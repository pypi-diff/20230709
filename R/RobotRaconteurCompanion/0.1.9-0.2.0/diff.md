# Comparing `tmp/RobotRaconteurCompanion-0.1.9-py3-none-any.whl.zip` & `tmp/RobotRaconteurCompanion-0.2.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,69 +1,67 @@
-Zip file size: 59822 bytes, number of entries: 67
--rw-rw-rw-  2.0 fat      367 b- defN 21-Mar-15 00:38 RobotRaconteurCompanion/__init__.py
--rw-rw-rw-  2.0 fat    11362 b- defN 21-Apr-07 03:18 RobotRaconteurCompanion/InfoParser/__init__.py
--rw-rw-rw-  2.0 fat     2150 b- defN 21-Apr-05 21:13 RobotRaconteurCompanion/StdRobDef/__init__.py
--rw-rw-rw-  2.0 fat      195 b- defN 21-Mar-21 03:22 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.action.robdef
--rw-rw-rw-  2.0 fat     2291 b- defN 21-Apr-05 20:32 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.actuator.robdef
--rw-rw-rw-  2.0 fat      393 b- defN 21-Mar-21 03:35 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.bignum.robdef
--rw-rw-rw-  2.0 fat      836 b- defN 21-Mar-21 03:24 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.color.robdef
--rw-rw-rw-  2.0 fat     1066 b- defN 21-Mar-21 03:24 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.datatype.robdef
--rw-rw-rw-  2.0 fat     1076 b- defN 21-Mar-21 03:25 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.datetime.clock.robdef
--rw-rw-rw-  2.0 fat     1492 b- defN 21-Mar-19 02:15 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.datetime.robdef
--rw-rw-rw-  2.0 fat      390 b- defN 20-Nov-24 23:35 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.device.clock.robdef
--rw-rw-rw-  2.0 fat      392 b- defN 21-Mar-21 03:25 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.device.isoch.robdef
--rw-rw-rw-  2.0 fat     1690 b- defN 21-Mar-21 03:03 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.device.robdef
--rw-rw-rw-  2.0 fat     1906 b- defN 21-Mar-21 03:22 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.eventlog.robdef
--rw-rw-rw-  2.0 fat     3195 b- defN 21-Mar-29 01:51 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.fiducial.robdef
--rw-rw-rw-  2.0 fat     3013 b- defN 21-Mar-21 03:25 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.geometry.robdef
--rw-rw-rw-  2.0 fat     2193 b- defN 21-Mar-19 23:44 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.geometry.shapes.robdef
--rw-rw-rw-  2.0 fat     3014 b- defN 21-Mar-21 03:25 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.geometryf.robdef
--rw-rw-rw-  2.0 fat     2978 b- defN 21-Mar-21 03:25 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.geometryi.robdef
--rw-rw-rw-  2.0 fat     2552 b- defN 21-Mar-29 01:31 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.gps.robdef
--rw-rw-rw-  2.0 fat     3076 b- defN 21-Apr-05 20:45 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.hid.joystick.robdef
--rw-rw-rw-  2.0 fat      196 b- defN 21-Mar-21 03:25 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.identifier.robdef
--rw-rw-rw-  2.0 fat     2583 b- defN 21-Apr-05 05:07 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.image.robdef
--rw-rw-rw-  2.0 fat     1048 b- defN 20-Nov-07 02:10 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.imaging.camerainfo.robdef
--rw-rw-rw-  2.0 fat     4237 b- defN 21-Mar-21 03:25 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.imaging.robdef
--rw-rw-rw-  2.0 fat     1187 b- defN 21-Mar-29 01:31 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.imu.robdef
--rw-rw-rw-  2.0 fat     2204 b- defN 21-Apr-05 20:49 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.laserscan.robdef
--rw-rw-rw-  2.0 fat     1315 b- defN 21-Mar-29 01:31 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.laserscanner.robdef
--rw-rw-rw-  2.0 fat     1081 b- defN 20-Sep-30 04:23 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.lighting.robdef
--rw-rw-rw-  2.0 fat     3061 b- defN 21-Mar-29 01:31 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.objectrecognition.robdef
--rw-rw-rw-  2.0 fat      939 b- defN 21-Apr-05 20:50 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.octree.robdef
--rw-rw-rw-  2.0 fat      747 b- defN 21-Mar-21 03:26 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.param.robdef
--rw-rw-rw-  2.0 fat      229 b- defN 21-Mar-21 03:26 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.pid.robdef
--rw-rw-rw-  2.0 fat     2929 b- defN 21-Apr-05 20:51 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.pointcloud.robdef
--rw-rw-rw-  2.0 fat     4624 b- defN 21-Mar-29 01:31 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.pointcloud.sensor.robdef
--rw-rw-rw-  2.0 fat     1539 b- defN 21-Mar-21 21:02 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.resource.device.robdef
--rw-rw-rw-  2.0 fat     2137 b- defN 21-Mar-21 20:58 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.resource.robdef
--rw-rw-rw-  2.0 fat     2297 b- defN 20-Nov-07 02:54 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.robotics.joints.robdef
--rw-rw-rw-  2.0 fat      521 b- defN 21-Mar-21 03:26 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.robotics.payload.robdef
--rw-rw-rw-  2.0 fat    10184 b- defN 20-Nov-07 02:55 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.robotics.planning.robdef
--rw-rw-rw-  2.0 fat     8700 b- defN 21-Mar-21 03:27 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.robotics.robot.robdef
--rw-rw-rw-  2.0 fat     2041 b- defN 20-Oct-30 06:03 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.robotics.scene.robdef
--rw-rw-rw-  2.0 fat     3731 b- defN 21-Mar-21 03:27 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.robotics.tool.robdef
--rw-rw-rw-  2.0 fat     3060 b- defN 20-Oct-30 06:03 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.robotics.trajectory.robdef
--rw-rw-rw-  2.0 fat     5569 b- defN 21-Apr-05 21:00 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.sensor.robdef
--rw-rw-rw-  2.0 fat      641 b- defN 21-Mar-21 03:27 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.sensordata.robdef
--rw-rw-rw-  2.0 fat     4308 b- defN 21-Mar-21 03:27 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.servo.robdef
--rw-rw-rw-  2.0 fat     2625 b- defN 21-Mar-21 03:42 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.signal.robdef
--rw-rw-rw-  2.0 fat      135 b- defN 21-Mar-21 03:27 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.units.robdef
--rw-rw-rw-  2.0 fat      104 b- defN 21-Mar-21 03:27 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.uuid.robdef
--rw-rw-rw-  2.0 fat     1438 b- defN 20-Nov-29 03:39 RobotRaconteurCompanion/Util/AttributesUtil.py
--rw-rw-rw-  2.0 fat     2651 b- defN 21-Mar-15 00:43 RobotRaconteurCompanion/Util/DateTimeUtil.py
--rw-rw-rw-  2.0 fat    14718 b- defN 21-Apr-18 01:32 RobotRaconteurCompanion/Util/GeometryUtil.py
--rw-rw-rw-  2.0 fat     4081 b- defN 21-Mar-15 00:42 RobotRaconteurCompanion/Util/IdentifierUtil.py
--rw-rw-rw-  2.0 fat     7999 b- defN 21-Apr-16 03:59 RobotRaconteurCompanion/Util/ImageUtil.py
--rw-rw-rw-  2.0 fat     2416 b- defN 20-Nov-29 04:17 RobotRaconteurCompanion/Util/InfoFileLoader.py
--rw-rw-rw-  2.0 fat     5604 b- defN 20-Nov-28 08:26 RobotRaconteurCompanion/Util/LocalIdentifiersManager.py
--rw-rw-rw-  2.0 fat     1077 b- defN 21-Feb-01 04:44 RobotRaconteurCompanion/Util/RobDef.py
--rw-rw-rw-  2.0 fat     4269 b- defN 21-Apr-10 06:10 RobotRaconteurCompanion/Util/RobotUtil.py
--rw-rw-rw-  2.0 fat     3741 b- defN 21-Apr-22 02:28 RobotRaconteurCompanion/Util/RobustFunctionCaller.py
--rw-rw-rw-  2.0 fat     1162 b- defN 21-Mar-15 00:42 RobotRaconteurCompanion/Util/SensorDataUtil.py
--rw-rw-rw-  2.0 fat     1090 b- defN 21-Mar-15 00:42 RobotRaconteurCompanion/Util/UuidUtil.py
--rw-rw-rw-  2.0 fat    11554 b- defN 21-Apr-23 03:32 RobotRaconteurCompanion-0.1.9.dist-info/LICENSE.txt
--rw-rw-rw-  2.0 fat      528 b- defN 21-Apr-23 03:32 RobotRaconteurCompanion-0.1.9.dist-info/METADATA
--rw-rw-rw-  2.0 fat       97 b- defN 21-Apr-23 03:32 RobotRaconteurCompanion-0.1.9.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       24 b- defN 21-Apr-23 03:32 RobotRaconteurCompanion-0.1.9.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     7932 b- defN 21-Apr-23 03:32 RobotRaconteurCompanion-0.1.9.dist-info/RECORD
-67 files, 189980 bytes uncompressed, 46344 bytes compressed:  75.6%
+Zip file size: 61539 bytes, number of entries: 65
+-rw-rw-rw-  2.0 fat      355 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/__init__.py
+-rw-rw-rw-  2.0 fat    13037 b- defN 23-Jul-09 05:59 RobotRaconteurCompanion/InfoParser/__init__.py
+-rw-rw-rw-  2.0 fat     2454 b- defN 23-Jul-09 05:59 RobotRaconteurCompanion/StdRobDef/__init__.py
+-rw-rw-rw-  2.0 fat      182 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.action.robdef
+-rw-rw-rw-  2.0 fat     2197 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.actuator.robdef
+-rw-rw-rw-  2.0 fat      373 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.bignum.robdef
+-rw-rw-rw-  2.0 fat      781 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.color.robdef
+-rw-rw-rw-  2.0 fat     1005 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.datatype.robdef
+-rw-rw-rw-  2.0 fat     1042 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.datetime.clock.robdef
+-rw-rw-rw-  2.0 fat     1415 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.datetime.robdef
+-rw-rw-rw-  2.0 fat      372 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.device.clock.robdef
+-rw-rw-rw-  2.0 fat      374 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.device.isoch.robdef
+-rw-rw-rw-  2.0 fat     1626 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.device.robdef
+-rw-rw-rw-  2.0 fat     1835 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.eventlog.robdef
+-rw-rw-rw-  2.0 fat     3100 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.fiducial.robdef
+-rw-rw-rw-  2.0 fat     2840 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.geometry.robdef
+-rw-rw-rw-  2.0 fat     2094 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.geometry.shapes.robdef
+-rw-rw-rw-  2.0 fat     2841 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.geometryf.robdef
+-rw-rw-rw-  2.0 fat     2805 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.geometryi.robdef
+-rw-rw-rw-  2.0 fat     2454 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.gps.robdef
+-rw-rw-rw-  2.0 fat     2967 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.hid.joystick.robdef
+-rw-rw-rw-  2.0 fat      184 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.identifier.robdef
+-rw-rw-rw-  2.0 fat     2459 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.image.robdef
+-rw-rw-rw-  2.0 fat     1006 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.imaging.camerainfo.robdef
+-rw-rw-rw-  2.0 fat     4111 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.imaging.robdef
+-rw-rw-rw-  2.0 fat     1151 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.imu.robdef
+-rw-rw-rw-  2.0 fat     2121 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.laserscan.robdef
+-rw-rw-rw-  2.0 fat     1277 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.laserscanner.robdef
+-rw-rw-rw-  2.0 fat     1039 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.lighting.robdef
+-rw-rw-rw-  2.0 fat     2978 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.objectrecognition.robdef
+-rw-rw-rw-  2.0 fat      896 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.octree.robdef
+-rw-rw-rw-  2.0 fat      721 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.param.robdef
+-rw-rw-rw-  2.0 fat      216 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.pid.robdef
+-rw-rw-rw-  2.0 fat     2813 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.pointcloud.robdef
+-rw-rw-rw-  2.0 fat     4502 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.pointcloud.sensor.robdef
+-rw-rw-rw-  2.0 fat     1506 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.resource.device.robdef
+-rw-rw-rw-  2.0 fat     2073 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.resource.robdef
+-rw-rw-rw-  2.0 fat     2182 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.robotics.joints.robdef
+-rw-rw-rw-  2.0 fat      502 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.robotics.payload.robdef
+-rw-rw-rw-  2.0 fat     8441 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.robotics.robot.robdef
+-rw-rw-rw-  2.0 fat     3601 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.robotics.tool.robdef
+-rw-rw-rw-  2.0 fat     2952 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.robotics.trajectory.robdef
+-rw-rw-rw-  2.0 fat     5361 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.sensor.robdef
+-rw-rw-rw-  2.0 fat      616 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.sensordata.robdef
+-rw-rw-rw-  2.0 fat     4166 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.servo.robdef
+-rw-rw-rw-  2.0 fat     2522 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.signal.robdef
+-rw-rw-rw-  2.0 fat      127 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.units.robdef
+-rw-rw-rw-  2.0 fat       97 b- defN 22-Dec-18 04:18 RobotRaconteurCompanion/StdRobDef/com.robotraconteur.uuid.robdef
+-rw-rw-rw-  2.0 fat     2456 b- defN 23-Jul-09 05:59 RobotRaconteurCompanion/Util/AttributesUtil.py
+-rw-rw-rw-  2.0 fat     5188 b- defN 23-Jul-09 05:59 RobotRaconteurCompanion/Util/DateTimeUtil.py
+-rw-rw-rw-  2.0 fat    31608 b- defN 23-Jul-09 05:59 RobotRaconteurCompanion/Util/GeometryUtil.py
+-rw-rw-rw-  2.0 fat     7229 b- defN 23-Jul-09 05:59 RobotRaconteurCompanion/Util/IdentifierUtil.py
+-rw-rw-rw-  2.0 fat    10396 b- defN 23-Jul-09 05:59 RobotRaconteurCompanion/Util/ImageUtil.py
+-rw-rw-rw-  2.0 fat     4070 b- defN 23-Jul-09 05:59 RobotRaconteurCompanion/Util/InfoFileLoader.py
+-rw-rw-rw-  2.0 fat     2553 b- defN 23-Jul-09 05:59 RobotRaconteurCompanion/Util/LocalIdentifiersManager.py
+-rw-rw-rw-  2.0 fat     2327 b- defN 23-Jul-09 05:59 RobotRaconteurCompanion/Util/RobDef.py
+-rw-rw-rw-  2.0 fat     5951 b- defN 23-Jul-09 05:59 RobotRaconteurCompanion/Util/RobotUtil.py
+-rw-rw-rw-  2.0 fat     4768 b- defN 23-Jul-09 05:59 RobotRaconteurCompanion/Util/RobustFunctionCaller.py
+-rw-rw-rw-  2.0 fat     1834 b- defN 23-Jul-09 05:59 RobotRaconteurCompanion/Util/SensorDataUtil.py
+-rw-rw-rw-  2.0 fat     2473 b- defN 23-Jul-09 05:59 RobotRaconteurCompanion/Util/UuidUtil.py
+-rw-rw-rw-  2.0 fat    11354 b- defN 23-Jul-09 06:00 RobotRaconteurCompanion-0.2.0.dist-info/LICENSE.txt
+-rw-rw-rw-  2.0 fat      547 b- defN 23-Jul-09 06:00 RobotRaconteurCompanion-0.2.0.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-Jul-09 06:00 RobotRaconteurCompanion-0.2.0.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       24 b- defN 23-Jul-09 06:00 RobotRaconteurCompanion-0.2.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     7666 b- defN 23-Jul-09 06:00 RobotRaconteurCompanion-0.2.0.dist-info/RECORD
+65 files, 206305 bytes uncompressed, 48515 bytes compressed:  76.5%
```

## zipnote {}

```diff
@@ -111,23 +111,17 @@
 
 Filename: RobotRaconteurCompanion/StdRobDef/com.robotraconteur.robotics.joints.robdef
 Comment: 
 
 Filename: RobotRaconteurCompanion/StdRobDef/com.robotraconteur.robotics.payload.robdef
 Comment: 
 
-Filename: RobotRaconteurCompanion/StdRobDef/com.robotraconteur.robotics.planning.robdef
-Comment: 
-
 Filename: RobotRaconteurCompanion/StdRobDef/com.robotraconteur.robotics.robot.robdef
 Comment: 
 
-Filename: RobotRaconteurCompanion/StdRobDef/com.robotraconteur.robotics.scene.robdef
-Comment: 
-
 Filename: RobotRaconteurCompanion/StdRobDef/com.robotraconteur.robotics.tool.robdef
 Comment: 
 
 Filename: RobotRaconteurCompanion/StdRobDef/com.robotraconteur.robotics.trajectory.robdef
 Comment: 
 
 Filename: RobotRaconteurCompanion/StdRobDef/com.robotraconteur.sensor.robdef
@@ -180,23 +174,23 @@
 
 Filename: RobotRaconteurCompanion/Util/SensorDataUtil.py
 Comment: 
 
 Filename: RobotRaconteurCompanion/Util/UuidUtil.py
 Comment: 
 
-Filename: RobotRaconteurCompanion-0.1.9.dist-info/LICENSE.txt
+Filename: RobotRaconteurCompanion-0.2.0.dist-info/LICENSE.txt
 Comment: 
 
-Filename: RobotRaconteurCompanion-0.1.9.dist-info/METADATA
+Filename: RobotRaconteurCompanion-0.2.0.dist-info/METADATA
 Comment: 
 
-Filename: RobotRaconteurCompanion-0.1.9.dist-info/WHEEL
+Filename: RobotRaconteurCompanion-0.2.0.dist-info/WHEEL
 Comment: 
 
-Filename: RobotRaconteurCompanion-0.1.9.dist-info/top_level.txt
+Filename: RobotRaconteurCompanion-0.2.0.dist-info/top_level.txt
 Comment: 
 
-Filename: RobotRaconteurCompanion-0.1.9.dist-info/RECORD
+Filename: RobotRaconteurCompanion-0.2.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## RobotRaconteurCompanion/__init__.py

 * *Ordering differences only*

```diff
@@ -1,13 +1,13 @@
-from __future__ import absolute_import
-
-try:
-    from .StdRobDef import RegisterStdRobDefServiceTypes
-except:
-    import warnings
-    warnings.warn("Could not initialize RobotRaconteurCompanion.StdRobDef")
-
-try:
-    from .InfoParser import InfoParser
-except:
-    import warnings
+from __future__ import absolute_import
+
+try:
+    from .StdRobDef import RegisterStdRobDefServiceTypes
+except:
+    import warnings
+    warnings.warn("Could not initialize RobotRaconteurCompanion.StdRobDef")
+
+try:
+    from .InfoParser import InfoParser
+except:
+    import warnings
     warnings.warn("Could not initialize RobotRaconteurCompanion.InfoParser")
```

## RobotRaconteurCompanion/InfoParser/__init__.py

```diff
@@ -1,267 +1,309 @@
-import yaml
-import RobotRaconteur as RR
-from RobotRaconteur.RobotRaconteurPythonUtil import SplitQualifiedName
-import traceback
-import numpy as np
-import uuid
-
-def _find_by_name(v,name):
-    for i in v:
-        if (i.Name==name):
-            return i
-    return None
-
-class InfoParser(object):
-    def __init__(self, node = None, client_obj = None):
-        if node is None:
-            self.node = RR.RobotRaconteurNode.s
-        else:
-            self.node = node
-        self.client_obj = client_obj
-
-    def _find_namedarray(self, n):
-        try:
-            dtype = self.node.GetNamedArrayDType(n,self.client_obj)
-        except:
-            return None, None
-        service_name, n1 = SplitQualifiedName(n)
-        type_def = _find_by_name(self.node.GetServiceType(service_name).NamedArrays,n1)
-        assert type_def is not None
-        return dtype, type_def
-
-    def _find_structure(self, s):
-        try:
-            stype = self.node.GetStructureType(s,self.client_obj)
-        except:
-            return None, None
-        service_name, s1 = SplitQualifiedName(s)
-        type_def = _find_by_name(self.node.GetServiceType(service_name).Structures,s1)
-        assert type_def is not None
-        return stype, type_def
-
-    def _find_enum(self, s):
-        service_name, s1 = SplitQualifiedName(s)
-        try:
-            return _find_by_name(self.node.GetServiceType(service_name).Enums,s1)
-        except:
-            return None
-    
-    def _rr_type_to_dtype(self,rr_type_code):
-        if rr_type_code == RR.DataTypes_double_t:
-            return np.float64
-        if rr_type_code == RR.DataTypes_single_t:
-            return np.float32
-        if rr_type_code == RR.DataTypes_int8_t:
-            return np.int8
-        if rr_type_code == RR.DataTypes_uint8_t:
-            return np.uint8
-        if rr_type_code == RR.DataTypes_int16_t:
-            return np.int16
-        if rr_type_code == RR.DataTypes_uint16_t:
-            return np.uint16
-        if rr_type_code == RR.DataTypes_int32_t:
-            return np.int32
-        if rr_type_code == RR.DataTypes_uint32_t:
-            return np.uint32
-        if rr_type_code == RR.DataTypes_int64_t:
-            return np.int64
-        if rr_type_code == RR.DataTypes_uint64_t:
-            return np.uint64        
-    
-    def _check_array_len(self,arr,type_def):
-        if type_def.ArrayVarLength == True:
-            if len(type_def.ArrayLength) == 0 or type_def.ArrayLength[0] == 0:
-                return True
-            if len(arr) <= type_def.ArrayLength[0]:
-                return True
-            return False
-        else:
-            return len(arr) == type_def.ArrayLength[0]
-
-    def _parse_number(self,d,type_def):
-        if type_def.ArrayType == RR.DataTypes_ArrayTypes_none:
-            if type_def.Type == RR.DataTypes_double_t or type_def.Type == RR.DataTypes_single_t:
-                return float(d)
-            else:
-                if isinstance(d,str):
-                    return int(d,0)
-                else:                    
-                        return int(d)
-        elif type_def.ArrayType == RR.DataTypes_ArrayTypes_array:
-            f_dtype = self._rr_type_to_dtype(type_def.Type)
-            arr = np.array(d,dtype=f_dtype)
-            assert self._check_array_len(arr,type_def)
-            return arr
-        elif type_def.ArrayType == RR.DataTypes_ArrayTypes_multidimarray:
-            # TODO: handle more than fixed 2D multidim arrays
-            if len(type_def.ArrayLength) != 2:
-                return None
-            f_dtype = self._rr_type_to_dtype(type_def.Type)
-            arr = np.array(d,dtype=f_dtype)
-            return arr.reshape(type_def.ArrayLength,order="F")
-        else:
-            return None
-
-    def _parse_structure(self, d, struct_type, struct_def):        
-        service_def = struct_def.GetServiceDefinition()
-        struct_type_name = service_def.Name + "." + struct_def.Name
-        s_override = "_override_structure_" + struct_type_name.replace(".","__")
-        if hasattr(self,s_override):
-            ov_res,ov_val = getattr(self,s_override)(d,struct_type,struct_def)
-            if ov_res:
-                return ov_val
-        ret = struct_type()
-        for i in range(len(struct_def.Members)):
-            f_def = struct_def.Members[i]
-            f_name = f_def.Name
-            if not f_name in d:
-                continue
-            f_override = "_override_field_" + (service_def.Name + "." + struct_def.Name + "." + f_def.Name).replace(".","__")
-            if hasattr(self,f_override):
-               f_res = getattr(self,f_override)(d[f_name],f_def.Type,service_def)
-               setattr(ret,f_name,f_res)
-               continue
-            f_res,f_val = self._parse_field_value(d[f_name], f_def.Type, struct_def, service_def)
-            if f_res:
-                setattr(ret,f_name,f_val)
-                continue
-
-        return ret
-        
-    def _parse_field_value(self, d, f_type, struct_def, service_def):
-        
-        if f_type.ContainerType != RR.DataTypes_ContainerTypes_none:
-            f_type_e = f_type.Clone()
-            f_type_e.RemoveContainers()
-            if f_type.ContainerType == RR.DataTypes_ContainerTypes_list:
-                ret = []
-                for e in d:
-                    e_res,e_val = self._parse_field_value(e,f_type_e,struct_def,service_def)
-                    assert e_res
-                    ret.append(e_val)
-                return True,ret
-            if f_type.ContainerType == RR.DataTypes_ContainerTypes_map_int32:
-                ret = {}
-                for k,v in d:
-                    e_res,e_val = self._parse_field_value(e,f_type_e,struct_def,service_def)
-                    assert e_res
-                    ret[int(k,0)] = e_val
-                return True,ret
-            if f_type.ContainerType == RR.DataTypes_ContainerTypes_map_string:
-                ret = {}
-                for k,v in d:
-                    e_res,e_val = self._parse_field_value(e,f_type_e,struct_def,service_def)
-                    assert e_res
-                    ret[str(k)] = e_val
-                return True,ret
-        if RR.IsTypeNumeric(f_type.Type):
-            f_res = self._parse_number(d,f_type)
-            if f_res is not None:
-                return True, f_res
-        
-        if f_type.Type == RR.DataTypes_string_t:
-            return True,str(d)
-            
-        
-        if f_type.Type == RR.DataTypes_namedtype_t:
-            typename = f_type.TypeString
-            if "." not in typename:
-                typename = service_def.Name + "." + typename            
-            s_type, s_def = self._find_structure(typename)
-            if s_type is not None:
-                return True, self._parse_structure(d,s_type,s_def)
-            n_dtype, n_def = self._find_namedarray(typename)
-            if n_dtype is not None:
-                return True, self._parse_namedarray(d,f_type,n_dtype,n_def)
-            e_def = self._find_enum(typename)
-            if e_def is not None:
-                enum_val = _find_by_name(e_def.Values,str(d))
-                assert enum_val is not None, "Invalid enum value"
-                return True, int(enum_val.Value)           
-        return False,None        
-
-    def _parse_namedarray_el(self, d, arr, ind, d_type):
-        
-        for k,v in d_type.fields.items():
-            if v[0].fields is not None:
-                self._parse_namedarray_el(d[k],arr[ind],k,v[0])
-            else:
-                arr[ind][k] = np.array(d[k],dtype=v[0])   
-
-    def _parse_namedarray(self, d, f_type, namedarray_dtype, namedarray_def):
-        service_def = namedarray_def.GetServiceDefinition()
-        namedarray_type_name = service_def.Name + "." + namedarray_def.Name
-        n_override = "_override_namedarray_" + namedarray_type_name.replace(".","__")
-        if hasattr(self,n_override):
-            return getattr(self,n_override)(d,f_type,namedarray_dtype,namedarray_def)
-        if f_type.ArrayType == RR.DataTypes_ArrayTypes_none:
-            arr = np.zeros((1,),dtype=namedarray_dtype)
-            self._parse_namedarray_el(d,arr,0,namedarray_dtype)
-            return arr
-        if f_type.ArrayType == RR.DataTypes_ArrayTypes_array:
-            n = len(d)
-            arr = np.zeros((n,),dtype=namedarray_dtype)
-            for i in range(n):
-                self._parse_namedarray_el(d[i],arr,i,namedarray_dtype)
-            return arr
-        return None
-
-    def ParseInfoFile(self, filename, type_name):
-        struct_type = self._find_structure(type_name)
-
-        with open(filename, 'r') as f:
-            file_text = f.read()
-
-        return ParseInfoString(self, file_text, type_name)
-
-    def ParseInfoString(self, info_string, type_name):
-        struct_type, struct_def = self._find_structure(type_name)
-        if struct_type is None:
-            raise RR.InvalidArgumentException("Invalid structure type specified")
-        
-        d = yaml.safe_load(info_string)
-        
-        ret = self._parse_structure(d,struct_type,struct_def)
-        return ret
-
-    ## Overrides for standard types
-
-    def _override_field_com__robotraconteur__robotics__robot__RobotInfo__robot_capabilities(self, d, f_type, service_def):
-        enum_def = _find_by_name(service_def.Enums,"RobotCapabilities")
-        return self._flags_override(d,enum_def)
-    
-    def _override_field_com__robotraconteur__robotics__tool__ToolInfo__tool_capabilities(self, d, f_type, service_def):
-        enum_def = _find_by_name(service_def.Enums,"ToolCapabilities")
-        return self._flags_override(d,enum_def)
-
-    def _override_field_com__robotraconteur__servo__ServoInfo__capabilities(self, d, f_type, service_def):
-        enum_def = _find_by_name(service_def.Enums,"ServoCapabilities")
-        return self._flags_override(d,enum_def)
-
-    def _flags_override(self, d, enum_def):
-        ret = 0
-        for e in d:
-            enum_val = _find_by_name(enum_def.Values,e)
-            assert enum_val is not None, "Invalid flag name"
-            ret |= int(enum_val.Value)
-        return ret
-
-    def _override_namedarray_com__robotraconteur__uuid__UUID(self,d,f_type,namedarray_dtype,namedarray_def):
-        ret_uuid = uuid.UUID(str(d))
-        ret_bytes = np.frombuffer(ret_uuid.bytes,dtype=np.uint8)
-        ret = np.zeros((1,),dtype=namedarray_dtype)
-        ret[0]["uuid_bytes"]=ret_bytes
-        return ret
-
-    def _override_structure_com__robotraconteur__identifier__Identifier(self, d, struct_type, struct_def):        
-        if isinstance(d,str) or isinstance(d,int) or isinstance(d,float):
-            ret = struct_type()
-            ret.name = str(d)
-            return True,ret
-        return False,None
-
-    def _override_field_com__robotraconteur__imaging__camerainfo__CameraCalibration__distortion_info(self,d,f_type,service_def):
-        s_type,s_def = self._find_structure('com.robotraconteur.imaging.camerainfo.PlumbBobDistortionInfo')
-        assert s_type is not None
-        return RR.VarValue(self._parse_structure(d,s_type,s_def),'com.robotraconteur.imaging.camerainfo.PlumbBobDistortionInfo')
+import yaml
+import RobotRaconteur as RR
+from RobotRaconteur.RobotRaconteurPythonUtil import SplitQualifiedName
+import traceback
+import numpy as np
+import uuid
+
+def _find_by_name(v,name):
+    for i in v:
+        if (i.Name==name):
+            return i
+    return None
+
+class InfoParser(object):
+    """
+    Class to load YAML info files into Robot Raconteur device info structures. This wil
+    typically be called from InfoFileLoader instead of being called directly.
+
+    :param node: (optional) The Robot Raconteur node to use for parsing. Defaults to RobotRaconteurNode.s
+    :type node: RobotRaconteur.RobotRaconteurNode
+    :param client_obj: (optional) The client object to use for finding types. Defaults to None
+    :type client_obj: RobotRaconteur.ClientObject
+
+    """
+
+    def __init__(self, node = None, client_obj = None):
+        if node is None:
+            self.node = RR.RobotRaconteurNode.s
+        else:
+            self.node = node
+        self.client_obj = client_obj
+
+    def _find_namedarray(self, n):
+        try:
+            dtype = self.node.GetNamedArrayDType(n,self.client_obj)
+        except:
+            return None, None
+        service_name, n1 = SplitQualifiedName(n)
+        type_def = _find_by_name(self.node.GetServiceType(service_name).NamedArrays,n1)
+        assert type_def is not None
+        return dtype, type_def
+
+    def _find_structure(self, s):
+        try:
+            stype = self.node.GetStructureType(s,self.client_obj)
+        except:
+            return None, None
+        service_name, s1 = SplitQualifiedName(s)
+        type_def = _find_by_name(self.node.GetServiceType(service_name).Structures,s1)
+        assert type_def is not None
+        return stype, type_def
+
+    def _find_enum(self, s):
+        service_name, s1 = SplitQualifiedName(s)
+        try:
+            return _find_by_name(self.node.GetServiceType(service_name).Enums,s1)
+        except:
+            return None
+    
+    def _rr_type_to_dtype(self,rr_type_code):
+        if rr_type_code == RR.DataTypes_double_t:
+            return np.float64
+        if rr_type_code == RR.DataTypes_single_t:
+            return np.float32
+        if rr_type_code == RR.DataTypes_int8_t:
+            return np.int8
+        if rr_type_code == RR.DataTypes_uint8_t:
+            return np.uint8
+        if rr_type_code == RR.DataTypes_int16_t:
+            return np.int16
+        if rr_type_code == RR.DataTypes_uint16_t:
+            return np.uint16
+        if rr_type_code == RR.DataTypes_int32_t:
+            return np.int32
+        if rr_type_code == RR.DataTypes_uint32_t:
+            return np.uint32
+        if rr_type_code == RR.DataTypes_int64_t:
+            return np.int64
+        if rr_type_code == RR.DataTypes_uint64_t:
+            return np.uint64        
+    
+    def _check_array_len(self,arr,type_def):
+        if type_def.ArrayVarLength == True:
+            if len(type_def.ArrayLength) == 0 or type_def.ArrayLength[0] == 0:
+                return True
+            if len(arr) <= type_def.ArrayLength[0]:
+                return True
+            return False
+        else:
+            return len(arr) == type_def.ArrayLength[0]
+
+    def _parse_number(self,d,type_def):
+        if type_def.ArrayType == RR.DataTypes_ArrayTypes_none:
+            if type_def.Type == RR.DataTypes_bool_t:
+                return bool(d)
+            if type_def.Type == RR.DataTypes_double_t or type_def.Type == RR.DataTypes_single_t:
+                return float(d)
+            else:
+                if isinstance(d,str):
+                    return int(d,0)
+                else:                    
+                        return int(d)
+        elif type_def.ArrayType == RR.DataTypes_ArrayTypes_array:
+            f_dtype = self._rr_type_to_dtype(type_def.Type)
+            arr = np.array(d,dtype=f_dtype)
+            assert self._check_array_len(arr,type_def)
+            return arr
+        elif type_def.ArrayType == RR.DataTypes_ArrayTypes_multidimarray:
+            # TODO: handle more than fixed 2D multidim arrays
+            if len(type_def.ArrayLength) != 2:
+                return None
+            f_dtype = self._rr_type_to_dtype(type_def.Type)
+            arr = np.array(d,dtype=f_dtype)
+            return arr.reshape(type_def.ArrayLength,order="F")
+        else:
+            return None
+
+    def _parse_structure(self, d, struct_type, struct_def):        
+        service_def = struct_def.GetServiceDefinition()
+        struct_type_name = service_def.Name + "." + struct_def.Name
+        s_override = "_override_structure_" + struct_type_name.replace(".","__")
+        if hasattr(self,s_override):
+            ov_res,ov_val = getattr(self,s_override)(d,struct_type,struct_def)
+            if ov_res:
+                return ov_val
+        ret = struct_type()
+        for i in range(len(struct_def.Members)):
+            f_def = struct_def.Members[i]
+            f_name = f_def.Name
+            if not f_name in d:
+                continue
+            f_override = "_override_field_" + (service_def.Name + "." + struct_def.Name + "." + f_def.Name).replace(".","__")
+            if hasattr(self,f_override):
+               f_res = getattr(self,f_override)(d[f_name],f_def.Type,service_def)
+               setattr(ret,f_name,f_res)
+               continue
+            f_res,f_val = self._parse_field_value(d[f_name], f_def.Type, struct_def, service_def)
+            if f_res:
+                setattr(ret,f_name,f_val)
+                continue
+
+        return ret
+        
+    def _parse_field_value(self, d, f_type, struct_def, service_def):
+        
+        if f_type.ContainerType != RR.DataTypes_ContainerTypes_none:
+            f_type_e = f_type.Clone()
+            f_type_e.RemoveContainers()
+            if f_type.ContainerType == RR.DataTypes_ContainerTypes_list:
+                ret = []
+                for e in d:
+                    e_res,e_val = self._parse_field_value(e,f_type_e,struct_def,service_def)
+                    assert e_res
+                    ret.append(e_val)
+                return True,ret
+            if f_type.ContainerType == RR.DataTypes_ContainerTypes_map_int32:
+                ret = {}
+                for k,v in d:
+                    e_res,e_val = self._parse_field_value(e,f_type_e,struct_def,service_def)
+                    assert e_res
+                    ret[int(k,0)] = e_val
+                return True,ret
+            if f_type.ContainerType == RR.DataTypes_ContainerTypes_map_string:
+                ret = {}
+                for k,v in d:
+                    e_res,e_val = self._parse_field_value(e,f_type_e,struct_def,service_def)
+                    assert e_res
+                    ret[str(k)] = e_val
+                return True,ret
+        if RR.IsTypeNumeric(f_type.Type):
+            f_res = self._parse_number(d,f_type)
+            if f_res is not None:
+                return True, f_res
+        
+        if f_type.Type == RR.DataTypes_string_t:
+            return True,str(d)
+            
+        
+        if f_type.Type == RR.DataTypes_namedtype_t:
+            typename = f_type.TypeString
+            if "." not in typename:
+                typename = service_def.Name + "." + typename            
+            s_type, s_def = self._find_structure(typename)
+            if s_type is not None:
+                return True, self._parse_structure(d,s_type,s_def)
+            n_dtype, n_def = self._find_namedarray(typename)
+            if n_dtype is not None:
+                return True, self._parse_namedarray(d,f_type,n_dtype,n_def)
+            e_def = self._find_enum(typename)
+            if e_def is not None:
+                enum_val = _find_by_name(e_def.Values,str(d))
+                assert enum_val is not None, "Invalid enum value"
+                return True, int(enum_val.Value)           
+        return False,None        
+
+    def _parse_namedarray_el(self, d, arr, ind, d_type):
+        
+        for k,v in d_type.fields.items():
+            if v[0].fields is not None:
+                self._parse_namedarray_el(d[k],arr[ind],k,v[0])
+            else:
+                arr[ind][k] = np.array(d[k],dtype=v[0])   
+
+    def _parse_namedarray(self, d, f_type, namedarray_dtype, namedarray_def):
+        service_def = namedarray_def.GetServiceDefinition()
+        namedarray_type_name = service_def.Name + "." + namedarray_def.Name
+        n_override = "_override_namedarray_" + namedarray_type_name.replace(".","__")
+        if hasattr(self,n_override):
+            return getattr(self,n_override)(d,f_type,namedarray_dtype,namedarray_def)
+        if f_type.ArrayType == RR.DataTypes_ArrayTypes_none:
+            arr = np.zeros((1,),dtype=namedarray_dtype)
+            self._parse_namedarray_el(d,arr,0,namedarray_dtype)
+            return arr
+        if f_type.ArrayType == RR.DataTypes_ArrayTypes_array:
+            n = len(d)
+            arr = np.zeros((n,),dtype=namedarray_dtype)
+            for i in range(n):
+                self._parse_namedarray_el(d[i],arr,i,namedarray_dtype)
+            return arr
+        return None
+
+    def ParseInfoFile(self, filename, type_name):
+        """
+        Load and parse a YAML file containing contents of a device info structure. The type_name 
+        must be the fully qualified name of the structure type. The structure type must be defined
+        in a service definition loaded into the node, or pulled by a client object.
+
+        :param filename: The filename of the YAML file to load
+        :type filename: str
+        :param type_name: The fully qualified name of the structure type. Examples include 
+          ``com.robotraconteur.robotics.robot.DeviceInfo`` and ``com.robotraconteur.robotics.robot.RobotInfo``
+        :type type_name: str
+        :return: The parsed structure
+
+        """
+
+        struct_type = self._find_structure(type_name)
+
+        with open(filename, 'r') as f:
+            file_text = f.read()
+
+        return self.ParseInfoString(file_text, type_name)
+
+    def ParseInfoString(self, info_string, type_name):
+        """
+        Parse a YAML string containing contents of a device info structure. The type_name
+        must be the fully qualified name of the structure type. The structure type must be defined
+        in a service definition loaded into the node, or pulled by a client object.
+
+        :param info_string: The YAML string to parse
+        :type info_string: str
+        :param type_name: The fully qualified name of the structure type. Examples include
+            ``com.robotraconteur.robotics.robot.DeviceInfo`` and ``com.robotraconteur.robotics.robot.RobotInfo``
+        :type type_name: str
+        :return: The parsed structure
+
+        """
+
+        struct_type, struct_def = self._find_structure(type_name)
+        if struct_type is None:
+            raise RR.InvalidArgumentException("Invalid structure type specified")
+        
+        d = yaml.safe_load(info_string)
+        
+        ret = self._parse_structure(d,struct_type,struct_def)
+        return ret
+
+    ## Overrides for standard types
+
+    def _override_field_com__robotraconteur__robotics__robot__RobotInfo__robot_capabilities(self, d, f_type, service_def):
+        enum_def = _find_by_name(service_def.Enums,"RobotCapabilities")
+        return self._flags_override(d,enum_def)
+    
+    def _override_field_com__robotraconteur__robotics__tool__ToolInfo__tool_capabilities(self, d, f_type, service_def):
+        enum_def = _find_by_name(service_def.Enums,"ToolCapabilities")
+        return self._flags_override(d,enum_def)
+
+    def _override_field_com__robotraconteur__servo__ServoInfo__capabilities(self, d, f_type, service_def):
+        enum_def = _find_by_name(service_def.Enums,"ServoCapabilities")
+        return self._flags_override(d,enum_def)
+
+    def _flags_override(self, d, enum_def):
+        ret = 0
+        for e in d:
+            enum_val = _find_by_name(enum_def.Values,e)
+            assert enum_val is not None, "Invalid flag name"
+            ret |= int(enum_val.Value)
+        return ret
+
+    def _override_namedarray_com__robotraconteur__uuid__UUID(self,d,f_type,namedarray_dtype,namedarray_def):
+        ret_uuid = uuid.UUID(str(d))
+        ret_bytes = np.frombuffer(ret_uuid.bytes,dtype=np.uint8)
+        ret = np.zeros((1,),dtype=namedarray_dtype)
+        ret[0]["uuid_bytes"]=ret_bytes
+        return ret
+
+    def _override_structure_com__robotraconteur__identifier__Identifier(self, d, struct_type, struct_def):        
+        if isinstance(d,str) or isinstance(d,int) or isinstance(d,float):
+            ret = struct_type()
+            ret.name = str(d)
+            ret.uuid = np.resize(ret.uuid,(1,))
+            return True,ret
+        return False,None
+
+    def _override_field_com__robotraconteur__imaging__camerainfo__CameraCalibration__distortion_info(self,d,f_type,service_def):
+        s_type,s_def = self._find_structure('com.robotraconteur.imaging.camerainfo.PlumbBobDistortionInfo')
+        assert s_type is not None
+        return RR.VarValue(self._parse_structure(d,s_type,s_def),'com.robotraconteur.imaging.camerainfo.PlumbBobDistortionInfo')
```

## RobotRaconteurCompanion/StdRobDef/__init__.py

```diff
@@ -1,62 +1,70 @@
-
-STANDARD_ROBDEF_NAMES = [
-    'com.robotraconteur.action',
-    'com.robotraconteur.actuator',
-    'com.robotraconteur.bignum',
-    'com.robotraconteur.color',
-    'com.robotraconteur.datatype',
-    'com.robotraconteur.datetime.clock',
-    'com.robotraconteur.datetime',
-    'com.robotraconteur.device.clock',
-    'com.robotraconteur.device.isoch',
-    'com.robotraconteur.device',
-    'com.robotraconteur.eventlog',
-    'com.robotraconteur.fiducial',
-    'com.robotraconteur.geometry',
-    'com.robotraconteur.geometry.shapes',
-    'com.robotraconteur.geometryf',
-    'com.robotraconteur.geometryi',
-    'com.robotraconteur.gps',
-    'com.robotraconteur.hid.joystick',
-    'com.robotraconteur.identifier',
-    'com.robotraconteur.image',
-    'com.robotraconteur.imaging.camerainfo',
-    'com.robotraconteur.imaging',
-    'com.robotraconteur.imu',
-    'com.robotraconteur.laserscan',
-    'com.robotraconteur.laserscanner',
-    'com.robotraconteur.lighting',
-    'com.robotraconteur.objectrecognition',
-    'com.robotraconteur.octree',
-    'com.robotraconteur.param',
-    'com.robotraconteur.pid',
-    'com.robotraconteur.pointcloud',
-    'com.robotraconteur.pointcloud.sensor',
-    'com.robotraconteur.resource',
-    'com.robotraconteur.resource.device',
-    'com.robotraconteur.robotics.joints',
-    'com.robotraconteur.robotics.payload',
-    'com.robotraconteur.robotics.robot',
-    'com.robotraconteur.robotics.tool',
-    'com.robotraconteur.robotics.trajectory',
-    'com.robotraconteur.sensor',
-    'com.robotraconteur.sensordata',
-    'com.robotraconteur.servo',
-    'com.robotraconteur.signal',
-    'com.robotraconteur.units',
-    'com.robotraconteur.uuid'
-]
-
-STANDARD_ROBDEF_TEXT={}
-
-def _load_standard_robdef_text():
-    import importlib_resources
-    for n in STANDARD_ROBDEF_NAMES:
-        robdef_text = importlib_resources.read_text(__package__, n + '.robdef')
-        STANDARD_ROBDEF_TEXT[n] = robdef_text
-
-_load_standard_robdef_text()
-
-def RegisterStdRobDefServiceTypes(node):
-    robdefs_text = list(STANDARD_ROBDEF_TEXT.values())
+
+STANDARD_ROBDEF_NAMES = [
+    'com.robotraconteur.action',
+    'com.robotraconteur.actuator',
+    'com.robotraconteur.bignum',
+    'com.robotraconteur.color',
+    'com.robotraconteur.datatype',
+    'com.robotraconteur.datetime.clock',
+    'com.robotraconteur.datetime',
+    'com.robotraconteur.device.clock',
+    'com.robotraconteur.device.isoch',
+    'com.robotraconteur.device',
+    'com.robotraconteur.eventlog',
+    'com.robotraconteur.fiducial',
+    'com.robotraconteur.geometry',
+    'com.robotraconteur.geometry.shapes',
+    'com.robotraconteur.geometryf',
+    'com.robotraconteur.geometryi',
+    'com.robotraconteur.gps',
+    'com.robotraconteur.hid.joystick',
+    'com.robotraconteur.identifier',
+    'com.robotraconteur.image',
+    'com.robotraconteur.imaging.camerainfo',
+    'com.robotraconteur.imaging',
+    'com.robotraconteur.imu',
+    'com.robotraconteur.laserscan',
+    'com.robotraconteur.laserscanner',
+    'com.robotraconteur.lighting',
+    'com.robotraconteur.objectrecognition',
+    'com.robotraconteur.octree',
+    'com.robotraconteur.param',
+    'com.robotraconteur.pid',
+    'com.robotraconteur.pointcloud',
+    'com.robotraconteur.pointcloud.sensor',
+    'com.robotraconteur.resource',
+    'com.robotraconteur.resource.device',
+    'com.robotraconteur.robotics.joints',
+    'com.robotraconteur.robotics.payload',
+    'com.robotraconteur.robotics.robot',
+    'com.robotraconteur.robotics.tool',
+    'com.robotraconteur.robotics.trajectory',
+    'com.robotraconteur.sensor',
+    'com.robotraconteur.sensordata',
+    'com.robotraconteur.servo',
+    'com.robotraconteur.signal',
+    'com.robotraconteur.units',
+    'com.robotraconteur.uuid'
+]
+
+STANDARD_ROBDEF_TEXT={}
+
+def _load_standard_robdef_text():
+    import importlib_resources
+    for n in STANDARD_ROBDEF_NAMES:
+        robdef_text = (importlib_resources.files() / (n + '.robdef')).read_text()
+        STANDARD_ROBDEF_TEXT[n] = robdef_text
+
+_load_standard_robdef_text()
+
+def RegisterStdRobDefServiceTypes(node):
+    """
+    Register standard Robot Raconteur service types to a node. This function will call RegisterServiceTypes() for
+    the standard services types to register them into the node.
+
+    :param node: The node to register the service types to. Typically this will be ``RRN`` for the default node.
+    :type node: RobotRaconteur.RobotRaconteurNode
+    """
+    
+    robdefs_text = list(STANDARD_ROBDEF_TEXT.values())
     node.RegisterServiceTypes(robdefs_text)
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.action.robdef

 * *Ordering differences only*

```diff
@@ -1,13 +1,13 @@
-service com.robotraconteur.action
-
-stdver 0.10
-
-enum ActionStatusCode
-    error = -3,
-    failed = -2,
-    cancelled = -1,
-    unknown = 0,
-    queued,
-    running,
-    complete
-end
+service com.robotraconteur.action
+
+stdver 0.10
+
+enum ActionStatusCode
+    error = -3,
+    failed = -2,
+    cancelled = -1,
+    unknown = 0,
+    queued,
+    running,
+    complete
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.actuator.robdef

 * *Ordering differences only*

```diff
@@ -1,94 +1,94 @@
-service com.robotraconteur.actuator
-
-stdver 0.10
-
-import com.robotraconteur.device
-import com.robotraconteur.param
-import com.robotraconteur.units
-import com.robotraconteur.datatype
-import com.robotraconteur.datetime
-
-using com.robotraconteur.device.DeviceInfo
-using com.robotraconteur.device.Device
-using com.robotraconteur.param.ParameterInfo
-using com.robotraconteur.units.SIUnit
-using com.robotraconteur.datatype.DataType
-using com.robotraconteur.datetime.TimeSpec3
-
-enum ActuatorTypeCode
-    unknown = 0,
-    generic,
-    position,
-    velocity,
-    acceleration,
-    effort,
-    motor_position,
-    motor_velocity,
-    motor_acceleration,
-    motor_effort,
-    solenoid,
-    voice_coil,
-    piezoelectric,
-    pneumatic_pressure,
-    vacuum_pressure,
-    heater_power,
-    chiller_power,
-    valve,
-    conveyor,
-    voltage,
-    current,
-    pneumatic_cylinder,
-    hydraulic_cylinder
-end
-
-enum ActuatorMode
-    error = -2,
-    disabled = -1,
-    halt = 0,
-    reduced_performance = 1,
-    normal = 2
-end
-
-enum ActuatorStateFlags
-    unknown = 0,
-    ready = 0x1,
-    streaming = 0x2,
-    warning = 0x4,
-    error = 0x8,
-    fatal_error = 0x10,
-    e_stop = 0x20,
-    homed = 0x40,
-    homing_required = 0x80,
-    communication_failure = 0x100,
-    valid_command = 0x200,
-    enabled = 0x400
-end
-
-struct ActuatorState
-    field TimeSpec3 ts
-    field uint64 seqno
-    field uint32 actuator_state_flags
-    field double[] actuator_command
-end
-
-struct ActuatorInfo
-    field DeviceInfo device_info
-    field ActuatorTypeCode actuator_type
-    field SIUnit{list} command_units
-    field DataType command_data_type
-    field double[] command_resolution
-    field bool analog_output
-    field ParameterInfo{list} parameter_info
-    field varvalue{string} extended
-end
-
-object Actuator
-    implements Device
-    property DeviceInfo device_info [readonly,nolock]
-    property ActuatorInfo actuator_info [readonly,nolock]
-    property ActuatorMode actuator_mode [nolockread]
-    wire double[] actuator_command [writeonly]
-    wire ActuatorState actuator_state [readonly,nolock]
-    function varvalue getf_param(string param_name)
-    function void setf_param(string param_name, varvalue value)
-end
+service com.robotraconteur.actuator
+
+stdver 0.10
+
+import com.robotraconteur.device
+import com.robotraconteur.param
+import com.robotraconteur.units
+import com.robotraconteur.datatype
+import com.robotraconteur.datetime
+
+using com.robotraconteur.device.DeviceInfo
+using com.robotraconteur.device.Device
+using com.robotraconteur.param.ParameterInfo
+using com.robotraconteur.units.SIUnit
+using com.robotraconteur.datatype.DataType
+using com.robotraconteur.datetime.TimeSpec3
+
+enum ActuatorTypeCode
+    unknown = 0,
+    generic,
+    position,
+    velocity,
+    acceleration,
+    effort,
+    motor_position,
+    motor_velocity,
+    motor_acceleration,
+    motor_effort,
+    solenoid,
+    voice_coil,
+    piezoelectric,
+    pneumatic_pressure,
+    vacuum_pressure,
+    heater_power,
+    chiller_power,
+    valve,
+    conveyor,
+    voltage,
+    current,
+    pneumatic_cylinder,
+    hydraulic_cylinder
+end
+
+enum ActuatorMode
+    error = -2,
+    disabled = -1,
+    halt = 0,
+    reduced_performance = 1,
+    normal = 2
+end
+
+enum ActuatorStateFlags
+    unknown = 0,
+    ready = 0x1,
+    streaming = 0x2,
+    warning = 0x4,
+    error = 0x8,
+    fatal_error = 0x10,
+    e_stop = 0x20,
+    homed = 0x40,
+    homing_required = 0x80,
+    communication_failure = 0x100,
+    valid_command = 0x200,
+    enabled = 0x400
+end
+
+struct ActuatorState
+    field TimeSpec3 ts
+    field uint64 seqno
+    field uint32 actuator_state_flags
+    field double[] actuator_command
+end
+
+struct ActuatorInfo
+    field DeviceInfo device_info
+    field ActuatorTypeCode actuator_type
+    field SIUnit{list} command_units
+    field DataType command_data_type
+    field double[] command_resolution
+    field bool analog_output
+    field ParameterInfo{list} parameter_info
+    field varvalue{string} extended
+end
+
+object Actuator
+    implements Device
+    property DeviceInfo device_info [readonly,nolock]
+    property ActuatorInfo actuator_info [readonly,nolock]
+    property ActuatorMode actuator_mode [nolockread]
+    wire double[] actuator_command [writeonly]
+    wire ActuatorState actuator_state [readonly,nolock]
+    function varvalue getf_param(string param_name)
+    function void setf_param(string param_name, varvalue value)
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.bignum.robdef

 * *Ordering differences only*

```diff
@@ -1,20 +1,20 @@
-service com.robotraconteur.bignum
-
-stdver 0.10
-
-# Signed arbitrary precision number, little endian
-struct BigNum
-    field uint8[] data
-end
-
-# Unsigned arbitrary precision number, little endian
-struct UnsignedBigNum
-    field uint8[] data
-end
-
-# Arbitrary precision floating point number
-struct BigFloat
-    field BigNum num
-    field BigNum den
-    field BigNum radix
-end
+service com.robotraconteur.bignum
+
+stdver 0.10
+
+# Signed arbitrary precision number, little endian
+struct BigNum
+    field uint8[] data
+end
+
+# Unsigned arbitrary precision number, little endian
+struct UnsignedBigNum
+    field uint8[] data
+end
+
+# Arbitrary precision floating point number
+struct BigFloat
+    field BigNum num
+    field BigNum den
+    field BigNum radix
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.color.robdef

 * *Ordering differences only*

```diff
@@ -1,55 +1,55 @@
-service com.robotraconteur.color
-
-stdver 0.10
-
-namedarray ColorRGBA
-    field double r
-    field double g
-    field double b
-    field double a
-end
-
-namedarray ColorRGBAf
-    field single r
-    field single g
-    field single b
-    field single a
-end
-
-namedarray ColorRGBAu
-    field uint8 r
-    field uint8 g
-    field uint8 b
-    field uint8 a
-end
-
-namedarray ColorRGBAh
-    field uint16 r
-    field uint16 g
-    field uint16 b
-    field uint16 a
-end
-
-namedarray ColorRGB
-    field double r
-    field double g
-    field double b
-end
-
-namedarray ColorRGBf
-    field single r
-    field single g
-    field single b
-end
-
-namedarray ColorRGBu
-    field uint8 r
-    field uint8 g
-    field uint8 b
-end
-
-namedarray ColorRGBh
-    field uint16 r
-    field uint16 g
-    field uint16 b
-end
+service com.robotraconteur.color
+
+stdver 0.10
+
+namedarray ColorRGBA
+    field double r
+    field double g
+    field double b
+    field double a
+end
+
+namedarray ColorRGBAf
+    field single r
+    field single g
+    field single b
+    field single a
+end
+
+namedarray ColorRGBAu
+    field uint8 r
+    field uint8 g
+    field uint8 b
+    field uint8 a
+end
+
+namedarray ColorRGBAh
+    field uint16 r
+    field uint16 g
+    field uint16 b
+    field uint16 a
+end
+
+namedarray ColorRGB
+    field double r
+    field double g
+    field double b
+end
+
+namedarray ColorRGBf
+    field single r
+    field single g
+    field single b
+end
+
+namedarray ColorRGBu
+    field uint8 r
+    field uint8 g
+    field uint8 b
+end
+
+namedarray ColorRGBh
+    field uint16 r
+    field uint16 g
+    field uint16 b
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.datatype.robdef

 * *Ordering differences only*

```diff
@@ -1,61 +1,61 @@
-service com.robotraconteur.datatype
-
-stdver 0.10
-
-enum DataTypeCode
-    void_c = 0,
-    double_c,
-    single_c,
-    int8_c,
-    uint8_c,
-    int16_c,
-    uint16_c,
-    int32_c,
-    uint32_c,
-    int64_c,
-    uint64_c,
-    string_c,
-    cdouble_c,
-    csingle_c,
-    bool_c,
-    structure_c = 101,
-    vector_c,
-    dictionary_c,
-    object_c,
-    varvalue_c,
-    varobject_c,
-    list_c = 108,
-    pod_c,
-    pod_array_c,
-    pod_multidimarray_c,
-    enum_c,
-    namedtype_c,
-    namedarray_c,
-    namedarray_array_c,
-    namedarray_multidimarray_c,
-    multidimarray_c
-end
-
-enum ArrayTypeCode
-    none_c = 0,
-    array_c,
-    multidimarray_c
-end
-
-enum ContainerTypeCode
-    none_c = 0,
-    list_c,
-    map_int32_c,
-    map_string_c,
-    generator_c
-end
-
-struct DataType
-    field string name
-    field DataTypeCode type_code
-    field string type_string
-    field ArrayTypeCode array_type_code
-    field bool array_var_len
-    field uint32[] array_len
-    field ContainerTypeCode container_type_code
-end
+service com.robotraconteur.datatype
+
+stdver 0.10
+
+enum DataTypeCode
+    void_c = 0,
+    double_c,
+    single_c,
+    int8_c,
+    uint8_c,
+    int16_c,
+    uint16_c,
+    int32_c,
+    uint32_c,
+    int64_c,
+    uint64_c,
+    string_c,
+    cdouble_c,
+    csingle_c,
+    bool_c,
+    structure_c = 101,
+    vector_c,
+    dictionary_c,
+    object_c,
+    varvalue_c,
+    varobject_c,
+    list_c = 108,
+    pod_c,
+    pod_array_c,
+    pod_multidimarray_c,
+    enum_c,
+    namedtype_c,
+    namedarray_c,
+    namedarray_array_c,
+    namedarray_multidimarray_c,
+    multidimarray_c
+end
+
+enum ArrayTypeCode
+    none_c = 0,
+    array_c,
+    multidimarray_c
+end
+
+enum ContainerTypeCode
+    none_c = 0,
+    list_c,
+    map_int32_c,
+    map_string_c,
+    generator_c
+end
+
+struct DataType
+    field string name
+    field DataTypeCode type_code
+    field string type_string
+    field ArrayTypeCode array_type_code
+    field bool array_var_len
+    field uint32[] array_len
+    field ContainerTypeCode container_type_code
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.datetime.clock.robdef

 * *Ordering differences only*

```diff
@@ -1,34 +1,34 @@
-service com.robotraconteur.datetime.clock
-
-stdver 0.10
-
-import com.robotraconteur.datetime
-import com.robotraconteur.device
-import com.robotraconteur.device.clock
-
-using com.robotraconteur.datetime.DateTimeUTC
-using com.robotraconteur.datetime.DateTimeLocal
-using com.robotraconteur.datetime.ClockTypeCode
-using com.robotraconteur.device.DeviceInfo
-using com.robotraconteur.device.Device
-using com.robotraconteur.device.clock.DeviceClock
-using com.robotraconteur.device.clock.DeviceTime
-
-struct ClockDeviceInfo
-    field DeviceInfo device_info
-    field ClockTypeCode clock_type
-    field int32 timezone_utc_offset_seconds
-    field string timezone_name
-    field varvalue{string} extended
-end
-
-object Clock
-    implements Device
-    implements DeviceClock
-    property DeviceInfo device_info [readonly,nolock]
-    property ClockDeviceInfo clock_info [readonly,nolock]
-    wire DateTimeUTC time_utc [readonly]
-    wire DateTimeLocal time_local [readonly]
-    # Optional device clock
-    wire DeviceTime device_clock_now [readonly,nolock]
-end
+service com.robotraconteur.datetime.clock
+
+stdver 0.10
+
+import com.robotraconteur.datetime
+import com.robotraconteur.device
+import com.robotraconteur.device.clock
+
+using com.robotraconteur.datetime.DateTimeUTC
+using com.robotraconteur.datetime.DateTimeLocal
+using com.robotraconteur.datetime.ClockTypeCode
+using com.robotraconteur.device.DeviceInfo
+using com.robotraconteur.device.Device
+using com.robotraconteur.device.clock.DeviceClock
+using com.robotraconteur.device.clock.DeviceTime
+
+struct ClockDeviceInfo
+    field DeviceInfo device_info
+    field ClockTypeCode clock_type
+    field int32 timezone_utc_offset_seconds
+    field string timezone_name
+    field varvalue{string} extended
+end
+
+object Clock
+    implements Device
+    implements DeviceClock
+    property DeviceInfo device_info [readonly,nolock]
+    property ClockDeviceInfo clock_info [readonly,nolock]
+    wire DateTimeUTC time_utc [readonly]
+    wire DateTimeLocal time_local [readonly]
+    # Optional device clock
+    wire DeviceTime device_clock_now [readonly,nolock]
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.datetime.robdef

 * *Ordering differences only*

```diff
@@ -1,77 +1,77 @@
-service com.robotraconteur.datetime
-
-stdver 0.10
-
-import com.robotraconteur.uuid
-using com.robotraconteur.uuid.UUID
-
-constant string EPOCH_ISO8601 "1970-01-01T00:00:00Z"
-
-enum ClockTypeCode
-    unknown = 0,
-    default,
-    system_rtc_clock,
-    system_ntp_clock,
-    system_ptp_clock,
-    system_arb_clock,
-    system_gps_clock,
-    system_tai_clock,
-    system_other_clock,
-    sim_clock_realtime,
-    sim_clock_scaled,
-    node_default,
-    node_rtc_clock,
-    node_ntp_clock,
-    node_ptp_clock,
-    node_arb_clock,
-    node_gps_clock,
-    node_tai_clock,
-    node_other_clock,
-    aux_0 = 0x1000,
-    aux_1,
-    aux_2,
-    aux_3,
-    aux_4,
-    aux_5,
-    aux_6,
-    aux_7
-end
-
-pod ClockInfo
-    field uint32 clock_type
-    field UUID clock_uuid
-    # Offset from TAI time
-    field int64 offset_microseconds
-end
-
-pod DateTimeUTC
-    field ClockInfo clock_info
-    field int64 seconds
-    field int32 nanoseconds
-end
-
-struct DateTimeLocal
-    field ClockInfo clock_info
-    field int64 seconds
-    field int32 nanoseconds
-    field int32 utc_offset_seconds
-    field string timezone_name
-end
-
-pod Duration
-    field ClockInfo clock_info
-    field int64 seconds
-    field int32 nanoseconds
-end
-
-# TimeSpec2 in Node Clock
-pod TimeSpec2
-    field ClockInfo clock_info
-    field int64 seconds
-    field int32 nanoseconds
-end
-
-# Compact TimeSpec3 in Node Clock
-namedarray TimeSpec3
-    field int64 microseconds
-end
+service com.robotraconteur.datetime
+
+stdver 0.10
+
+import com.robotraconteur.uuid
+using com.robotraconteur.uuid.UUID
+
+constant string EPOCH_ISO8601 "1970-01-01T00:00:00Z"
+
+enum ClockTypeCode
+    unknown = 0,
+    default,
+    system_rtc_clock,
+    system_ntp_clock,
+    system_ptp_clock,
+    system_arb_clock,
+    system_gps_clock,
+    system_tai_clock,
+    system_other_clock,
+    sim_clock_realtime,
+    sim_clock_scaled,
+    node_default,
+    node_rtc_clock,
+    node_ntp_clock,
+    node_ptp_clock,
+    node_arb_clock,
+    node_gps_clock,
+    node_tai_clock,
+    node_other_clock,
+    aux_0 = 0x1000,
+    aux_1,
+    aux_2,
+    aux_3,
+    aux_4,
+    aux_5,
+    aux_6,
+    aux_7
+end
+
+pod ClockInfo
+    field uint32 clock_type
+    field UUID clock_uuid
+    # Offset from TAI time
+    field int64 offset_microseconds
+end
+
+pod DateTimeUTC
+    field ClockInfo clock_info
+    field int64 seconds
+    field int32 nanoseconds
+end
+
+struct DateTimeLocal
+    field ClockInfo clock_info
+    field int64 seconds
+    field int32 nanoseconds
+    field int32 utc_offset_seconds
+    field string timezone_name
+end
+
+pod Duration
+    field ClockInfo clock_info
+    field int64 seconds
+    field int32 nanoseconds
+end
+
+# TimeSpec2 in Node Clock
+pod TimeSpec2
+    field ClockInfo clock_info
+    field int64 seconds
+    field int32 nanoseconds
+end
+
+# Compact TimeSpec3 in Node Clock
+namedarray TimeSpec3
+    field int64 microseconds
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.device.clock.robdef

 * *Ordering differences only*

```diff
@@ -1,18 +1,18 @@
-service com.robotraconteur.device.clock
-
-stdver 0.10
-
-import com.robotraconteur.datetime
-
-using com.robotraconteur.datetime.TimeSpec2
-using com.robotraconteur.datetime.DateTimeUTC
-
-pod DeviceTime
-    field TimeSpec2 device_ts
-    field DateTimeUTC device_utc
-    field uint64 device_seqno
-end
-
-object DeviceClock
-    wire DeviceTime device_clock_now [readonly,nolock]
-end
+service com.robotraconteur.device.clock
+
+stdver 0.10
+
+import com.robotraconteur.datetime
+
+using com.robotraconteur.datetime.TimeSpec2
+using com.robotraconteur.datetime.DateTimeUTC
+
+pod DeviceTime
+    field TimeSpec2 device_ts
+    field DateTimeUTC device_utc
+    field uint64 device_seqno
+end
+
+object DeviceClock
+    wire DeviceTime device_clock_now [readonly,nolock]
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.device.isoch.robdef

 * *Ordering differences only*

```diff
@@ -1,18 +1,18 @@
-service com.robotraconteur.device.isoch
-
-stdver 0.10
-
-import com.robotraconteur.datetime
-
-using com.robotraconteur.datetime.TimeSpec2
-
-struct IsochInfo
-    field double update_rate
-    field TimeSpec2 isoch_epoch
-    field uint32 max_downsample
-end
-
-object IsochDevice
-    property IsochInfo isoch_info [readonly,nolock]
-    property uint32 isoch_downsample [perclient]
-end
+service com.robotraconteur.device.isoch
+
+stdver 0.10
+
+import com.robotraconteur.datetime
+
+using com.robotraconteur.datetime.TimeSpec2
+
+struct IsochInfo
+    field double update_rate
+    field TimeSpec2 isoch_epoch
+    field uint32 max_downsample
+end
+
+object IsochDevice
+    property IsochInfo isoch_info [readonly,nolock]
+    property uint32 isoch_downsample [perclient]
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.device.robdef

 * *Ordering differences only*

```diff
@@ -1,64 +1,64 @@
-service com.robotraconteur.device
-
-stdver 0.10
-
-import com.robotraconteur.identifier
-import com.robotraconteur.resource
-import com.robotraconteur.geometry
-
-using com.robotraconteur.identifier.Identifier
-using com.robotraconteur.resource.ResourceIdentifier
-using com.robotraconteur.geometry.NamedPose
-
-struct DeviceOption
-    field Identifier option_identifier
-    field DeviceSubOption{list} suboptions
-end
-
-struct DeviceSubOption
-    field string suboption_name
-    field double suboption_level
-    field varvalue{string} extended
-end
-
-struct DeviceCapability
-    field Identifier capability_identifier
-    field DeviceSubCapability{list} subcapabilities
-end
-
-struct DeviceSubCapability
-    field string subcapability_name
-    field double subcapability_level
-    field varvalue{string} extended
-end
-
-struct DeviceClass
-    field Identifier class_identifier
-    field string{list} subclasses
-end
-
-struct DeviceInfo
-    field Identifier device
-    field Identifier parent_device
-    field Identifier manufacturer
-    field Identifier model
-    field DeviceOption{list} options
-    field DeviceCapability{list} capabilities
-    field string serial_number
-    field DeviceClass{list} device_classes
-    field string user_description
-    field ResourceIdentifier description_resource
-    field string{list} implemented_types
-    field NamedPose device_origin_pose
-    field Identifier{string} associated_devices
-    field varvalue{string} extended
-end
-
-object Device
-    property DeviceInfo device_info [readonly,nolock]
-end
-
-object BillboardDevice
-    implements Device
-    property DeviceInfo device_info [readonly,nolock]
-end
+service com.robotraconteur.device
+
+stdver 0.10
+
+import com.robotraconteur.identifier
+import com.robotraconteur.resource
+import com.robotraconteur.geometry
+
+using com.robotraconteur.identifier.Identifier
+using com.robotraconteur.resource.ResourceIdentifier
+using com.robotraconteur.geometry.NamedPose
+
+struct DeviceOption
+    field Identifier option_identifier
+    field DeviceSubOption{list} suboptions
+end
+
+struct DeviceSubOption
+    field string suboption_name
+    field double suboption_level
+    field varvalue{string} extended
+end
+
+struct DeviceCapability
+    field Identifier capability_identifier
+    field DeviceSubCapability{list} subcapabilities
+end
+
+struct DeviceSubCapability
+    field string subcapability_name
+    field double subcapability_level
+    field varvalue{string} extended
+end
+
+struct DeviceClass
+    field Identifier class_identifier
+    field string{list} subclasses
+end
+
+struct DeviceInfo
+    field Identifier device
+    field Identifier parent_device
+    field Identifier manufacturer
+    field Identifier model
+    field DeviceOption{list} options
+    field DeviceCapability{list} capabilities
+    field string serial_number
+    field DeviceClass{list} device_classes
+    field string user_description
+    field ResourceIdentifier description_resource
+    field string{list} implemented_types
+    field NamedPose device_origin_pose
+    field Identifier{string} associated_devices
+    field varvalue{string} extended
+end
+
+object Device
+    property DeviceInfo device_info [readonly,nolock]
+end
+
+object BillboardDevice
+    implements Device
+    property DeviceInfo device_info [readonly,nolock]
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.eventlog.robdef

 * *Ordering differences only*

```diff
@@ -1,71 +1,71 @@
-service com.robotraconteur.eventlog
-
-stdver 0.10
-
-import com.robotraconteur.identifier
-import com.robotraconteur.datetime
-import com.robotraconteur.device
-
-using com.robotraconteur.identifier.Identifier
-using com.robotraconteur.datetime.DateTimeUTC
-using com.robotraconteur.device.DeviceInfo
-using com.robotraconteur.device.Device
-
-enum EventLogLevel
-    undefined = 0,
-    trace = 1,
-    debug,
-    info,
-    warning,
-    error,
-    safety_violation_error,
-    fatal_error,
-    emergency_error,
-    catastrophic_error
-end
-
-struct EventLogType
-    field Identifier event_category
-    field string event_type
-end
-
-struct EventLogMessageHeader
-    field EventLogType type
-    field EventLogLevel level
-    field Identifier source_device
-    field string source_component
-    field string source_object
-    field uint64 message_number
-    field DateTimeUTC timestamp
-end
-
-struct EventLogMessage
-    field EventLogMessageHeader header
-    field string title
-    field string message
-    field varvalue{string} extended
-end
-
-struct EventLogInfo
-    field DeviceInfo device_info
-    field Identifier logged_device
-    field uint64 min_message_number
-    field uint64 max_message_number
-    field varvalue{string} extended
-end
-
-object EventLog
-    property EventLogInfo eventlog_info [readonly,nolock]
-    function EventLogMessage{list} getf_eventlog_messages(uint64 start, uint64 count)
-end
-
-object EventLogDevice
-    implements EventLog
-    implements Device
-    property DeviceInfo device_info [readonly,nolock]
-    property EventLogInfo eventlog_info [readonly,nolock]
-    function EventLogMessage{list} getf_eventlog_messages(uint64 start, uint64 count)
-    pipe EventLogMessage eventlog_message_stream [readonly]
-    function void eventlog_clear_messages(uint64 offset, uint64 count)
-    function void eventlog_clear_all_messages()
-end
+service com.robotraconteur.eventlog
+
+stdver 0.10
+
+import com.robotraconteur.identifier
+import com.robotraconteur.datetime
+import com.robotraconteur.device
+
+using com.robotraconteur.identifier.Identifier
+using com.robotraconteur.datetime.DateTimeUTC
+using com.robotraconteur.device.DeviceInfo
+using com.robotraconteur.device.Device
+
+enum EventLogLevel
+    undefined = 0,
+    trace = 1,
+    debug,
+    info,
+    warning,
+    error,
+    safety_violation_error,
+    fatal_error,
+    emergency_error,
+    catastrophic_error
+end
+
+struct EventLogType
+    field Identifier event_category
+    field string event_type
+end
+
+struct EventLogMessageHeader
+    field EventLogType type
+    field EventLogLevel level
+    field Identifier source_device
+    field string source_component
+    field string source_object
+    field uint64 message_number
+    field DateTimeUTC timestamp
+end
+
+struct EventLogMessage
+    field EventLogMessageHeader header
+    field string title
+    field string message
+    field varvalue{string} extended
+end
+
+struct EventLogInfo
+    field DeviceInfo device_info
+    field Identifier logged_device
+    field uint64 min_message_number
+    field uint64 max_message_number
+    field varvalue{string} extended
+end
+
+object EventLog
+    property EventLogInfo eventlog_info [readonly,nolock]
+    function EventLogMessage{list} getf_eventlog_messages(uint64 start, uint64 count)
+end
+
+object EventLogDevice
+    implements EventLog
+    implements Device
+    property DeviceInfo device_info [readonly,nolock]
+    property EventLogInfo eventlog_info [readonly,nolock]
+    function EventLogMessage{list} getf_eventlog_messages(uint64 start, uint64 count)
+    pipe EventLogMessage eventlog_message_stream [readonly]
+    function void eventlog_clear_messages(uint64 offset, uint64 count)
+    function void eventlog_clear_all_messages()
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.fiducial.robdef

 * *Ordering differences only*

```diff
@@ -1,95 +1,95 @@
-service com.robotraconteur.fiducial
-
-stdver 0.10
-
-import com.robotraconteur.identifier
-import com.robotraconteur.geometry
-import com.robotraconteur.color
-import com.robotraconteur.image
-import com.robotraconteur.device
-import com.robotraconteur.param
-import com.robotraconteur.sensordata
-import com.robotraconteur.device.isoch
-import com.robotraconteur.device.clock
-
-using com.robotraconteur.identifier.Identifier
-using com.robotraconteur.geometry.NamedPose
-using com.robotraconteur.geometry.NamedPoseWithCovariance
-using com.robotraconteur.geometry.Point2D
-using com.robotraconteur.geometry.Size2D
-using com.robotraconteur.geometry.BoundingBox
-using com.robotraconteur.geometry.Vector3
-using com.robotraconteur.color.ColorRGBA
-using com.robotraconteur.image.CompressedImage
-using com.robotraconteur.device.Device
-using com.robotraconteur.device.DeviceInfo
-using com.robotraconteur.param.ParameterInfo
-using com.robotraconteur.sensordata.SensorDataHeader
-using com.robotraconteur.device.isoch.IsochDevice
-using com.robotraconteur.device.isoch.IsochInfo
-using com.robotraconteur.device.clock.DeviceClock
-using com.robotraconteur.device.clock.DeviceTime
-
-struct Fiducial
-    field Identifier fiducial_marker_class
-    field string fiducial_marker
-    field NamedPose fiducial_pose
-    field double fiducial_scale
-    field ColorRGBA foreground_color
-    field ColorRGBA background_color
-end
-
-struct FiducialInfo
-    field Identifier fiducial_marker_class
-    field string fiducial_marker
-    field string fiducial_marker_range
-    field Size2D default_size
-    field ColorRGBA default_foreground_color
-    field ColorRGBA default_background_color
-    field CompressedImage marker_template
-    field Point2D marker_template_centroid
-    field varvalue{string} extended
-end
-
-struct RecognizedFiducial
-    field Identifier fiducial_marker_class
-    field string fiducial_marker
-    field NamedPoseWithCovariance pose
-    field double confidence
-    field varvalue{string} extended
-end
-
-struct RecognizedFiducials
-    field RecognizedFiducial{list} recognized_fiducials
-    field varvalue source_data
-    field varvalue{string} extended
-end
-
-struct FiducialSensorInfo
-    field DeviceInfo device_info
-    field BoundingBox range
-    field Vector3 resolution
-    field ParameterInfo{list} param_info
-    field FiducialInfo{list} fiducial_info
-    field varvalue{string} extended
-end
-
-struct FiducialSensorData
-    field SensorDataHeader sensor_data
-    field RecognizedFiducials fiducials
-end
-
-object FiducialSensor
-    implements Device
-    implements DeviceClock
-    implements IsochDevice
-    property DeviceInfo device_info [readonly,nolock]
-    property FiducialSensorInfo fiducial_sensor_info [readonly,nolock]
-    function RecognizedFiducials capture_fiducials()
-    pipe FiducialSensorData fiducials_sensor_data [readonly]
-    function varvalue getf_param(string param_name)
-    function void setf_param(string param_name, varvalue value)
-    property IsochInfo isoch_info [readonly,nolock]
-    property uint32 isoch_downsample [perclient]
-    wire DeviceTime device_clock_now [readonly,nolock]
-end
+service com.robotraconteur.fiducial
+
+stdver 0.10
+
+import com.robotraconteur.identifier
+import com.robotraconteur.geometry
+import com.robotraconteur.color
+import com.robotraconteur.image
+import com.robotraconteur.device
+import com.robotraconteur.param
+import com.robotraconteur.sensordata
+import com.robotraconteur.device.isoch
+import com.robotraconteur.device.clock
+
+using com.robotraconteur.identifier.Identifier
+using com.robotraconteur.geometry.NamedPose
+using com.robotraconteur.geometry.NamedPoseWithCovariance
+using com.robotraconteur.geometry.Point2D
+using com.robotraconteur.geometry.Size2D
+using com.robotraconteur.geometry.BoundingBox
+using com.robotraconteur.geometry.Vector3
+using com.robotraconteur.color.ColorRGBA
+using com.robotraconteur.image.CompressedImage
+using com.robotraconteur.device.Device
+using com.robotraconteur.device.DeviceInfo
+using com.robotraconteur.param.ParameterInfo
+using com.robotraconteur.sensordata.SensorDataHeader
+using com.robotraconteur.device.isoch.IsochDevice
+using com.robotraconteur.device.isoch.IsochInfo
+using com.robotraconteur.device.clock.DeviceClock
+using com.robotraconteur.device.clock.DeviceTime
+
+struct Fiducial
+    field Identifier fiducial_marker_class
+    field string fiducial_marker
+    field NamedPose fiducial_pose
+    field double fiducial_scale
+    field ColorRGBA foreground_color
+    field ColorRGBA background_color
+end
+
+struct FiducialInfo
+    field Identifier fiducial_marker_class
+    field string fiducial_marker
+    field string fiducial_marker_range
+    field Size2D default_size
+    field ColorRGBA default_foreground_color
+    field ColorRGBA default_background_color
+    field CompressedImage marker_template
+    field Point2D marker_template_centroid
+    field varvalue{string} extended
+end
+
+struct RecognizedFiducial
+    field Identifier fiducial_marker_class
+    field string fiducial_marker
+    field NamedPoseWithCovariance pose
+    field double confidence
+    field varvalue{string} extended
+end
+
+struct RecognizedFiducials
+    field RecognizedFiducial{list} recognized_fiducials
+    field varvalue source_data
+    field varvalue{string} extended
+end
+
+struct FiducialSensorInfo
+    field DeviceInfo device_info
+    field BoundingBox range
+    field Vector3 resolution
+    field ParameterInfo{list} param_info
+    field FiducialInfo{list} fiducial_info
+    field varvalue{string} extended
+end
+
+struct FiducialSensorData
+    field SensorDataHeader sensor_data
+    field RecognizedFiducials fiducials
+end
+
+object FiducialSensor
+    implements Device
+    implements DeviceClock
+    implements IsochDevice
+    property DeviceInfo device_info [readonly,nolock]
+    property FiducialSensorInfo fiducial_sensor_info [readonly,nolock]
+    function RecognizedFiducials capture_fiducials()
+    pipe FiducialSensorData fiducials_sensor_data [readonly]
+    function varvalue getf_param(string param_name)
+    function void setf_param(string param_name, varvalue value)
+    property IsochInfo isoch_info [readonly,nolock]
+    property uint32 isoch_downsample [perclient]
+    wire DeviceTime device_clock_now [readonly,nolock]
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.geometry.robdef

 * *Ordering differences only*

```diff
@@ -1,173 +1,173 @@
-service com.robotraconteur.geometry
-
-stdver 0.10
-
-import com.robotraconteur.identifier
-
-using com.robotraconteur.identifier.Identifier
-
-namedarray Vector2
-    field double x
-    field double y
-end
-
-namedarray Vector3
-    field double x
-    field double y
-    field double z
-end
-
-namedarray Vector6
-    field double alpha
-    field double beta
-    field double gamma
-    field double x
-    field double y
-    field double z
-end
-
-namedarray Point2D
-    field double x
-    field double y
-end
-
-namedarray Point
-    field double x
-    field double y
-    field double z
-end
-
-namedarray Size2D
-    field double width
-    field double height
-end
-
-namedarray Size
-    field double width
-    field double height
-    field double depth
-end
-
-namedarray Rect
-   field Point2D origin
-   field Size2D size
-end
-
-namedarray Box
-   field Point origin
-   field Size size
-end
-
-namedarray Quaternion
-    field double w
-    field double x
-    field double y
-    field double z
-end
-
-namedarray Plane
-    field Vector3 normal
-    field double a
-end
-
-namedarray Transform
-    field Quaternion rotation
-    field Vector3 translation
-end
-
-struct NamedTransform
-    field Identifier parent_frame
-    field Identifier child_frame
-    field Transform transform
-end
-
-namedarray Pose
-    field Quaternion orientation
-    field Point position
-end
-
-struct NamedPose
-    field Identifier parent_frame
-    field Identifier frame
-    field Pose pose
-end
-
-struct PoseWithCovariance
-    field Pose pose
-    field double[6,6] covariance
-end
-
-struct NamedPoseWithCovariance
-    field NamedPose pose
-    field double[6,6] covariance
-end
-
-namedarray Pose2D
-    field double orientation
-    field Point2D position
-end
-
-struct NamedPose2D
-    field Identifier parent_frame
-    field Identifier frame
-    field Pose2D pose
-end
-
-namedarray SpatialVelocity
-    field Vector3 angular
-    field Vector3 linear
-end
-
-struct NamedSpatialVelocity
-    field Identifier parent_frame
-    field Identifier frame
-    field SpatialVelocity velocity
-end
-
-namedarray SpatialAcceleration
-    field Vector3 angular
-    field Vector3 linear
-end
-
-struct NamedSpatialAcceleration
-    field Identifier parent_frame
-    field Identifier frame
-    field SpatialAcceleration acceleration
-end
-
-namedarray Wrench
-    field Vector3 torque
-    field Vector3 force
-end
-
-struct NamedWrench
-    field Identifier parent_frame
-    field Identifier frame
-    field Wrench wrench
-end
-
-namedarray SpatialInertia
-    field double m
-    field Vector3 com
-    field double ixx
-    field double ixy
-    field double ixz
-    field double iyy
-    field double iyz
-    field double izz
-end
-
-struct NamedSpatialInertia
-    field Identifier frame
-    field SpatialInertia inertia
-end
-
-struct BoundingBox2D
-    field NamedPose2D center
-    field Size2D size
-end
-
-struct BoundingBox
-    field NamedPose center
-    field Size size
-end
+service com.robotraconteur.geometry
+
+stdver 0.10
+
+import com.robotraconteur.identifier
+
+using com.robotraconteur.identifier.Identifier
+
+namedarray Vector2
+    field double x
+    field double y
+end
+
+namedarray Vector3
+    field double x
+    field double y
+    field double z
+end
+
+namedarray Vector6
+    field double alpha
+    field double beta
+    field double gamma
+    field double x
+    field double y
+    field double z
+end
+
+namedarray Point2D
+    field double x
+    field double y
+end
+
+namedarray Point
+    field double x
+    field double y
+    field double z
+end
+
+namedarray Size2D
+    field double width
+    field double height
+end
+
+namedarray Size
+    field double width
+    field double height
+    field double depth
+end
+
+namedarray Rect
+   field Point2D origin
+   field Size2D size
+end
+
+namedarray Box
+   field Point origin
+   field Size size
+end
+
+namedarray Quaternion
+    field double w
+    field double x
+    field double y
+    field double z
+end
+
+namedarray Plane
+    field Vector3 normal
+    field double a
+end
+
+namedarray Transform
+    field Quaternion rotation
+    field Vector3 translation
+end
+
+struct NamedTransform
+    field Identifier parent_frame
+    field Identifier child_frame
+    field Transform transform
+end
+
+namedarray Pose
+    field Quaternion orientation
+    field Point position
+end
+
+struct NamedPose
+    field Identifier parent_frame
+    field Identifier frame
+    field Pose pose
+end
+
+struct PoseWithCovariance
+    field Pose pose
+    field double[6,6] covariance
+end
+
+struct NamedPoseWithCovariance
+    field NamedPose pose
+    field double[6,6] covariance
+end
+
+namedarray Pose2D
+    field double orientation
+    field Point2D position
+end
+
+struct NamedPose2D
+    field Identifier parent_frame
+    field Identifier frame
+    field Pose2D pose
+end
+
+namedarray SpatialVelocity
+    field Vector3 angular
+    field Vector3 linear
+end
+
+struct NamedSpatialVelocity
+    field Identifier parent_frame
+    field Identifier frame
+    field SpatialVelocity velocity
+end
+
+namedarray SpatialAcceleration
+    field Vector3 angular
+    field Vector3 linear
+end
+
+struct NamedSpatialAcceleration
+    field Identifier parent_frame
+    field Identifier frame
+    field SpatialAcceleration acceleration
+end
+
+namedarray Wrench
+    field Vector3 torque
+    field Vector3 force
+end
+
+struct NamedWrench
+    field Identifier parent_frame
+    field Identifier frame
+    field Wrench wrench
+end
+
+namedarray SpatialInertia
+    field double m
+    field Vector3 com
+    field double ixx
+    field double ixy
+    field double ixz
+    field double iyy
+    field double iyz
+    field double izz
+end
+
+struct NamedSpatialInertia
+    field Identifier frame
+    field SpatialInertia inertia
+end
+
+struct BoundingBox2D
+    field NamedPose2D center
+    field Size2D size
+end
+
+struct BoundingBox
+    field NamedPose center
+    field Size size
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.geometry.shapes.robdef

 * *Ordering differences only*

```diff
@@ -1,99 +1,99 @@
-service com.robotraconteur.geometry.shapes
-
-stdver 0.10
-
-import com.robotraconteur.geometry
-import com.robotraconteur.identifier
-import com.robotraconteur.color
-import com.robotraconteur.resource
-import com.robotraconteur.image
-import com.robotraconteur.fiducial
-
-using com.robotraconteur.geometry.Point
-using com.robotraconteur.geometry.Pose
-using com.robotraconteur.geometry.Vector2
-using com.robotraconteur.geometry.Vector3
-using com.robotraconteur.geometry.NamedPose
-using com.robotraconteur.geometry.SpatialInertia
-using com.robotraconteur.identifier.Identifier
-using com.robotraconteur.color.ColorRGB
-using com.robotraconteur.color.ColorRGBA
-using com.robotraconteur.resource.ResourceIdentifier
-using com.robotraconteur.image.CompressedImage
-using com.robotraconteur.fiducial.Fiducial
-
-enum MeshType
-    mesh = 0,
-    convex_mesh,
-    sdf_mesh
-end
-
-struct Box
-    field double x
-    field double y
-    field double z
-end
-
-struct Sphere
-    field double radius
-end
-
-struct Cylinder
-    field double height
-    field double radius
-end
-
-struct Cone
-    field double height
-    field double radius
-end
-
-struct Capsule
-    field double height
-    field double radius
-end
-
-struct Plane
-    field double a
-    field double b
-    field double c
-    field double d
-end
-
-namedarray MeshTriangle
-    field uint32 v1
-    field uint32 v2
-    field uint32 v3
-end
-
-struct MeshTexture
-    field CompressedImage image
-    field Vector2[] uvs
-end
-
-struct Mesh
-    field MeshTriangle[] triangles
-    field Point[] vertices
-    field Vector3[] normals
-    field ColorRGB[] colors
-    field MeshTexture{list} textures
-    field MeshType mesh_type
-end
-
-struct Material
-    field ColorRGBA base_color_factor
-    field double metallic_factor
-    field double roughness_factor
-    field ColorRGBA emissive_factor
-    field varvalue{string} extended
-end
-
-struct ShapeObject
-    field Identifier name
-    field varvalue{list} shapes
-    field Pose{list} shape_poses
-    field Material{list} shape_materials
-    field SpatialInertia inertia
-    field Fiducial{list} fiducials
-    field varvalue{string} extended
-end
+service com.robotraconteur.geometry.shapes
+
+stdver 0.10
+
+import com.robotraconteur.geometry
+import com.robotraconteur.identifier
+import com.robotraconteur.color
+import com.robotraconteur.resource
+import com.robotraconteur.image
+import com.robotraconteur.fiducial
+
+using com.robotraconteur.geometry.Point
+using com.robotraconteur.geometry.Pose
+using com.robotraconteur.geometry.Vector2
+using com.robotraconteur.geometry.Vector3
+using com.robotraconteur.geometry.NamedPose
+using com.robotraconteur.geometry.SpatialInertia
+using com.robotraconteur.identifier.Identifier
+using com.robotraconteur.color.ColorRGB
+using com.robotraconteur.color.ColorRGBA
+using com.robotraconteur.resource.ResourceIdentifier
+using com.robotraconteur.image.CompressedImage
+using com.robotraconteur.fiducial.Fiducial
+
+enum MeshType
+    mesh = 0,
+    convex_mesh,
+    sdf_mesh
+end
+
+struct Box
+    field double x
+    field double y
+    field double z
+end
+
+struct Sphere
+    field double radius
+end
+
+struct Cylinder
+    field double height
+    field double radius
+end
+
+struct Cone
+    field double height
+    field double radius
+end
+
+struct Capsule
+    field double height
+    field double radius
+end
+
+struct Plane
+    field double a
+    field double b
+    field double c
+    field double d
+end
+
+namedarray MeshTriangle
+    field uint32 v1
+    field uint32 v2
+    field uint32 v3
+end
+
+struct MeshTexture
+    field CompressedImage image
+    field Vector2[] uvs
+end
+
+struct Mesh
+    field MeshTriangle[] triangles
+    field Point[] vertices
+    field Vector3[] normals
+    field ColorRGB[] colors
+    field MeshTexture{list} textures
+    field MeshType mesh_type
+end
+
+struct Material
+    field ColorRGBA base_color_factor
+    field double metallic_factor
+    field double roughness_factor
+    field ColorRGBA emissive_factor
+    field varvalue{string} extended
+end
+
+struct ShapeObject
+    field Identifier name
+    field varvalue{list} shapes
+    field Pose{list} shape_poses
+    field Material{list} shape_materials
+    field SpatialInertia inertia
+    field Fiducial{list} fiducials
+    field varvalue{string} extended
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.geometryf.robdef

 * *Ordering differences only*

```diff
@@ -1,173 +1,173 @@
-service com.robotraconteur.geometryf
-
-stdver 0.10
-
-import com.robotraconteur.identifier
-
-using com.robotraconteur.identifier.Identifier
-
-namedarray Vector2
-    field single x
-    field single y
-end
-
-namedarray Vector3
-    field single x
-    field single y
-    field single z
-end
-
-namedarray Vector6
-    field single alpha
-    field single beta
-    field single gamma
-    field single x
-    field single y
-    field single z
-end
-
-namedarray Point2D
-    field single x
-    field single y
-end
-
-namedarray Point
-    field single x
-    field single y
-    field single z
-end
-
-namedarray Size2D
-    field single width
-    field single height
-end
-
-namedarray Size
-    field single width
-    field single height
-    field single depth
-end
-
-namedarray Rect
-   field Point2D origin
-   field Size2D size
-end
-
-namedarray Box
-   field Point origin
-   field Size size
-end
-
-namedarray Quaternion
-    field single w
-    field single x
-    field single y
-    field single z
-end
-
-namedarray Plane
-    field Vector3 normal
-    field single a
-end
-
-namedarray Transform
-    field Quaternion rotation
-    field Vector3 translation
-end
-
-struct NamedTransform
-    field Identifier parent_frame
-    field Identifier child_frame
-    field Transform transform
-end
-
-namedarray Pose
-    field Quaternion orientation
-    field Point position
-end
-
-struct NamedPose
-    field Identifier parent_frame
-    field Identifier frame
-    field Pose pose
-end
-
-struct PoseWithCovariance
-    field Pose pose
-    field single[6,6] covariance
-end
-
-struct NamedPoseWithCovariance
-    field NamedPose pose
-    field single[6,6] covariance
-end
-
-namedarray Pose2D
-    field single orientation
-    field Point2D position
-end
-
-struct NamedPose2D
-    field Identifier parent_frame
-    field Identifier frame
-    field Pose2D pose
-end
-
-namedarray SpatialVelocity
-    field Vector3 angular
-    field Vector3 linear
-end
-
-struct NamedSpatialVelocity
-    field Identifier parent_frame
-    field Identifier frame
-    field SpatialVelocity velocity
-end
-
-namedarray SpatialAcceleration
-    field Vector3 angular
-    field Vector3 linear
-end
-
-struct NamedSpatialAcceleration
-    field Identifier parent_frame
-    field Identifier frame
-    field SpatialAcceleration acceleration
-end
-
-namedarray Wrench
-    field Vector3 torque
-    field Vector3 force
-end
-
-struct NamedWrench
-    field Identifier parent_frame
-    field Identifier frame
-    field Wrench wrench
-end
-
-namedarray SpatialInertia
-    field single m
-    field Vector3 com
-    field single ixx
-    field single ixy
-    field single ixz
-    field single iyy
-    field single iyz
-    field single izz
-end
-
-struct NamedSpatialInertia
-    field Identifier frame
-    field SpatialInertia inertia
-end
-
-struct BoundingBox2D
-    field NamedPose2D center
-    field Size2D size
-end
-
-struct BoundingBox
-    field NamedPose center
-    field Size size
-end
+service com.robotraconteur.geometryf
+
+stdver 0.10
+
+import com.robotraconteur.identifier
+
+using com.robotraconteur.identifier.Identifier
+
+namedarray Vector2
+    field single x
+    field single y
+end
+
+namedarray Vector3
+    field single x
+    field single y
+    field single z
+end
+
+namedarray Vector6
+    field single alpha
+    field single beta
+    field single gamma
+    field single x
+    field single y
+    field single z
+end
+
+namedarray Point2D
+    field single x
+    field single y
+end
+
+namedarray Point
+    field single x
+    field single y
+    field single z
+end
+
+namedarray Size2D
+    field single width
+    field single height
+end
+
+namedarray Size
+    field single width
+    field single height
+    field single depth
+end
+
+namedarray Rect
+   field Point2D origin
+   field Size2D size
+end
+
+namedarray Box
+   field Point origin
+   field Size size
+end
+
+namedarray Quaternion
+    field single w
+    field single x
+    field single y
+    field single z
+end
+
+namedarray Plane
+    field Vector3 normal
+    field single a
+end
+
+namedarray Transform
+    field Quaternion rotation
+    field Vector3 translation
+end
+
+struct NamedTransform
+    field Identifier parent_frame
+    field Identifier child_frame
+    field Transform transform
+end
+
+namedarray Pose
+    field Quaternion orientation
+    field Point position
+end
+
+struct NamedPose
+    field Identifier parent_frame
+    field Identifier frame
+    field Pose pose
+end
+
+struct PoseWithCovariance
+    field Pose pose
+    field single[6,6] covariance
+end
+
+struct NamedPoseWithCovariance
+    field NamedPose pose
+    field single[6,6] covariance
+end
+
+namedarray Pose2D
+    field single orientation
+    field Point2D position
+end
+
+struct NamedPose2D
+    field Identifier parent_frame
+    field Identifier frame
+    field Pose2D pose
+end
+
+namedarray SpatialVelocity
+    field Vector3 angular
+    field Vector3 linear
+end
+
+struct NamedSpatialVelocity
+    field Identifier parent_frame
+    field Identifier frame
+    field SpatialVelocity velocity
+end
+
+namedarray SpatialAcceleration
+    field Vector3 angular
+    field Vector3 linear
+end
+
+struct NamedSpatialAcceleration
+    field Identifier parent_frame
+    field Identifier frame
+    field SpatialAcceleration acceleration
+end
+
+namedarray Wrench
+    field Vector3 torque
+    field Vector3 force
+end
+
+struct NamedWrench
+    field Identifier parent_frame
+    field Identifier frame
+    field Wrench wrench
+end
+
+namedarray SpatialInertia
+    field single m
+    field Vector3 com
+    field single ixx
+    field single ixy
+    field single ixz
+    field single iyy
+    field single iyz
+    field single izz
+end
+
+struct NamedSpatialInertia
+    field Identifier frame
+    field SpatialInertia inertia
+end
+
+struct BoundingBox2D
+    field NamedPose2D center
+    field Size2D size
+end
+
+struct BoundingBox
+    field NamedPose center
+    field Size size
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.geometryi.robdef

 * *Ordering differences only*

```diff
@@ -1,173 +1,173 @@
-service com.robotraconteur.geometryi
-
-stdver 0.10
-
-import com.robotraconteur.identifier
-
-using com.robotraconteur.identifier.Identifier
-
-namedarray Vector2
-    field int32 x
-    field int32 y
-end
-
-namedarray Vector3
-    field int32 x
-    field int32 y
-    field int32 z
-end
-
-namedarray Vector6
-    field int32 alpha
-    field int32 beta
-    field int32 gamma
-    field int32 x
-    field int32 y
-    field int32 z
-end
-
-namedarray Point2D
-    field int32 x
-    field int32 y
-end
-
-namedarray Point
-    field int32 x
-    field int32 y
-    field int32 z
-end
-
-namedarray Size2D
-    field int32 width
-    field int32 height
-end
-
-namedarray Size
-    field int32 width
-    field int32 height
-    field int32 depth
-end
-
-namedarray Rect
-   field Point2D origin
-   field Size2D size
-end
-
-namedarray Box
-   field Point origin
-   field Size size
-end
-
-namedarray Quaternion
-    field int32 w
-    field int32 x
-    field int32 y
-    field int32 z
-end
-
-namedarray Plane
-    field Vector3 normal
-    field int32 a
-end
-
-namedarray Transform
-    field Quaternion rotation
-    field Vector3 translation
-end
-
-struct NamedTransform
-    field Identifier parent_frame
-    field Identifier child_frame
-    field Transform transform
-end
-
-namedarray Pose
-    field Quaternion orientation
-    field Point position
-end
-
-struct NamedPose
-    field Identifier parent_frame
-    field Identifier frame
-    field Pose pose
-end
-
-struct PoseWithCovariance
-    field Pose pose
-    field int32[6,6] covariance
-end
-
-struct NamedPoseWithCovariance
-    field NamedPose pose
-    field int32[6,6] covariance
-end
-
-namedarray Pose2D
-    field int32 orientation
-    field Point2D position
-end
-
-struct NamedPose2D
-    field Identifier parent_frame
-    field Identifier frame
-    field Pose2D pose
-end
-
-namedarray SpatialVelocity
-    field Vector3 angular
-    field Vector3 linear
-end
-
-struct NamedSpatialVelocity
-    field Identifier parent_frame
-    field Identifier frame
-    field SpatialVelocity velocity
-end
-
-namedarray SpatialAcceleration
-    field Vector3 angular
-    field Vector3 linear
-end
-
-struct NamedSpatialAcceleration
-    field Identifier parent_frame
-    field Identifier frame
-    field SpatialAcceleration acceleration
-end
-
-namedarray Wrench
-    field Vector3 torque
-    field Vector3 force
-end
-
-struct NamedWrench
-    field Identifier parent_frame
-    field Identifier frame
-    field Wrench wrench
-end
-
-namedarray SpatialInertia
-    field int32 m
-    field Vector3 com
-    field int32 ixx
-    field int32 ixy
-    field int32 ixz
-    field int32 iyy
-    field int32 iyz
-    field int32 izz
-end
-
-struct NamedSpatialInertia
-    field Identifier frame
-    field SpatialInertia inertia
-end
-
-struct BoundingBox2D
-    field NamedPose2D center
-    field Size2D size
-end
-
-struct BoundingBox
-    field NamedPose center
-    field Size size
-end
+service com.robotraconteur.geometryi
+
+stdver 0.10
+
+import com.robotraconteur.identifier
+
+using com.robotraconteur.identifier.Identifier
+
+namedarray Vector2
+    field int32 x
+    field int32 y
+end
+
+namedarray Vector3
+    field int32 x
+    field int32 y
+    field int32 z
+end
+
+namedarray Vector6
+    field int32 alpha
+    field int32 beta
+    field int32 gamma
+    field int32 x
+    field int32 y
+    field int32 z
+end
+
+namedarray Point2D
+    field int32 x
+    field int32 y
+end
+
+namedarray Point
+    field int32 x
+    field int32 y
+    field int32 z
+end
+
+namedarray Size2D
+    field int32 width
+    field int32 height
+end
+
+namedarray Size
+    field int32 width
+    field int32 height
+    field int32 depth
+end
+
+namedarray Rect
+   field Point2D origin
+   field Size2D size
+end
+
+namedarray Box
+   field Point origin
+   field Size size
+end
+
+namedarray Quaternion
+    field int32 w
+    field int32 x
+    field int32 y
+    field int32 z
+end
+
+namedarray Plane
+    field Vector3 normal
+    field int32 a
+end
+
+namedarray Transform
+    field Quaternion rotation
+    field Vector3 translation
+end
+
+struct NamedTransform
+    field Identifier parent_frame
+    field Identifier child_frame
+    field Transform transform
+end
+
+namedarray Pose
+    field Quaternion orientation
+    field Point position
+end
+
+struct NamedPose
+    field Identifier parent_frame
+    field Identifier frame
+    field Pose pose
+end
+
+struct PoseWithCovariance
+    field Pose pose
+    field int32[6,6] covariance
+end
+
+struct NamedPoseWithCovariance
+    field NamedPose pose
+    field int32[6,6] covariance
+end
+
+namedarray Pose2D
+    field int32 orientation
+    field Point2D position
+end
+
+struct NamedPose2D
+    field Identifier parent_frame
+    field Identifier frame
+    field Pose2D pose
+end
+
+namedarray SpatialVelocity
+    field Vector3 angular
+    field Vector3 linear
+end
+
+struct NamedSpatialVelocity
+    field Identifier parent_frame
+    field Identifier frame
+    field SpatialVelocity velocity
+end
+
+namedarray SpatialAcceleration
+    field Vector3 angular
+    field Vector3 linear
+end
+
+struct NamedSpatialAcceleration
+    field Identifier parent_frame
+    field Identifier frame
+    field SpatialAcceleration acceleration
+end
+
+namedarray Wrench
+    field Vector3 torque
+    field Vector3 force
+end
+
+struct NamedWrench
+    field Identifier parent_frame
+    field Identifier frame
+    field Wrench wrench
+end
+
+namedarray SpatialInertia
+    field int32 m
+    field Vector3 com
+    field int32 ixx
+    field int32 ixy
+    field int32 ixz
+    field int32 iyy
+    field int32 iyz
+    field int32 izz
+end
+
+struct NamedSpatialInertia
+    field Identifier frame
+    field SpatialInertia inertia
+end
+
+struct BoundingBox2D
+    field NamedPose2D center
+    field Size2D size
+end
+
+struct BoundingBox
+    field NamedPose center
+    field Size size
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.gps.robdef

 * *Ordering differences only*

```diff
@@ -1,98 +1,98 @@
-service com.robotraconteur.gps
-
-stdver 0.10
-
-import com.robotraconteur.sensor
-import com.robotraconteur.device
-import com.robotraconteur.datetime
-
-using com.robotraconteur.sensor.Sensor
-using com.robotraconteur.sensor.SensorInfo
-using com.robotraconteur.sensor.SensorData
-using com.robotraconteur.device.Device
-using com.robotraconteur.device.DeviceInfo
-using com.robotraconteur.datetime.DateTimeUTC
-
-enum GpsMeasurementStatusCode
-    no_fix = -1,
-    fix = 0,
-    sbas_fix = 1,
-    gbas_fix = 2,
-    dgps_fix = 18,
-    waas_fix = 33
-end
-
-enum GpsMeasureSourceFlags
-    none = 0,
-    gps = 0x1,
-    points = 0x2,
-    doppler = 0x4,
-    altimeter = 0x8,
-    magnetic = 0x10,
-    gyro = 0x20,
-    accel = 0x40
-end
-
-enum GpsCovarianceTypeCode
-    unknown = 0,
-    approximated = 1,
-    diagonal_known = 2,
-    known = 3
-end
-
-struct GpsStatus
-    field uint16 satellites_used
-    field int32[] satellite_used_prn
-    field uint16 satellites_visible
-    field int32[] satellite_visible_prn
-    field int32[] satellite_visible_z
-    field int32[] satellite_visible_azimuth
-    field int32[] satellite_visible_snr
-    field GpsMeasurementStatusCode status_code
-    field uint16 motion_source_flags
-    field uint16 orientation_source_flags
-    field uint16 position_source_flags
-end
-
-
-struct GpsState
-    field GpsStatus status
-    field DateTimeUTC time
-    field double latitude_deg
-    field double longitude_deg
-    field double altitude
-    field double track_deg
-    field double speed
-    field double climb
-    field double pitch
-    field double roll
-    field double dip
-    field double gdop
-    field double pdop
-    field double hdop
-    field double vdop
-    field double tdop
-    field double err
-    field double err_horz
-    field double err_track
-    field double err_speed
-    field double err_climb
-    field double err_time
-    field double err_pitch
-    field double err_roll
-    field double err_dip
-    field double[3,3] position_covariance
-    field GpsCovarianceTypeCode position_covariance_type
-end
-
-object GpsSensor
-    implements Sensor
-    implements Device
-    property DeviceInfo device_info [readonly,nolock]
-    property SensorInfo sensor_info [readonly,nolock]
-    wire double[] sensor_value [readonly,nolock]
-    pipe SensorData sensor_data [readonly,nolock]
-    function varvalue getf_param(string param_name)
-    function void setf_param(string param_name, varvalue value)
-    wire GpsState gps_state [readonly,nolock]
-end
+service com.robotraconteur.gps
+
+stdver 0.10
+
+import com.robotraconteur.sensor
+import com.robotraconteur.device
+import com.robotraconteur.datetime
+
+using com.robotraconteur.sensor.Sensor
+using com.robotraconteur.sensor.SensorInfo
+using com.robotraconteur.sensor.SensorData
+using com.robotraconteur.device.Device
+using com.robotraconteur.device.DeviceInfo
+using com.robotraconteur.datetime.DateTimeUTC
+
+enum GpsMeasurementStatusCode
+    no_fix = -1,
+    fix = 0,
+    sbas_fix = 1,
+    gbas_fix = 2,
+    dgps_fix = 18,
+    waas_fix = 33
+end
+
+enum GpsMeasureSourceFlags
+    none = 0,
+    gps = 0x1,
+    points = 0x2,
+    doppler = 0x4,
+    altimeter = 0x8,
+    magnetic = 0x10,
+    gyro = 0x20,
+    accel = 0x40
+end
+
+enum GpsCovarianceTypeCode
+    unknown = 0,
+    approximated = 1,
+    diagonal_known = 2,
+    known = 3
+end
+
+struct GpsStatus
+    field uint16 satellites_used
+    field int32[] satellite_used_prn
+    field uint16 satellites_visible
+    field int32[] satellite_visible_prn
+    field int32[] satellite_visible_z
+    field int32[] satellite_visible_azimuth
+    field int32[] satellite_visible_snr
+    field GpsMeasurementStatusCode status_code
+    field uint16 motion_source_flags
+    field uint16 orientation_source_flags
+    field uint16 position_source_flags
+end
+
+
+struct GpsState
+    field GpsStatus status
+    field DateTimeUTC time
+    field double latitude_deg
+    field double longitude_deg
+    field double altitude
+    field double track_deg
+    field double speed
+    field double climb
+    field double pitch
+    field double roll
+    field double dip
+    field double gdop
+    field double pdop
+    field double hdop
+    field double vdop
+    field double tdop
+    field double err
+    field double err_horz
+    field double err_track
+    field double err_speed
+    field double err_climb
+    field double err_time
+    field double err_pitch
+    field double err_roll
+    field double err_dip
+    field double[3,3] position_covariance
+    field GpsCovarianceTypeCode position_covariance_type
+end
+
+object GpsSensor
+    implements Sensor
+    implements Device
+    property DeviceInfo device_info [readonly,nolock]
+    property SensorInfo sensor_info [readonly,nolock]
+    wire double[] sensor_value [readonly,nolock]
+    pipe SensorData sensor_data [readonly,nolock]
+    function varvalue getf_param(string param_name)
+    function void setf_param(string param_name, varvalue value)
+    wire GpsState gps_state [readonly,nolock]
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.hid.joystick.robdef

 * *Ordering differences only*

```diff
@@ -1,109 +1,109 @@
-service com.robotraconteur.hid.joystick
-
-stdver 0.10
-
-import com.robotraconteur.device
-import com.robotraconteur.sensordata
-import com.robotraconteur.geometry
-import com.robotraconteur.uuid
-import com.robotraconteur.device.isoch
-import com.robotraconteur.device.clock
-
-using com.robotraconteur.device.DeviceInfo
-using com.robotraconteur.device.Device
-using com.robotraconteur.sensordata.SensorDataHeader
-using com.robotraconteur.geometry.Vector2
-using com.robotraconteur.uuid.UUID
-using com.robotraconteur.device.isoch.IsochDevice
-using com.robotraconteur.device.isoch.IsochInfo
-using com.robotraconteur.device.clock.DeviceClock
-using com.robotraconteur.device.clock.DeviceTime
-
-enum JoystickCapabilities
-    none = 0,
-    rumble = 0x1,
-    force_feedback = 0x2,
-    standard_gamepad = 0x4
-end
-
-enum GamepadButtons
-    button_A = 0x1,
-    button_B = 0x2,
-    button_X = 0x4,
-    button_Y = 0x8,
-    button_back = 0x10,
-    button_guide = 0x20,
-    button_start = 0x40,
-    button_left_stick = 0x80,
-    button_right_stick = 0x100,
-    button_left_shoulder = 0x200,
-    button_right_shoulder = 0x400,
-    button_dpad_up = 0x800,
-    button_dpad_down = 0x1000,
-    button_dpad_left = 0x2000,
-    button_dpad_right = 0x4000
-end
-
-enum JoystickHatState
-    hat_centered = 0,
-    hat_up = 0x01,
-    hat_right = 0x02,
-    hat_down = 0x04,
-    hat_left = 0x08,
-    hat_rightup = 0x03,
-    hat_rightdown = 0x06,
-    hat_leftup = 0x09,
-    hat_leftdown = 0x0C
-end
-
-struct JoystickInfo
-    field DeviceInfo device_info
-    field uint32 id
-    field uint32 axes_count
-    field uint32 button_count
-    field uint32 hat_count
-    field uint32 joystick_capabilities
-    field uint16 joystick_device_vendor
-    field uint16 joystick_device_product
-    field uint16 joystick_device_version
-    field UUID joystick_uuid
-    field varvalue{string} extended
-end
-
-struct JoystickState
-    field int16[] axes
-    field uint8[] buttons
-    field uint8[] hats
-end
-
-struct GamepadState
-    field int16 left_x
-    field int16 left_y
-    field int16 right_x
-    field int16 right_y
-    field int16 trigger_left
-    field int16 trigger_right
-    field uint16 buttons
-end
-
-struct JoystickStateSensorData
-    field SensorDataHeader data_header
-    field JoystickState joystick_state
-    field GamepadState gamepad_state
-end
-
-object Joystick
-    implements Device
-    implements DeviceClock
-    implements IsochDevice
-    property DeviceInfo device_info [readonly,nolock]
-    property JoystickInfo joystick_info [readonly,nolock]
-    property IsochInfo isoch_info [readonly,nolock]
-    property uint32 isoch_downsample [perclient]
-    wire DeviceTime device_clock_now [readonly,nolock]
-    wire JoystickState joystick_state [readonly,nolock]
-    wire GamepadState gamepad_state [readonly,nolock]
-    pipe JoystickStateSensorData joystick_sensor_data [readonly,nolock]
-    function void rumble(double intensity, double duration)
-    function void force_feedback(Vector2 force, double duration)
-end
+service com.robotraconteur.hid.joystick
+
+stdver 0.10
+
+import com.robotraconteur.device
+import com.robotraconteur.sensordata
+import com.robotraconteur.geometry
+import com.robotraconteur.uuid
+import com.robotraconteur.device.isoch
+import com.robotraconteur.device.clock
+
+using com.robotraconteur.device.DeviceInfo
+using com.robotraconteur.device.Device
+using com.robotraconteur.sensordata.SensorDataHeader
+using com.robotraconteur.geometry.Vector2
+using com.robotraconteur.uuid.UUID
+using com.robotraconteur.device.isoch.IsochDevice
+using com.robotraconteur.device.isoch.IsochInfo
+using com.robotraconteur.device.clock.DeviceClock
+using com.robotraconteur.device.clock.DeviceTime
+
+enum JoystickCapabilities
+    none = 0,
+    rumble = 0x1,
+    force_feedback = 0x2,
+    standard_gamepad = 0x4
+end
+
+enum GamepadButtons
+    button_A = 0x1,
+    button_B = 0x2,
+    button_X = 0x4,
+    button_Y = 0x8,
+    button_back = 0x10,
+    button_guide = 0x20,
+    button_start = 0x40,
+    button_left_stick = 0x80,
+    button_right_stick = 0x100,
+    button_left_shoulder = 0x200,
+    button_right_shoulder = 0x400,
+    button_dpad_up = 0x800,
+    button_dpad_down = 0x1000,
+    button_dpad_left = 0x2000,
+    button_dpad_right = 0x4000
+end
+
+enum JoystickHatState
+    hat_centered = 0,
+    hat_up = 0x01,
+    hat_right = 0x02,
+    hat_down = 0x04,
+    hat_left = 0x08,
+    hat_rightup = 0x03,
+    hat_rightdown = 0x06,
+    hat_leftup = 0x09,
+    hat_leftdown = 0x0C
+end
+
+struct JoystickInfo
+    field DeviceInfo device_info
+    field uint32 id
+    field uint32 axes_count
+    field uint32 button_count
+    field uint32 hat_count
+    field uint32 joystick_capabilities
+    field uint16 joystick_device_vendor
+    field uint16 joystick_device_product
+    field uint16 joystick_device_version
+    field UUID joystick_uuid
+    field varvalue{string} extended
+end
+
+struct JoystickState
+    field int16[] axes
+    field uint8[] buttons
+    field uint8[] hats
+end
+
+struct GamepadState
+    field int16 left_x
+    field int16 left_y
+    field int16 right_x
+    field int16 right_y
+    field int16 trigger_left
+    field int16 trigger_right
+    field uint16 buttons
+end
+
+struct JoystickStateSensorData
+    field SensorDataHeader data_header
+    field JoystickState joystick_state
+    field GamepadState gamepad_state
+end
+
+object Joystick
+    implements Device
+    implements DeviceClock
+    implements IsochDevice
+    property DeviceInfo device_info [readonly,nolock]
+    property JoystickInfo joystick_info [readonly,nolock]
+    property IsochInfo isoch_info [readonly,nolock]
+    property uint32 isoch_downsample [perclient]
+    wire DeviceTime device_clock_now [readonly,nolock]
+    wire JoystickState joystick_state [readonly,nolock]
+    wire GamepadState gamepad_state [readonly,nolock]
+    pipe JoystickStateSensorData joystick_sensor_data [readonly,nolock]
+    function void rumble(double intensity, double duration)
+    function void force_feedback(Vector2 force, double duration)
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.identifier.robdef

 * *Ordering differences only*

```diff
@@ -1,12 +1,12 @@
-service com.robotraconteur.identifier
-
-stdver 0.10
-
-import com.robotraconteur.uuid
-
-using com.robotraconteur.uuid.UUID
-
-struct Identifier
-    field string name
-    field UUID uuid
-end
+service com.robotraconteur.identifier
+
+stdver 0.10
+
+import com.robotraconteur.uuid
+
+using com.robotraconteur.uuid.UUID
+
+struct Identifier
+    field string name
+    field UUID uuid
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.image.robdef

 * *Ordering differences only*

```diff
@@ -1,124 +1,124 @@
-service com.robotraconteur.image
-
-stdver 0.10
-
-import com.robotraconteur.sensordata
-import com.robotraconteur.identifier
-import com.robotraconteur.resource
-
-using com.robotraconteur.sensordata.SensorDataHeader
-using com.robotraconteur.identifier.Identifier
-using com.robotraconteur.resource.ResourceIdentifier
-
-enum ImageEncoding
-    unknown = 0,
-    rgb888 = 0x1000,
-    rgba8888,
-    bgr888,
-    bgra8888,
-    rgba16_16_16_16,
-    bgra16_16_16_16,
-    mono8 = 0x2000,
-    mono16,
-    mono32,
-    mono_f16,
-    mono_f32,
-    mono_f64,
-    bayer_rggb8888 = 0x3000,
-    bayer_bggr8888,
-    bayer_gbrg8888,
-    bayer_grbg8888,
-    depth_u16 = 0x4000,
-    depth_i16,
-    depth_u32,
-    depth_i32,
-    depth_u64,
-    depth_i64,
-    depth_f32,
-    depth_f64,
-    freeform = 0x5000,
-    compressed = 0x6000,
-    other = 0x8000
-end
-
-namedarray PixelRGB
-    field uint8 r
-    field uint8 g
-    field uint8 b
-end
-
-namedarray PixelRGBA
-    field uint8 r
-    field uint8 g
-    field uint8 b
-    field uint8 a
-end
-
-# Used with laser scan and point cloud
-namedarray PixelRGBFloatPacked
-    field double rgb
-end
-namedarray PixelRGBFloatPackedf
-    field single rgb
-end
-
-struct ImageInfo
-    field SensorDataHeader data_header
-    field uint32 height
-    field uint32 width
-    field uint32 step
-    field ImageEncoding encoding
-    field varvalue{string} extended
-end
-
-struct FreeformImageInfo
-    field ImageInfo image_info
-    field string encoding
-    field varvalue{string} extended
-end
-
-struct Image
-    field ImageInfo image_info
-    # Data is always little-endian
-    field uint8[] data
-end
-
-struct CompressedImage
-    field ImageInfo image_info
-    # Use magic to determine data type
-    field uint8[] data
-end
-
-struct FreeformImage
-    field FreeformImageInfo image_info
-    field varvalue data
-    field varvalue{string} extended
-end
-
-struct ImagePart
-    field ImageInfo image_info
-    # Data is always little-endian
-    field uint32 data_offset
-    field uint32 data_total_len
-    field uint8[] data_part
-end
-
-struct CompressedImagePart
-    field ImageInfo image_info
-    # Data is always little-endian
-    field uint32 data_offset
-    field uint32 data_total_len
-    field uint8[] data_part
-end
-
-struct FreeformImagePart
-    field FreeformImageInfo image_info
-    field uint32 data_offset
-    field uint32 data_total_len
-    field varvalue data_part
-    field varvalue{string} extended
-end
-
-struct ImageResource
-    field ResourceIdentifier image_resource
-end
+service com.robotraconteur.image
+
+stdver 0.10
+
+import com.robotraconteur.sensordata
+import com.robotraconteur.identifier
+import com.robotraconteur.resource
+
+using com.robotraconteur.sensordata.SensorDataHeader
+using com.robotraconteur.identifier.Identifier
+using com.robotraconteur.resource.ResourceIdentifier
+
+enum ImageEncoding
+    unknown = 0,
+    rgb888 = 0x1000,
+    rgba8888,
+    bgr888,
+    bgra8888,
+    rgba16_16_16_16,
+    bgra16_16_16_16,
+    mono8 = 0x2000,
+    mono16,
+    mono32,
+    mono_f16,
+    mono_f32,
+    mono_f64,
+    bayer_rggb8888 = 0x3000,
+    bayer_bggr8888,
+    bayer_gbrg8888,
+    bayer_grbg8888,
+    depth_u16 = 0x4000,
+    depth_i16,
+    depth_u32,
+    depth_i32,
+    depth_u64,
+    depth_i64,
+    depth_f32,
+    depth_f64,
+    freeform = 0x5000,
+    compressed = 0x6000,
+    other = 0x8000
+end
+
+namedarray PixelRGB
+    field uint8 r
+    field uint8 g
+    field uint8 b
+end
+
+namedarray PixelRGBA
+    field uint8 r
+    field uint8 g
+    field uint8 b
+    field uint8 a
+end
+
+# Used with laser scan and point cloud
+namedarray PixelRGBFloatPacked
+    field double rgb
+end
+namedarray PixelRGBFloatPackedf
+    field single rgb
+end
+
+struct ImageInfo
+    field SensorDataHeader data_header
+    field uint32 height
+    field uint32 width
+    field uint32 step
+    field ImageEncoding encoding
+    field varvalue{string} extended
+end
+
+struct FreeformImageInfo
+    field ImageInfo image_info
+    field string encoding
+    field varvalue{string} extended
+end
+
+struct Image
+    field ImageInfo image_info
+    # Data is always little-endian
+    field uint8[] data
+end
+
+struct CompressedImage
+    field ImageInfo image_info
+    # Use magic to determine data type
+    field uint8[] data
+end
+
+struct FreeformImage
+    field FreeformImageInfo image_info
+    field varvalue data
+    field varvalue{string} extended
+end
+
+struct ImagePart
+    field ImageInfo image_info
+    # Data is always little-endian
+    field uint32 data_offset
+    field uint32 data_total_len
+    field uint8[] data_part
+end
+
+struct CompressedImagePart
+    field ImageInfo image_info
+    # Data is always little-endian
+    field uint32 data_offset
+    field uint32 data_total_len
+    field uint8[] data_part
+end
+
+struct FreeformImagePart
+    field FreeformImageInfo image_info
+    field uint32 data_offset
+    field uint32 data_total_len
+    field varvalue data_part
+    field varvalue{string} extended
+end
+
+struct ImageResource
+    field ResourceIdentifier image_resource
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.imaging.camerainfo.robdef

 * *Ordering differences only*

```diff
@@ -1,42 +1,42 @@
-service com.robotraconteur.imaging.camerainfo
-
-stdver 0.10
-
-import com.robotraconteur.identifier
-import com.robotraconteur.geometry
-import com.robotraconteur.geometryi
-import com.robotraconteur.device
-
-using com.robotraconteur.identifier.Identifier
-using com.robotraconteur.geometry.NamedPose
-using com.robotraconteur.geometryi.Size2D
-using com.robotraconteur.device.DeviceInfo
-
-struct PlumbBobDistortionInfo
-    field double k1
-    field double k2
-    field double p1
-    field double p2
-    field double k3
-end
-
-struct CameraCalibration
-    field Size2D image_size
-    field varvalue distortion_info
-    field double[3,3] K
-    field Identifier parent_device
-    field NamedPose camera_pose
-    field varvalue{string} extended
-end
-
-struct CameraInfo
-    field DeviceInfo device_info
-    field CameraCalibration calibration
-    field varvalue{string} extended
-end
-
-struct MultiCameraInfo
-    field DeviceInfo device_info
-    field CameraInfo{int32} camera_info_all
-    field varvalue{string} extended
-end
+service com.robotraconteur.imaging.camerainfo
+
+stdver 0.10
+
+import com.robotraconteur.identifier
+import com.robotraconteur.geometry
+import com.robotraconteur.geometryi
+import com.robotraconteur.device
+
+using com.robotraconteur.identifier.Identifier
+using com.robotraconteur.geometry.NamedPose
+using com.robotraconteur.geometryi.Size2D
+using com.robotraconteur.device.DeviceInfo
+
+struct PlumbBobDistortionInfo
+    field double k1
+    field double k2
+    field double p1
+    field double p2
+    field double k3
+end
+
+struct CameraCalibration
+    field Size2D image_size
+    field varvalue distortion_info
+    field double[3,3] K
+    field Identifier parent_device
+    field NamedPose camera_pose
+    field varvalue{string} extended
+end
+
+struct CameraInfo
+    field DeviceInfo device_info
+    field CameraCalibration calibration
+    field varvalue{string} extended
+end
+
+struct MultiCameraInfo
+    field DeviceInfo device_info
+    field CameraInfo{int32} camera_info_all
+    field varvalue{string} extended
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.imaging.robdef

 * *Ordering differences only*

```diff
@@ -1,126 +1,126 @@
-service com.robotraconteur.imaging
-
-stdver 0.10
-
-import com.robotraconteur.image
-import com.robotraconteur.imaging.camerainfo
-import com.robotraconteur.param
-import com.robotraconteur.device
-import com.robotraconteur.device.isoch
-import com.robotraconteur.device.clock
-import com.robotraconteur.datetime
-
-using com.robotraconteur.image.Image
-using com.robotraconteur.image.ImagePart
-using com.robotraconteur.image.CompressedImage
-using com.robotraconteur.imaging.camerainfo.CameraInfo
-using com.robotraconteur.imaging.camerainfo.MultiCameraInfo
-using com.robotraconteur.param.ParameterInfo
-using com.robotraconteur.device.Device
-using com.robotraconteur.device.DeviceInfo
-using com.robotraconteur.device.isoch.IsochDevice
-using com.robotraconteur.device.isoch.IsochInfo
-using com.robotraconteur.device.clock.DeviceClock
-using com.robotraconteur.device.clock.DeviceTime
-using com.robotraconteur.datetime.TimeSpec3
-
-enum TriggerMode
-   unknown = 0,
-   software,
-   continuous,
-   external,
-   aux1,
-   aux2,
-   aux3,
-   aux4
-end
-
-enum Capabilities
-   unknown = 0,
-   still = 0x1,
-   stream = 0x2,
-   preview = 0x4,
-   software_trigger = 0x10,
-   continuous_trigger = 0x20,
-   external_trigger = 0x40,
-   aux_trigger = 0x80
-end
-
-enum CameraStateFlags
-    unknown = 0,
-    ready = 0x1,
-    streaming = 0x2,
-    warning = 0x4,
-    error = 0x8,
-    fatal_error = 0x10
-end
-
-struct CameraState
-    field TimeSpec3 ts
-    field uint64 seqno
-    field int32 state_flags
-    field varvalue{string} extended
-end
-
-object Camera
-    implements Device
-    implements DeviceClock
-    implements IsochDevice
-    property DeviceInfo device_info [readonly,nolock]
-    property CameraInfo camera_info [readonly,nolock]
-    property uint32 capabilities [readonly]
-    function Image capture_frame()
-    function CompressedImage capture_frame_compressed()
-    property TriggerMode trigger_mode [nolockread]
-    function void trigger()
-    function void start_streaming()
-    function void stop_streaming()
-    wire CameraState camera_state [readonly,nolock]
-    pipe Image frame_stream [readonly]
-    pipe CompressedImage frame_stream_compressed [readonly]
-    pipe CompressedImage preview_stream [readonly,nolock]
-    property ParameterInfo{list} param_info [readonly]
-    function varvalue getf_param(string param_name)
-    function void setf_param(string param_name, varvalue value)
-    property IsochInfo isoch_info [readonly,nolock]
-    property uint32 isoch_downsample [perclient]
-    wire DeviceTime device_clock_now [readonly,nolock]
-end
-
-object MultiCamera
-    implements Device
-    property DeviceInfo device_info [readonly,nolock]
-    property MultiCameraInfo multicamera_info [readonly,nolock]
-    property string{int32} camera_names [readonly,nolock]
-    objref Camera{int32} cameras
-    function Image{int32} capture_frame_all()
-    function void trigger_all()
-    pipe Image{int32} frame_stream_all [readonly]
-    pipe CompressedImage{int32} frame_stream_compressed_all [readonly]
-    pipe CompressedImage{int32} preview_stream_all [readonly,nolock]
-    property ParameterInfo{list} param_info [readonly]
-    function varvalue getf_param(string param_name)
-    function void setf_param(string param_name, varvalue value)
-end
-
-object ImagePartCamera
-    implements Device
-    implements DeviceClock
-    implements IsochDevice
-    property DeviceInfo device_info [readonly,nolock]
-    property CameraInfo camera_info [readonly,nolock]
-    property uint32 capabilities [readonly]
-    function ImagePart{generator} capture_frame()
-    property TriggerMode trigger_mode [nolockread]
-    function void trigger()
-    function void start_streaming()
-    function void stop_streaming()
-    wire CameraState camera_state [readonly,nolock]
-    pipe CompressedImage preview_stream [readonly,nolock]
-    property ParameterInfo{list} param_info [readonly]
-    function varvalue getf_param(string param_name)
-    function void setf_param(string param_name, varvalue value)
-    property IsochInfo isoch_info [readonly,nolock]
-    property uint32 isoch_downsample [perclient]
-    wire DeviceTime device_clock_now [readonly,nolock]
-end
+service com.robotraconteur.imaging
+
+stdver 0.10
+
+import com.robotraconteur.image
+import com.robotraconteur.imaging.camerainfo
+import com.robotraconteur.param
+import com.robotraconteur.device
+import com.robotraconteur.device.isoch
+import com.robotraconteur.device.clock
+import com.robotraconteur.datetime
+
+using com.robotraconteur.image.Image
+using com.robotraconteur.image.ImagePart
+using com.robotraconteur.image.CompressedImage
+using com.robotraconteur.imaging.camerainfo.CameraInfo
+using com.robotraconteur.imaging.camerainfo.MultiCameraInfo
+using com.robotraconteur.param.ParameterInfo
+using com.robotraconteur.device.Device
+using com.robotraconteur.device.DeviceInfo
+using com.robotraconteur.device.isoch.IsochDevice
+using com.robotraconteur.device.isoch.IsochInfo
+using com.robotraconteur.device.clock.DeviceClock
+using com.robotraconteur.device.clock.DeviceTime
+using com.robotraconteur.datetime.TimeSpec3
+
+enum TriggerMode
+   unknown = 0,
+   software,
+   continuous,
+   external,
+   aux1,
+   aux2,
+   aux3,
+   aux4
+end
+
+enum Capabilities
+   unknown = 0,
+   still = 0x1,
+   stream = 0x2,
+   preview = 0x4,
+   software_trigger = 0x10,
+   continuous_trigger = 0x20,
+   external_trigger = 0x40,
+   aux_trigger = 0x80
+end
+
+enum CameraStateFlags
+    unknown = 0,
+    ready = 0x1,
+    streaming = 0x2,
+    warning = 0x4,
+    error = 0x8,
+    fatal_error = 0x10
+end
+
+struct CameraState
+    field TimeSpec3 ts
+    field uint64 seqno
+    field int32 state_flags
+    field varvalue{string} extended
+end
+
+object Camera
+    implements Device
+    implements DeviceClock
+    implements IsochDevice
+    property DeviceInfo device_info [readonly,nolock]
+    property CameraInfo camera_info [readonly,nolock]
+    property uint32 capabilities [readonly]
+    function Image capture_frame()
+    function CompressedImage capture_frame_compressed()
+    property TriggerMode trigger_mode [nolockread]
+    function void trigger()
+    function void start_streaming()
+    function void stop_streaming()
+    wire CameraState camera_state [readonly,nolock]
+    pipe Image frame_stream [readonly]
+    pipe CompressedImage frame_stream_compressed [readonly]
+    pipe CompressedImage preview_stream [readonly,nolock]
+    property ParameterInfo{list} param_info [readonly]
+    function varvalue getf_param(string param_name)
+    function void setf_param(string param_name, varvalue value)
+    property IsochInfo isoch_info [readonly,nolock]
+    property uint32 isoch_downsample [perclient]
+    wire DeviceTime device_clock_now [readonly,nolock]
+end
+
+object MultiCamera
+    implements Device
+    property DeviceInfo device_info [readonly,nolock]
+    property MultiCameraInfo multicamera_info [readonly,nolock]
+    property string{int32} camera_names [readonly,nolock]
+    objref Camera{int32} cameras
+    function Image{int32} capture_frame_all()
+    function void trigger_all()
+    pipe Image{int32} frame_stream_all [readonly]
+    pipe CompressedImage{int32} frame_stream_compressed_all [readonly]
+    pipe CompressedImage{int32} preview_stream_all [readonly,nolock]
+    property ParameterInfo{list} param_info [readonly]
+    function varvalue getf_param(string param_name)
+    function void setf_param(string param_name, varvalue value)
+end
+
+object ImagePartCamera
+    implements Device
+    implements DeviceClock
+    implements IsochDevice
+    property DeviceInfo device_info [readonly,nolock]
+    property CameraInfo camera_info [readonly,nolock]
+    property uint32 capabilities [readonly]
+    function ImagePart{generator} capture_frame()
+    property TriggerMode trigger_mode [nolockread]
+    function void trigger()
+    function void start_streaming()
+    function void stop_streaming()
+    wire CameraState camera_state [readonly,nolock]
+    pipe CompressedImage preview_stream [readonly,nolock]
+    property ParameterInfo{list} param_info [readonly]
+    function varvalue getf_param(string param_name)
+    function void setf_param(string param_name, varvalue value)
+    property IsochInfo isoch_info [readonly,nolock]
+    property uint32 isoch_downsample [perclient]
+    wire DeviceTime device_clock_now [readonly,nolock]
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.imu.robdef

 * *Ordering differences only*

```diff
@@ -1,36 +1,36 @@
-service com.robotraconteur.imu
-
-stdver 0.10
-
-import com.robotraconteur.sensor
-import com.robotraconteur.geometry
-import com.robotraconteur.device
-
-using com.robotraconteur.sensor.Sensor
-using com.robotraconteur.sensor.SensorInfo
-using com.robotraconteur.sensor.SensorData
-using com.robotraconteur.geometry.Vector3
-using com.robotraconteur.geometry.Quaternion
-using com.robotraconteur.device.Device
-using com.robotraconteur.device.DeviceInfo
-
-struct ImuState
-    field Vector3 angular_velocity
-    field double[3,3] angular_velocity_covariance
-    field Vector3 linear_acceleration
-    field double[3,3] linear_acceleration_covariance
-    field Quaternion orientation
-    field double[3,3] orientation_covariance
-end
-
-object ImuSensor
-    implements Device
-    implements Sensor
-    property DeviceInfo device_info [readonly,nolock]
-    property SensorInfo sensor_info [readonly,nolock]
-    wire double[] sensor_value [readonly,nolock]
-    pipe SensorData sensor_data [readonly,nolock]
-    function varvalue getf_param(string param_name)
-    function void setf_param(string param_name, varvalue value)
-    wire ImuState imu_state [readonly,nolock]
-end
+service com.robotraconteur.imu
+
+stdver 0.10
+
+import com.robotraconteur.sensor
+import com.robotraconteur.geometry
+import com.robotraconteur.device
+
+using com.robotraconteur.sensor.Sensor
+using com.robotraconteur.sensor.SensorInfo
+using com.robotraconteur.sensor.SensorData
+using com.robotraconteur.geometry.Vector3
+using com.robotraconteur.geometry.Quaternion
+using com.robotraconteur.device.Device
+using com.robotraconteur.device.DeviceInfo
+
+struct ImuState
+    field Vector3 angular_velocity
+    field double[3,3] angular_velocity_covariance
+    field Vector3 linear_acceleration
+    field double[3,3] linear_acceleration_covariance
+    field Quaternion orientation
+    field double[3,3] orientation_covariance
+end
+
+object ImuSensor
+    implements Device
+    implements Sensor
+    property DeviceInfo device_info [readonly,nolock]
+    property SensorInfo sensor_info [readonly,nolock]
+    wire double[] sensor_value [readonly,nolock]
+    pipe SensorData sensor_data [readonly,nolock]
+    function varvalue getf_param(string param_name)
+    function void setf_param(string param_name, varvalue value)
+    wire ImuState imu_state [readonly,nolock]
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.laserscan.robdef

 * *Ordering differences only*

```diff
@@ -1,83 +1,83 @@
-service com.robotraconteur.laserscan
-
-stdver 0.10
-
-import com.robotraconteur.image
-import com.robotraconteur.sensordata
-
-using com.robotraconteur.image.PixelRGB
-using com.robotraconteur.sensordata.SensorDataHeader
-
-struct LaserScanInfo
-    field SensorDataHeader data_header
-    field double angle_min
-    field double angle_max
-    field double angle_increment
-    field uint32 angle_count
-    field double vertical_angle_min
-    field double vertical_angle_max
-    field double vertical_angle_increment
-    field uint32 vertical_angle_count
-    field double time_increment
-    field double scan_time
-    field double range_min
-    field double range_max
-    field double range_resolution
-end
-
-struct LaserScan
-    field LaserScanInfo scan_info
-    field double[] ranges
-    field double[] intensities
-    field PixelRGB[] color
-    field int32[] fiducial
-    field varvalue{string} extended
-end
-
-struct LaserScanInfof
-    field SensorDataHeader data_header
-    field single angle_min
-    field single angle_max
-    field single angle_increment
-    field uint32 angle_count
-    field single vertical_angle_min
-    field single vertical_angle_max
-    field single vertical_angle_increment
-    field uint32 vertical_angle_count
-    field single time_increment
-    field single scan_time
-    field single range_min
-    field single range_max
-    field single range_resolution
-end
-
-struct LaserScanf
-    field LaserScanInfof scan_info
-    field single[] ranges
-    field single[] intensities
-    field PixelRGB[] color
-    field int32[] fiducial
-    field varvalue{string} extended
-end
-
-struct LaserScanPart
-    field LaserScanInfo scan_info
-    field uint32 data_offset
-    field uint32 data_total_len
-    field double[] ranges
-    field double[] intensities
-    field PixelRGB[] color
-    field int32[] fiducial
-    field varvalue{string} extended
-end
-
-struct LaserScanPartf
-    field LaserScanInfof scan_info
-    field uint32 data_offset
-    field uint32 data_total_len
-    field single[] ranges
-    field single[] intensities
-    field PixelRGB[] color
-    field int32[] fiducial
-    field varvalue{string} extended
-end
+service com.robotraconteur.laserscan
+
+stdver 0.10
+
+import com.robotraconteur.image
+import com.robotraconteur.sensordata
+
+using com.robotraconteur.image.PixelRGB
+using com.robotraconteur.sensordata.SensorDataHeader
+
+struct LaserScanInfo
+    field SensorDataHeader data_header
+    field double angle_min
+    field double angle_max
+    field double angle_increment
+    field uint32 angle_count
+    field double vertical_angle_min
+    field double vertical_angle_max
+    field double vertical_angle_increment
+    field uint32 vertical_angle_count
+    field double time_increment
+    field double scan_time
+    field double range_min
+    field double range_max
+    field double range_resolution
+end
+
+struct LaserScan
+    field LaserScanInfo scan_info
+    field double[] ranges
+    field double[] intensities
+    field PixelRGB[] color
+    field int32[] fiducial
+    field varvalue{string} extended
+end
+
+struct LaserScanInfof
+    field SensorDataHeader data_header
+    field single angle_min
+    field single angle_max
+    field single angle_increment
+    field uint32 angle_count
+    field single vertical_angle_min
+    field single vertical_angle_max
+    field single vertical_angle_increment
+    field uint32 vertical_angle_count
+    field single time_increment
+    field single scan_time
+    field single range_min
+    field single range_max
+    field single range_resolution
+end
+
+struct LaserScanf
+    field LaserScanInfof scan_info
+    field single[] ranges
+    field single[] intensities
+    field PixelRGB[] color
+    field int32[] fiducial
+    field varvalue{string} extended
+end
+
+struct LaserScanPart
+    field LaserScanInfo scan_info
+    field uint32 data_offset
+    field uint32 data_total_len
+    field double[] ranges
+    field double[] intensities
+    field PixelRGB[] color
+    field int32[] fiducial
+    field varvalue{string} extended
+end
+
+struct LaserScanPartf
+    field LaserScanInfof scan_info
+    field uint32 data_offset
+    field uint32 data_total_len
+    field single[] ranges
+    field single[] intensities
+    field PixelRGB[] color
+    field int32[] fiducial
+    field varvalue{string} extended
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.laserscanner.robdef

 * *Ordering differences only*

```diff
@@ -1,38 +1,38 @@
-service com.robotraconteur.laserscanner
-
-stdver 0.10
-
-import com.robotraconteur.device
-import com.robotraconteur.param
-import com.robotraconteur.laserscan
-
-using com.robotraconteur.device.DeviceInfo
-using com.robotraconteur.device.Device
-using com.robotraconteur.param.ParameterInfo
-using com.robotraconteur.laserscan.LaserScanInfof as LaserScanInfo
-using com.robotraconteur.laserscan.LaserScanf as LaserScan
-using com.robotraconteur.laserscan.LaserScanPartf as LaserScanPart
-
-struct LaserScannerInfo
-    field DeviceInfo device_info
-    field LaserScanInfo scanner_info
-    field double scan_rate
-    field ParameterInfo{list} param_info
-    field varvalue{string} extended
-end
-
-object LaserScanner
-    implements Device
-    property DeviceInfo device_info [readonly,nolock]
-    property LaserScannerInfo scanner_info [readonly,nolock]
-    pipe LaserScan laser_scan_sensor_data [readonly]
-    function varvalue getf_param(string param_name)
-    function void setf_param(string param_name, varvalue value)
-end
-
-object LaserScanPartScanner
-    property LaserScannerInfo scanner_info [readonly,nolock]
-    pipe LaserScanPart laser_scan_sensor_data [readonly]
-    function varvalue getf_param(string param_name)
-    function void setf_param(string param_name, varvalue value)
-end
+service com.robotraconteur.laserscanner
+
+stdver 0.10
+
+import com.robotraconteur.device
+import com.robotraconteur.param
+import com.robotraconteur.laserscan
+
+using com.robotraconteur.device.DeviceInfo
+using com.robotraconteur.device.Device
+using com.robotraconteur.param.ParameterInfo
+using com.robotraconteur.laserscan.LaserScanInfof as LaserScanInfo
+using com.robotraconteur.laserscan.LaserScanf as LaserScan
+using com.robotraconteur.laserscan.LaserScanPartf as LaserScanPart
+
+struct LaserScannerInfo
+    field DeviceInfo device_info
+    field LaserScanInfo scanner_info
+    field double scan_rate
+    field ParameterInfo{list} param_info
+    field varvalue{string} extended
+end
+
+object LaserScanner
+    implements Device
+    property DeviceInfo device_info [readonly,nolock]
+    property LaserScannerInfo scanner_info [readonly,nolock]
+    pipe LaserScan laser_scan_sensor_data [readonly]
+    function varvalue getf_param(string param_name)
+    function void setf_param(string param_name, varvalue value)
+end
+
+object LaserScanPartScanner
+    property LaserScannerInfo scanner_info [readonly,nolock]
+    pipe LaserScanPart laser_scan_sensor_data [readonly]
+    function varvalue getf_param(string param_name)
+    function void setf_param(string param_name, varvalue value)
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.lighting.robdef

 * *Ordering differences only*

```diff
@@ -1,42 +1,42 @@
-service com.robotraconteur.lighting
-
-stdver 0.10
-
-import com.robotraconteur.color
-import com.robotraconteur.device
-
-using com.robotraconteur.color.ColorRGBA
-using com.robotraconteur.device.DeviceInfo
-using com.robotraconteur.device.Device
-
-struct LightInfo
-    field DeviceInfo device_info
-    field double max_lumens
-    field varvalue{string} extended
-end
-
-object Light
-    property DeviceInfo device_info [readonly,nolock]
-    property LightInfo light_info [readonly,nolock]
-    property bool on_off
-end
-
-object DimmableLight
-    implements Light
-    property DeviceInfo device_info [readonly,nolock]
-    property LightInfo light_info [readonly,nolock]
-    property bool on_off
-    # intensity 0.0 to 1.0
-    property double intensity
-end
-
-object ColorTunableLight
-    implements Light
-    implements DimmableLight
-    property DeviceInfo device_info [readonly,nolock]
-    property LightInfo light_info [readonly,nolock]
-    property bool on_off
-    # intensity 0.0 to 1.0
-    property double intensity
-    property ColorRGBA color
-end
+service com.robotraconteur.lighting
+
+stdver 0.10
+
+import com.robotraconteur.color
+import com.robotraconteur.device
+
+using com.robotraconteur.color.ColorRGBA
+using com.robotraconteur.device.DeviceInfo
+using com.robotraconteur.device.Device
+
+struct LightInfo
+    field DeviceInfo device_info
+    field double max_lumens
+    field varvalue{string} extended
+end
+
+object Light
+    property DeviceInfo device_info [readonly,nolock]
+    property LightInfo light_info [readonly,nolock]
+    property bool on_off
+end
+
+object DimmableLight
+    implements Light
+    property DeviceInfo device_info [readonly,nolock]
+    property LightInfo light_info [readonly,nolock]
+    property bool on_off
+    # intensity 0.0 to 1.0
+    property double intensity
+end
+
+object ColorTunableLight
+    implements Light
+    implements DimmableLight
+    property DeviceInfo device_info [readonly,nolock]
+    property LightInfo light_info [readonly,nolock]
+    property bool on_off
+    # intensity 0.0 to 1.0
+    property double intensity
+    property ColorRGBA color
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.objectrecognition.robdef

 * *Ordering differences only*

```diff
@@ -1,83 +1,83 @@
-service com.robotraconteur.objectrecognition
-
-stdver 0.10
-
-import com.robotraconteur.identifier
-import com.robotraconteur.geometry
-import com.robotraconteur.geometry.shapes
-import com.robotraconteur.param
-import com.robotraconteur.device
-import com.robotraconteur.device.isoch
-import com.robotraconteur.sensordata
-import com.robotraconteur.device.clock
-import com.robotraconteur.fiducial
-
-using com.robotraconteur.identifier.Identifier
-using com.robotraconteur.device.Device
-using com.robotraconteur.device.DeviceInfo
-using com.robotraconteur.device.DeviceClass
-using com.robotraconteur.device.isoch.IsochDevice
-using com.robotraconteur.device.isoch.IsochInfo
-using com.robotraconteur.param.ParameterInfo
-using com.robotraconteur.geometry.shapes.ShapeObject
-using com.robotraconteur.geometry.NamedPoseWithCovariance
-using com.robotraconteur.geometry.BoundingBox
-using com.robotraconteur.geometry.Vector3
-using com.robotraconteur.sensordata.SensorDataHeader
-using com.robotraconteur.device.clock.DeviceClock
-using com.robotraconteur.device.clock.DeviceTime
-using com.robotraconteur.fiducial.Fiducial
-
-struct ObjectRecognitionTemplate
-    field Identifier object_identifier
-    field DeviceClass object_class
-    field ShapeObject object_shape
-    field Fiducial{list} object_fiducials
-    field varvalue{string} extended
-end
-
-struct RecognizedObject
-    field Identifier recognized_object
-    field DeviceClass recognized_object_class
-    field NamedPoseWithCovariance pose
-    field double confidence
-    field varvalue{string} extended
-end
-
-struct RecognizedObjects
-    field RecognizedObject{list} recognized_objects
-    field varvalue source_data
-    field varvalue{string} extended
-end
-
-struct ObjectRecognitionSensorInfo
-    field DeviceInfo device_info
-    field BoundingBox range
-    field Vector3 resolution
-    field ParameterInfo{list} param_info
-    field Identifier{list} object_template_identifiers
-    field DeviceClass{list} object_template_classes
-    field varvalue{string} extended
-end
-
-struct ObjectRecognitionSensorData
-    field SensorDataHeader sensor_data
-    field RecognizedObjects recognized_objects
-end
-
-object ObjectRecognitionSensor
-    implements Device
-    implements DeviceClock
-    implements IsochDevice
-    property DeviceInfo device_info [readonly,nolock]
-    property ObjectRecognitionSensorInfo object_recognition_sensor_info [readonly,nolock]
-    function RecognizedObjects capture_recognized_objects()
-    pipe ObjectRecognitionSensorData object_recognition_sensor_data [readonly]
-    function varvalue getf_param(string param_name)
-    function void setf_param(string param_name, varvalue value)
-    function ObjectRecognitionTemplate getf_object_template(Identifier object_identifier)
-    function ObjectRecognitionTemplate getf_object_class_template(Identifier object_class)
-    property IsochInfo isoch_info [readonly,nolock]
-    property uint32 isoch_downsample [perclient]
-    wire DeviceTime device_clock_now [readonly,nolock]
-end
+service com.robotraconteur.objectrecognition
+
+stdver 0.10
+
+import com.robotraconteur.identifier
+import com.robotraconteur.geometry
+import com.robotraconteur.geometry.shapes
+import com.robotraconteur.param
+import com.robotraconteur.device
+import com.robotraconteur.device.isoch
+import com.robotraconteur.sensordata
+import com.robotraconteur.device.clock
+import com.robotraconteur.fiducial
+
+using com.robotraconteur.identifier.Identifier
+using com.robotraconteur.device.Device
+using com.robotraconteur.device.DeviceInfo
+using com.robotraconteur.device.DeviceClass
+using com.robotraconteur.device.isoch.IsochDevice
+using com.robotraconteur.device.isoch.IsochInfo
+using com.robotraconteur.param.ParameterInfo
+using com.robotraconteur.geometry.shapes.ShapeObject
+using com.robotraconteur.geometry.NamedPoseWithCovariance
+using com.robotraconteur.geometry.BoundingBox
+using com.robotraconteur.geometry.Vector3
+using com.robotraconteur.sensordata.SensorDataHeader
+using com.robotraconteur.device.clock.DeviceClock
+using com.robotraconteur.device.clock.DeviceTime
+using com.robotraconteur.fiducial.Fiducial
+
+struct ObjectRecognitionTemplate
+    field Identifier object_identifier
+    field DeviceClass object_class
+    field ShapeObject object_shape
+    field Fiducial{list} object_fiducials
+    field varvalue{string} extended
+end
+
+struct RecognizedObject
+    field Identifier recognized_object
+    field DeviceClass recognized_object_class
+    field NamedPoseWithCovariance pose
+    field double confidence
+    field varvalue{string} extended
+end
+
+struct RecognizedObjects
+    field RecognizedObject{list} recognized_objects
+    field varvalue source_data
+    field varvalue{string} extended
+end
+
+struct ObjectRecognitionSensorInfo
+    field DeviceInfo device_info
+    field BoundingBox range
+    field Vector3 resolution
+    field ParameterInfo{list} param_info
+    field Identifier{list} object_template_identifiers
+    field DeviceClass{list} object_template_classes
+    field varvalue{string} extended
+end
+
+struct ObjectRecognitionSensorData
+    field SensorDataHeader sensor_data
+    field RecognizedObjects recognized_objects
+end
+
+object ObjectRecognitionSensor
+    implements Device
+    implements DeviceClock
+    implements IsochDevice
+    property DeviceInfo device_info [readonly,nolock]
+    property ObjectRecognitionSensorInfo object_recognition_sensor_info [readonly,nolock]
+    function RecognizedObjects capture_recognized_objects()
+    pipe ObjectRecognitionSensorData object_recognition_sensor_data [readonly]
+    function varvalue getf_param(string param_name)
+    function void setf_param(string param_name, varvalue value)
+    function ObjectRecognitionTemplate getf_object_template(Identifier object_identifier)
+    function ObjectRecognitionTemplate getf_object_class_template(Identifier object_class)
+    property IsochInfo isoch_info [readonly,nolock]
+    property uint32 isoch_downsample [perclient]
+    wire DeviceTime device_clock_now [readonly,nolock]
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.octree.robdef

 * *Ordering differences only*

```diff
@@ -1,43 +1,43 @@
-service com.robotraconteur.octree
-
-stdver 0.10
-
-import com.robotraconteur.sensordata
-import com.robotraconteur.identifier
-import com.robotraconteur.resource
-
-using com.robotraconteur.sensordata.SensorDataHeader
-using com.robotraconteur.identifier.Identifier
-using com.robotraconteur.resource.ResourceIdentifier
-
-enum OcTreeEncoding
-    unknown=0,
-    octomap_ot,
-    octomap_bt,
-    other
-end
-
-struct OcTreeInfo
-    field SensorDataHeader data_header
-    field OcTreeEncoding encoding
-    field string id
-    field double resolution
-end
-
-struct OcTree
-    field OcTreeInfo octree_info
-    field uint8[] data
-    field varvalue{string} extended
-end
-
-struct OcTreePart
-    field OcTreeInfo octree_info
-    field uint32 data_offset
-    field uint32 data_total_len
-    field uint8[] data
-    field varvalue{string} extended
-end
-
-struct OcTreeResource
-    field ResourceIdentifier octree_resource
-end
+service com.robotraconteur.octree
+
+stdver 0.10
+
+import com.robotraconteur.sensordata
+import com.robotraconteur.identifier
+import com.robotraconteur.resource
+
+using com.robotraconteur.sensordata.SensorDataHeader
+using com.robotraconteur.identifier.Identifier
+using com.robotraconteur.resource.ResourceIdentifier
+
+enum OcTreeEncoding
+    unknown=0,
+    octomap_ot,
+    octomap_bt,
+    other
+end
+
+struct OcTreeInfo
+    field SensorDataHeader data_header
+    field OcTreeEncoding encoding
+    field string id
+    field double resolution
+end
+
+struct OcTree
+    field OcTreeInfo octree_info
+    field uint8[] data
+    field varvalue{string} extended
+end
+
+struct OcTreePart
+    field OcTreeInfo octree_info
+    field uint32 data_offset
+    field uint32 data_total_len
+    field uint8[] data
+    field varvalue{string} extended
+end
+
+struct OcTreeResource
+    field ResourceIdentifier octree_resource
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.param.robdef

 * *Ordering differences only*

```diff
@@ -1,26 +1,26 @@
-service com.robotraconteur.param
-
-stdver 0.10
-
-import com.robotraconteur.identifier
-import com.robotraconteur.datatype
-import com.robotraconteur.device
-import com.robotraconteur.units
-
-using com.robotraconteur.identifier.Identifier
-using com.robotraconteur.datatype.DataType
-using com.robotraconteur.device.DeviceClass
-using com.robotraconteur.units.SIUnit
-
-struct ParameterInfo
-    field Identifier parameter_identifier
-    field DeviceClass parameter_class
-    field DataType data_type
-    field SIUnit{list} data_units
-    field string description
-    field varvalue default_value
-    field varvalue min_value
-    field varvalue max_value
-    field varvalue{string} enum_values
-    field varvalue{string} extended
-end
+service com.robotraconteur.param
+
+stdver 0.10
+
+import com.robotraconteur.identifier
+import com.robotraconteur.datatype
+import com.robotraconteur.device
+import com.robotraconteur.units
+
+using com.robotraconteur.identifier.Identifier
+using com.robotraconteur.datatype.DataType
+using com.robotraconteur.device.DeviceClass
+using com.robotraconteur.units.SIUnit
+
+struct ParameterInfo
+    field Identifier parameter_identifier
+    field DeviceClass parameter_class
+    field DataType data_type
+    field SIUnit{list} data_units
+    field string description
+    field varvalue default_value
+    field varvalue min_value
+    field varvalue max_value
+    field varvalue{string} enum_values
+    field varvalue{string} extended
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.pid.robdef

 * *Ordering differences only*

```diff
@@ -1,13 +1,13 @@
-service com.robotraconteur.pid
-
-stdver 0.10
-
-struct PIDParam
-    field double p
-    field double i
-    field double d
-    field double imax
-    field double imin
-    field double cmd_max
-    field double cmd_min
-end
+service com.robotraconteur.pid
+
+stdver 0.10
+
+struct PIDParam
+    field double p
+    field double i
+    field double d
+    field double imax
+    field double imin
+    field double cmd_max
+    field double cmd_min
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.pointcloud.robdef

 * *Ordering differences only*

```diff
@@ -1,116 +1,116 @@
-service com.robotraconteur.pointcloud
-
-stdver 0.10
-
-import com.robotraconteur.geometry
-import com.robotraconteur.geometryf
-import com.robotraconteur.image
-
-using com.robotraconteur.geometry.Point
-using com.robotraconteur.geometry.Vector3
-using com.robotraconteur.geometry.BoundingBox
-using com.robotraconteur.geometryf.Point as Pointf
-using com.robotraconteur.geometryf.Vector3 as Vector3f
-using com.robotraconteur.geometryf.BoundingBox as BoundingBoxf
-using com.robotraconteur.image.PixelRGBFloatPacked
-using com.robotraconteur.image.PixelRGBFloatPackedf
-
-struct PointCloud
-    field BoundingBox bounds
-    field bool is_dense
-    field Point[] points
-    field varvalue{string} extended
-end
-
-struct PointCloudPart
-    field BoundingBox bounds
-    field bool is_dense
-    field uint32 points_offset
-    field uint32 points_total_len
-    field Point[] points
-    field varvalue{string} extended
-end
-
-struct PointCloudf
-    field BoundingBoxf bounds
-    field bool is_dense
-    field Pointf[] points
-    field varvalue{string} extended
-end
-
-struct PointCloudPartf
-    field BoundingBoxf bounds
-    field bool is_dense
-    field uint32 points_offset
-    field uint32 points_total_len
-    field Pointf[] points
-    field varvalue{string} extended
-end
-
-namedarray PointCloud2Point
-    field Point point
-    field double intensity
-    field Vector3 normal
-    field PixelRGBFloatPacked rgb
-    field double[3] moment_invariants
-    field double channel
-end
-
-struct PointCloud2
-    field BoundingBox bounds
-    field bool is_dense
-    field PointCloud2Point[] points
-    field varvalue{string} extended
-end
-
-struct PointCloud2Part
-    field BoundingBox bounds
-    field bool is_dense
-    field uint32 points_offset
-    field uint32 points_total_len
-    field PointCloud2Point[] points
-    field varvalue{string} extended
-end
-
-namedarray PointCloud2Pointf
-    field Pointf point
-    field single intensity
-    field Vector3f normal
-    field PixelRGBFloatPackedf rgb
-    field single[3] moment_invariants
-    field single channel
-end
-
-struct PointCloud2f
-    field BoundingBoxf bounds
-    field bool is_dense
-    field PointCloud2Pointf[] points
-    field varvalue{string} extended
-end
-
-struct PointCloud2Partf
-    field BoundingBoxf bounds
-    field bool is_dense
-    field uint32 points_offset
-    field uint32 points_total_len
-    field PointCloud2Pointf[] points
-    field varvalue{string} extended
-end
-
-struct FreeformPointCloud
-    field BoundingBox bounds
-    field string encoding
-    field bool is_dense
-    field varvalue points
-    field varvalue{string} extended
-end
-
-struct FreeformPointCloudPart
-    field BoundingBox bounds
-    field string encoding
-    field bool is_dense
-    field uint32 points_offset
-    field uint32 points_total_len
-    field varvalue points
-    field varvalue{string} extended
-end
+service com.robotraconteur.pointcloud
+
+stdver 0.10
+
+import com.robotraconteur.geometry
+import com.robotraconteur.geometryf
+import com.robotraconteur.image
+
+using com.robotraconteur.geometry.Point
+using com.robotraconteur.geometry.Vector3
+using com.robotraconteur.geometry.BoundingBox
+using com.robotraconteur.geometryf.Point as Pointf
+using com.robotraconteur.geometryf.Vector3 as Vector3f
+using com.robotraconteur.geometryf.BoundingBox as BoundingBoxf
+using com.robotraconteur.image.PixelRGBFloatPacked
+using com.robotraconteur.image.PixelRGBFloatPackedf
+
+struct PointCloud
+    field BoundingBox bounds
+    field bool is_dense
+    field Point[] points
+    field varvalue{string} extended
+end
+
+struct PointCloudPart
+    field BoundingBox bounds
+    field bool is_dense
+    field uint32 points_offset
+    field uint32 points_total_len
+    field Point[] points
+    field varvalue{string} extended
+end
+
+struct PointCloudf
+    field BoundingBoxf bounds
+    field bool is_dense
+    field Pointf[] points
+    field varvalue{string} extended
+end
+
+struct PointCloudPartf
+    field BoundingBoxf bounds
+    field bool is_dense
+    field uint32 points_offset
+    field uint32 points_total_len
+    field Pointf[] points
+    field varvalue{string} extended
+end
+
+namedarray PointCloud2Point
+    field Point point
+    field double intensity
+    field Vector3 normal
+    field PixelRGBFloatPacked rgb
+    field double[3] moment_invariants
+    field double channel
+end
+
+struct PointCloud2
+    field BoundingBox bounds
+    field bool is_dense
+    field PointCloud2Point[] points
+    field varvalue{string} extended
+end
+
+struct PointCloud2Part
+    field BoundingBox bounds
+    field bool is_dense
+    field uint32 points_offset
+    field uint32 points_total_len
+    field PointCloud2Point[] points
+    field varvalue{string} extended
+end
+
+namedarray PointCloud2Pointf
+    field Pointf point
+    field single intensity
+    field Vector3f normal
+    field PixelRGBFloatPackedf rgb
+    field single[3] moment_invariants
+    field single channel
+end
+
+struct PointCloud2f
+    field BoundingBoxf bounds
+    field bool is_dense
+    field PointCloud2Pointf[] points
+    field varvalue{string} extended
+end
+
+struct PointCloud2Partf
+    field BoundingBoxf bounds
+    field bool is_dense
+    field uint32 points_offset
+    field uint32 points_total_len
+    field PointCloud2Pointf[] points
+    field varvalue{string} extended
+end
+
+struct FreeformPointCloud
+    field BoundingBox bounds
+    field string encoding
+    field bool is_dense
+    field varvalue points
+    field varvalue{string} extended
+end
+
+struct FreeformPointCloudPart
+    field BoundingBox bounds
+    field string encoding
+    field bool is_dense
+    field uint32 points_offset
+    field uint32 points_total_len
+    field varvalue points
+    field varvalue{string} extended
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.pointcloud.sensor.robdef

 * *Ordering differences only*

```diff
@@ -1,122 +1,122 @@
-service com.robotraconteur.pointcloud.sensor
-
-stdver 0.10
-
-import com.robotraconteur.device
-import com.robotraconteur.param
-import com.robotraconteur.pointcloud
-import com.robotraconteur.geometry
-import com.robotraconteur.sensor
-import com.robotraconteur.device.isoch
-import com.robotraconteur.device.clock
-
-using com.robotraconteur.device.DeviceInfo
-using com.robotraconteur.device.Device
-using com.robotraconteur.param.ParameterInfo
-using com.robotraconteur.pointcloud.PointCloudf as PointCloud
-using com.robotraconteur.pointcloud.PointCloudPartf as PointCloudPart
-using com.robotraconteur.pointcloud.PointCloud2f as PointCloud2
-using com.robotraconteur.pointcloud.PointCloud2Partf as PointCloud2Part
-using com.robotraconteur.geometry.Point
-using com.robotraconteur.geometry.Vector3
-using com.robotraconteur.geometry.BoundingBox
-using com.robotraconteur.sensor.SensorData
-using com.robotraconteur.device.isoch.IsochDevice
-using com.robotraconteur.device.isoch.IsochInfo
-using com.robotraconteur.device.clock.DeviceClock
-using com.robotraconteur.device.clock.DeviceTime
-
-struct PointCloudSensorInfo
-    field DeviceInfo device_info
-    field BoundingBox bounds
-    field Vector3 resolution
-    field ParameterInfo{list} param_info
-    field varvalue{string} extended
-end
-
-struct PointCloudSensorData
-    field SensorData sensor_data
-    field PointCloud point_cloud
-end
-
-struct PointCloudPartSensorData
-    field SensorData sensor_data
-    field PointCloudPart point_cloud
-end
-
-object PointCloudSensor
-    implements Device
-    implements DeviceClock
-    implements IsochDevice
-    property DeviceInfo device_info [readonly,nolock]
-    property PointCloudSensorInfo point_sensor_info [readonly,nolock]
-    function PointCloud capture_point_cloud()
-    pipe PointCloudSensorData point_cloud_sensor_data [readonly]
-    function varvalue getf_param(string param_name)
-    function void setf_param(string param_name, varvalue value)
-    property IsochInfo isoch_info [readonly,nolock]
-    property uint32 isoch_downsample [perclient]
-    wire DeviceTime device_clock_now [readonly,nolock]
-end
-
-object PointCloudPartSensor
-    implements Device
-    implements DeviceClock
-    implements IsochDevice
-    property DeviceInfo device_info [readonly,nolock]
-    property PointCloudSensorInfo point_sensor_info [readonly,nolock]
-    function PointCloudPart{generator} capture_point_cloud()
-    pipe PointCloudPartSensorData point_cloud_sensor_data [readonly]
-    function varvalue getf_param(string param_name)
-    function void setf_param(string param_name, varvalue value)
-    property IsochInfo isoch_info [readonly,nolock]
-    property uint32 isoch_downsample [perclient]
-    wire DeviceTime device_clock_now [readonly,nolock]
-end
-
-
-struct PointCloud2SensorData
-    field SensorData sensor_data
-    field PointCloud2 point_cloud
-end
-
-struct PointCloud2PartSensorData
-    field SensorData sensor_data
-    field PointCloud2Part point_cloud
-end
-
-object PointCloud2Sensor
-    implements PointCloudSensor
-    implements Device
-    implements DeviceClock
-    implements IsochDevice
-    property DeviceInfo device_info [readonly,nolock]
-    property PointCloudSensorInfo point_sensor_info [readonly,nolock]
-    function PointCloud capture_point_cloud()
-    function PointCloud2 capture_point_cloud2()
-    pipe PointCloudSensorData point_cloud_sensor_data [readonly]
-    pipe PointCloud2SensorData point_cloud2_sensor_data [readonly]
-    function varvalue getf_param(string param_name)
-    function void setf_param(string param_name, varvalue value)
-    property IsochInfo isoch_info [readonly,nolock]
-    property uint32 isoch_downsample [perclient]
-    wire DeviceTime device_clock_now [readonly,nolock]
-end
-
-object PointCloud2PartSensor
-    implements PointCloudPartSensor
-    implements Device
-    implements DeviceClock
-    implements IsochDevice
-    property DeviceInfo device_info [readonly,nolock]
-    property PointCloudSensorInfo point_sensor_info [readonly,nolock]
-    function PointCloudPart{generator} capture_point_cloud()
-    function PointCloud2Part{generator} capture_point_cloud2()
-    pipe PointCloudPartSensorData point_cloud_sensor_data [readonly]
-    pipe PointCloud2PartSensorData point_cloud2_sensor_data [readonly]
-    function varvalue getf_param(string param_name)
-    function void setf_param(string param_name, varvalue value)
-    property IsochInfo isoch_info [readonly,nolock]
-    property uint32 isoch_downsample [perclient]
-    wire DeviceTime device_clock_now [readonly,nolock]
-end
+service com.robotraconteur.pointcloud.sensor
+
+stdver 0.10
+
+import com.robotraconteur.device
+import com.robotraconteur.param
+import com.robotraconteur.pointcloud
+import com.robotraconteur.geometry
+import com.robotraconteur.sensor
+import com.robotraconteur.device.isoch
+import com.robotraconteur.device.clock
+
+using com.robotraconteur.device.DeviceInfo
+using com.robotraconteur.device.Device
+using com.robotraconteur.param.ParameterInfo
+using com.robotraconteur.pointcloud.PointCloudf as PointCloud
+using com.robotraconteur.pointcloud.PointCloudPartf as PointCloudPart
+using com.robotraconteur.pointcloud.PointCloud2f as PointCloud2
+using com.robotraconteur.pointcloud.PointCloud2Partf as PointCloud2Part
+using com.robotraconteur.geometry.Point
+using com.robotraconteur.geometry.Vector3
+using com.robotraconteur.geometry.BoundingBox
+using com.robotraconteur.sensor.SensorData
+using com.robotraconteur.device.isoch.IsochDevice
+using com.robotraconteur.device.isoch.IsochInfo
+using com.robotraconteur.device.clock.DeviceClock
+using com.robotraconteur.device.clock.DeviceTime
+
+struct PointCloudSensorInfo
+    field DeviceInfo device_info
+    field BoundingBox bounds
+    field Vector3 resolution
+    field ParameterInfo{list} param_info
+    field varvalue{string} extended
+end
+
+struct PointCloudSensorData
+    field SensorData sensor_data
+    field PointCloud point_cloud
+end
+
+struct PointCloudPartSensorData
+    field SensorData sensor_data
+    field PointCloudPart point_cloud
+end
+
+object PointCloudSensor
+    implements Device
+    implements DeviceClock
+    implements IsochDevice
+    property DeviceInfo device_info [readonly,nolock]
+    property PointCloudSensorInfo point_sensor_info [readonly,nolock]
+    function PointCloud capture_point_cloud()
+    pipe PointCloudSensorData point_cloud_sensor_data [readonly]
+    function varvalue getf_param(string param_name)
+    function void setf_param(string param_name, varvalue value)
+    property IsochInfo isoch_info [readonly,nolock]
+    property uint32 isoch_downsample [perclient]
+    wire DeviceTime device_clock_now [readonly,nolock]
+end
+
+object PointCloudPartSensor
+    implements Device
+    implements DeviceClock
+    implements IsochDevice
+    property DeviceInfo device_info [readonly,nolock]
+    property PointCloudSensorInfo point_sensor_info [readonly,nolock]
+    function PointCloudPart{generator} capture_point_cloud()
+    pipe PointCloudPartSensorData point_cloud_sensor_data [readonly]
+    function varvalue getf_param(string param_name)
+    function void setf_param(string param_name, varvalue value)
+    property IsochInfo isoch_info [readonly,nolock]
+    property uint32 isoch_downsample [perclient]
+    wire DeviceTime device_clock_now [readonly,nolock]
+end
+
+
+struct PointCloud2SensorData
+    field SensorData sensor_data
+    field PointCloud2 point_cloud
+end
+
+struct PointCloud2PartSensorData
+    field SensorData sensor_data
+    field PointCloud2Part point_cloud
+end
+
+object PointCloud2Sensor
+    implements PointCloudSensor
+    implements Device
+    implements DeviceClock
+    implements IsochDevice
+    property DeviceInfo device_info [readonly,nolock]
+    property PointCloudSensorInfo point_sensor_info [readonly,nolock]
+    function PointCloud capture_point_cloud()
+    function PointCloud2 capture_point_cloud2()
+    pipe PointCloudSensorData point_cloud_sensor_data [readonly]
+    pipe PointCloud2SensorData point_cloud2_sensor_data [readonly]
+    function varvalue getf_param(string param_name)
+    function void setf_param(string param_name, varvalue value)
+    property IsochInfo isoch_info [readonly,nolock]
+    property uint32 isoch_downsample [perclient]
+    wire DeviceTime device_clock_now [readonly,nolock]
+end
+
+object PointCloud2PartSensor
+    implements PointCloudPartSensor
+    implements Device
+    implements DeviceClock
+    implements IsochDevice
+    property DeviceInfo device_info [readonly,nolock]
+    property PointCloudSensorInfo point_sensor_info [readonly,nolock]
+    function PointCloudPart{generator} capture_point_cloud()
+    function PointCloud2Part{generator} capture_point_cloud2()
+    pipe PointCloudPartSensorData point_cloud_sensor_data [readonly]
+    pipe PointCloud2PartSensorData point_cloud2_sensor_data [readonly]
+    function varvalue getf_param(string param_name)
+    function void setf_param(string param_name, varvalue value)
+    property IsochInfo isoch_info [readonly,nolock]
+    property uint32 isoch_downsample [perclient]
+    wire DeviceTime device_clock_now [readonly,nolock]
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.resource.device.robdef

 * *Ordering differences only*

```diff
@@ -1,33 +1,33 @@
-service com.robotraconteur.resource.device
-
-stdver 0.10
-
-import com.robotraconteur.device
-import com.robotraconteur.resource
-import com.robotraconteur.identifier
-
-using com.robotraconteur.identifier.Identifier
-using com.robotraconteur.device.Device
-using com.robotraconteur.device.DeviceInfo
-using com.robotraconteur.resource.BucketInfo
-using com.robotraconteur.resource.ResourceIdentifier
-using com.robotraconteur.resource.ResourcePart
-using com.robotraconteur.resource.ResourceInfo
-using com.robotraconteur.resource.ResourceReadOnlyStorage
-using com.robotraconteur.resource.ResourceStorage
-
-object ResourceStorageDevice
-    implements Device
-    implements ResourceReadOnlyStorage
-    implements ResourceStorage
-    property DeviceInfo device_info [readonly,nolock]
-    property BucketInfo{list} resource_bucket_info [readonly,nolock]
-    function ResourceInfo resource_get_info(ResourceIdentifier identifier)
-    function ResourcePart{generator} resource_get(ResourceIdentifier identifier)
-    function ResourcePart{generator} resource_get_all(Identifier bucket_identifier)
-    function void resource_bucket_add(Identifier bucket_identifier)
-    function void resource_bucket_delete(Identifier bucket_identifier)
-    function void resource_set(ResourceIdentifier identifier, bool overwrite, ResourcePart{generator} resource)
-    function void resource_delete(ResourceIdentifier identifier)
-    function void resource_copy(ResourceIdentifier identifier, ResourceIdentifier new_identifier, bool copy)
-end
+service com.robotraconteur.resource.device
+
+stdver 0.10
+
+import com.robotraconteur.device
+import com.robotraconteur.resource
+import com.robotraconteur.identifier
+
+using com.robotraconteur.identifier.Identifier
+using com.robotraconteur.device.Device
+using com.robotraconteur.device.DeviceInfo
+using com.robotraconteur.resource.BucketInfo
+using com.robotraconteur.resource.ResourceIdentifier
+using com.robotraconteur.resource.ResourcePart
+using com.robotraconteur.resource.ResourceInfo
+using com.robotraconteur.resource.ResourceReadOnlyStorage
+using com.robotraconteur.resource.ResourceStorage
+
+object ResourceStorageDevice
+    implements Device
+    implements ResourceReadOnlyStorage
+    implements ResourceStorage
+    property DeviceInfo device_info [readonly,nolock]
+    property BucketInfo{list} resource_bucket_info [readonly,nolock]
+    function ResourceInfo resource_get_info(ResourceIdentifier identifier)
+    function ResourcePart{generator} resource_get(ResourceIdentifier identifier)
+    function ResourcePart{generator} resource_get_all(Identifier bucket_identifier)
+    function void resource_bucket_add(Identifier bucket_identifier)
+    function void resource_bucket_delete(Identifier bucket_identifier)
+    function void resource_set(ResourceIdentifier identifier, bool overwrite, ResourcePart{generator} resource)
+    function void resource_delete(ResourceIdentifier identifier)
+    function void resource_copy(ResourceIdentifier identifier, ResourceIdentifier new_identifier, bool copy)
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.resource.robdef

 * *Ordering differences only*

```diff
@@ -1,64 +1,64 @@
-service com.robotraconteur.resource
-
-stdver 0.10
-
-import com.robotraconteur.uuid
-import com.robotraconteur.datetime
-import com.robotraconteur.identifier
-
-using com.robotraconteur.uuid.UUID
-using com.robotraconteur.datetime.DateTimeUTC
-using com.robotraconteur.identifier.Identifier
-
-struct ResourceIdentifier
-    field Identifier bucket
-    field string key
-end
-
-struct BucketInfo
-    field Identifier identifier
-    field string{list} keys
-    field string description
-    field varvalue{string} extended
-end
-
-struct ResourceInfo
-    field ResourceIdentifier identifier
-    field string key
-    field DateTimeUTC created
-    field DateTimeUTC modified
-    field uint64 total_size
-    field string description
-    field varvalue{string} extended
-end
-
-struct Resource
-    field ResourceInfo info
-    field uint8[] data
-end
-
-struct ResourcePart
-    field ResourceInfo info
-    field uint64 data_offset
-    field uint8[] data
-end
-
-object ResourceReadOnlyStorage
-    property BucketInfo{list} resource_bucket_info [readonly,nolock]
-    function ResourceInfo resource_get_info(ResourceIdentifier identifier)
-    function ResourcePart{generator} resource_get(ResourceIdentifier identifier)
-    function ResourcePart{generator} resource_get_all(Identifier bucket_identifier)
-end
-
-object ResourceStorage
-    implements ResourceReadOnlyStorage
-    property BucketInfo{list} resource_bucket_info [readonly,nolock]
-    function ResourceInfo resource_get_info(ResourceIdentifier identifier)
-    function ResourcePart{generator} resource_get(ResourceIdentifier identifier)
-    function ResourcePart{generator} resource_get_all(Identifier bucket_identifier)
-    function void resource_bucket_add(Identifier bucket_identifier)
-    function void resource_bucket_delete(Identifier bucket_identifier)
-    function void resource_set(ResourceIdentifier identifier, bool overwrite, ResourcePart{generator} resource)
-    function void resource_delete(ResourceIdentifier identifier)
-    function void resource_copy(ResourceIdentifier identifier, ResourceIdentifier new_identifier, bool copy)
-end
+service com.robotraconteur.resource
+
+stdver 0.10
+
+import com.robotraconteur.uuid
+import com.robotraconteur.datetime
+import com.robotraconteur.identifier
+
+using com.robotraconteur.uuid.UUID
+using com.robotraconteur.datetime.DateTimeUTC
+using com.robotraconteur.identifier.Identifier
+
+struct ResourceIdentifier
+    field Identifier bucket
+    field string key
+end
+
+struct BucketInfo
+    field Identifier identifier
+    field string{list} keys
+    field string description
+    field varvalue{string} extended
+end
+
+struct ResourceInfo
+    field ResourceIdentifier identifier
+    field string key
+    field DateTimeUTC created
+    field DateTimeUTC modified
+    field uint64 total_size
+    field string description
+    field varvalue{string} extended
+end
+
+struct Resource
+    field ResourceInfo info
+    field uint8[] data
+end
+
+struct ResourcePart
+    field ResourceInfo info
+    field uint64 data_offset
+    field uint8[] data
+end
+
+object ResourceReadOnlyStorage
+    property BucketInfo{list} resource_bucket_info [readonly,nolock]
+    function ResourceInfo resource_get_info(ResourceIdentifier identifier)
+    function ResourcePart{generator} resource_get(ResourceIdentifier identifier)
+    function ResourcePart{generator} resource_get_all(Identifier bucket_identifier)
+end
+
+object ResourceStorage
+    implements ResourceReadOnlyStorage
+    property BucketInfo{list} resource_bucket_info [readonly,nolock]
+    function ResourceInfo resource_get_info(ResourceIdentifier identifier)
+    function ResourcePart{generator} resource_get(ResourceIdentifier identifier)
+    function ResourcePart{generator} resource_get_all(Identifier bucket_identifier)
+    function void resource_bucket_add(Identifier bucket_identifier)
+    function void resource_bucket_delete(Identifier bucket_identifier)
+    function void resource_set(ResourceIdentifier identifier, bool overwrite, ResourcePart{generator} resource)
+    function void resource_delete(ResourceIdentifier identifier)
+    function void resource_copy(ResourceIdentifier identifier, ResourceIdentifier new_identifier, bool copy)
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.robotics.joints.robdef

 * *Ordering differences only*

```diff
@@ -1,115 +1,115 @@
-service com.robotraconteur.robotics.joints
-
-stdver 0.10
-
-import com.robotraconteur.units
-import com.robotraconteur.identifier
-
-using com.robotraconteur.units.SIUnit
-using com.robotraconteur.identifier.Identifier
-
-enum JointPositionUnits
-    implicit = 0,
-    meter,
-    radian,
-    degree,
-    # ticks_lin = m/(2^20)
-    ticks_lin,
-    # ticks_rot = rev/(2^20)
-    ticks_rot,
-    # nanoticks_lin = nm/(2^20)
-    nanoticks_lin,
-    # nanoticks_rot = nrev/(2^20)
-    nanoticks_rot
-end
-
-enum JointVelocityUnits
-    implicit = 0,
-    meter_second = 16,
-    radian_second,
-    degree_second,
-    ticks_lin_second,
-    ticks_rot_second,
-    nanoticks_lin_second,
-    nanoticks_rot_second
-end
-
-enum JointAccelerationUnits
-    implicit = 0,
-    meter_second2 = 32,
-    radian_second2,
-    degree_second2,
-    ticks_lin_second2,
-    ticks_rot_second2,
-    nanoticks_lin_second2,
-    nanoticks_rot_second2
-end
-
-enum JointJerkUnits
-    implicit = 0,
-    meter_second2 = 48,
-    radian_second3,
-    degree_second3,
-    ticks_lin_second3,
-    ticks_rot_second3,
-    nanoticks_lin_second3,
-    nanoticks_rot_second3
-end
-
-enum JointEffortUnits
-    implicit = 0,
-    newton = 64,
-    newton_meter,
-    ampere,
-    volt,
-    pascal,
-    coulomb,
-    tesla,
-    weber,
-    meter_second2,
-    radian_second2,
-    degree_second2
-end
-
-enum JointType
-    unknown = 0,
-    revolute,
-    continuous,
-    prismatic,
-    wheel,
-    screw,
-    other,
-    # Compound joint types
-    revolute2,
-    universal,
-    ball,
-    planar,
-    floating,
-    other_compound,
-    # Fixed used in scenes
-    fixed
-end
-
-struct JointLimits
-    field double lower
-    field double upper
-    field double home
-    field double velocity
-    field double acceleration
-    field double jerk
-    field double effort
-    field double reduced_velocity
-    field double reduced_acceleration
-    field double reduced_jerk
-    field double reduced_effort
-end
-
-struct JointInfo
-    field Identifier joint_identifier
-    field JointType joint_type
-    field JointLimits joint_limits
-    field JointPositionUnits default_units
-    field JointEffortUnits default_effort_units
-    field bool passive
-    field varvalue{string} extended
-end
+service com.robotraconteur.robotics.joints
+
+stdver 0.10
+
+import com.robotraconteur.units
+import com.robotraconteur.identifier
+
+using com.robotraconteur.units.SIUnit
+using com.robotraconteur.identifier.Identifier
+
+enum JointPositionUnits
+    implicit = 0,
+    meter,
+    radian,
+    degree,
+    # ticks_lin = m/(2^20)
+    ticks_lin,
+    # ticks_rot = rev/(2^20)
+    ticks_rot,
+    # nanoticks_lin = nm/(2^20)
+    nanoticks_lin,
+    # nanoticks_rot = nrev/(2^20)
+    nanoticks_rot
+end
+
+enum JointVelocityUnits
+    implicit = 0,
+    meter_second = 16,
+    radian_second,
+    degree_second,
+    ticks_lin_second,
+    ticks_rot_second,
+    nanoticks_lin_second,
+    nanoticks_rot_second
+end
+
+enum JointAccelerationUnits
+    implicit = 0,
+    meter_second2 = 32,
+    radian_second2,
+    degree_second2,
+    ticks_lin_second2,
+    ticks_rot_second2,
+    nanoticks_lin_second2,
+    nanoticks_rot_second2
+end
+
+enum JointJerkUnits
+    implicit = 0,
+    meter_second2 = 48,
+    radian_second3,
+    degree_second3,
+    ticks_lin_second3,
+    ticks_rot_second3,
+    nanoticks_lin_second3,
+    nanoticks_rot_second3
+end
+
+enum JointEffortUnits
+    implicit = 0,
+    newton = 64,
+    newton_meter,
+    ampere,
+    volt,
+    pascal,
+    coulomb,
+    tesla,
+    weber,
+    meter_second2,
+    radian_second2,
+    degree_second2
+end
+
+enum JointType
+    unknown = 0,
+    revolute,
+    continuous,
+    prismatic,
+    wheel,
+    screw,
+    other,
+    # Compound joint types
+    revolute2,
+    universal,
+    ball,
+    planar,
+    floating,
+    other_compound,
+    # Fixed used in scenes
+    fixed
+end
+
+struct JointLimits
+    field double lower
+    field double upper
+    field double home
+    field double velocity
+    field double acceleration
+    field double jerk
+    field double effort
+    field double reduced_velocity
+    field double reduced_acceleration
+    field double reduced_jerk
+    field double reduced_effort
+end
+
+struct JointInfo
+    field Identifier joint_identifier
+    field JointType joint_type
+    field JointLimits joint_limits
+    field JointPositionUnits default_units
+    field JointEffortUnits default_effort_units
+    field bool passive
+    field varvalue{string} extended
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.robotics.payload.robdef

 * *Ordering differences only*

```diff
@@ -1,19 +1,19 @@
-service com.robotraconteur.robotics.payload
-
-stdver 0.10
-
-import com.robotraconteur.device
-import com.robotraconteur.geometry
-import com.robotraconteur.fiducial
-
-using com.robotraconteur.device.DeviceInfo
-using com.robotraconteur.geometry.Transform
-using com.robotraconteur.geometry.SpatialInertia
-using com.robotraconteur.fiducial.Fiducial
-
-struct PayloadInfo
-    field DeviceInfo device_info
-    field SpatialInertia inertia
-    field Fiducial{list} fiducials
-    field varvalue{string} extended
-end
+service com.robotraconteur.robotics.payload
+
+stdver 0.10
+
+import com.robotraconteur.device
+import com.robotraconteur.geometry
+import com.robotraconteur.fiducial
+
+using com.robotraconteur.device.DeviceInfo
+using com.robotraconteur.geometry.Transform
+using com.robotraconteur.geometry.SpatialInertia
+using com.robotraconteur.fiducial.Fiducial
+
+struct PayloadInfo
+    field DeviceInfo device_info
+    field SpatialInertia inertia
+    field Fiducial{list} fiducials
+    field varvalue{string} extended
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.robotics.robot.robdef

 * *Ordering differences only*

```diff
@@ -1,259 +1,259 @@
-service com.robotraconteur.robotics.robot
-
-stdver 0.10
-
-import com.robotraconteur.geometry
-import com.robotraconteur.sensordata
-import com.robotraconteur.device
-import com.robotraconteur.signal
-import com.robotraconteur.param
-import com.robotraconteur.robotics.joints
-import com.robotraconteur.robotics.tool
-import com.robotraconteur.robotics.payload
-import com.robotraconteur.robotics.trajectory
-import com.robotraconteur.identifier
-import com.robotraconteur.action
-import com.robotraconteur.eventlog
-import com.robotraconteur.device.isoch
-import com.robotraconteur.device.clock
-import com.robotraconteur.datetime
-import com.robotraconteur.fiducial
-
-using com.robotraconteur.geometry.Point
-using com.robotraconteur.geometry.Vector3
-using com.robotraconteur.geometry.Transform
-using com.robotraconteur.geometry.SpatialInertia
-using com.robotraconteur.geometry.Pose
-using com.robotraconteur.geometry.SpatialVelocity
-using com.robotraconteur.geometry.SpatialAcceleration
-using com.robotraconteur.sensordata.SensorDataHeader
-using com.robotraconteur.device.DeviceInfo
-using com.robotraconteur.device.Device
-using com.robotraconteur.signal.SignalInfo
-using com.robotraconteur.robotics.joints.JointInfo
-using com.robotraconteur.robotics.tool.ToolInfo
-using com.robotraconteur.robotics.payload.PayloadInfo
-using com.robotraconteur.param.ParameterInfo
-using com.robotraconteur.robotics.trajectory.TrajectoryStatus
-using com.robotraconteur.robotics.trajectory.JointTrajectory
-using com.robotraconteur.robotics.trajectory.InterpolationMode
-using com.robotraconteur.identifier.Identifier
-using com.robotraconteur.action.ActionStatusCode
-using com.robotraconteur.eventlog.EventLogMessage
-using com.robotraconteur.device.isoch.IsochDevice
-using com.robotraconteur.device.isoch.IsochInfo
-using com.robotraconteur.device.clock.DeviceClock
-using com.robotraconteur.device.clock.DeviceTime
-using com.robotraconteur.datetime.TimeSpec3
-using com.robotraconteur.fiducial.Fiducial
-
-
-enum RobotTypeCode
-    unknown = 0,
-    serial = 1,
-    dual_arm,
-    differential_drive,
-    planar,
-    floating,
-    freeform,
-    other
-end
-
-enum RobotCommandMode
-    invalid_state = -1,
-    halt = 0,
-    jog,
-    trajectory,
-    position_command,
-    velocity_command,
-    homing
-end
-
-enum RobotOperationalMode
-    undefined = 0,
-    manual_reduced_speed,
-    manual_full_speed,
-    auto,
-    cobot
-end
-
-enum RobotControllerState
-    undefined = 0,
-    init = 1,
-    motor_on,
-    motor_off,
-    guard_stop,
-    emergency_stop,
-    emergency_stop_reset
-end
-
-enum RobotCapabilities
-    unknown = 0,
-    jog_command = 0x1,
-    trajectory_command = 0x2,
-    position_command = 0x4,
-    velocity_command = 0x8,
-    homing_command = 0x10,
-    software_reset_errors = 0x20,
-    software_enable = 0x40,
-    interpolated_trajectory = 0x80,
-    raster_trajectory = 0x100,
-    trajectory_queueing = 0x200,
-    speed_ratio = 0x400
-end
-
-enum RobotStateFlags
-    unknown = 0,
-    error = 0x1,
-    fatal_error = 0x2,
-    estop = 0x4,
-    estop_button1 = 0x8,
-    estop_button2 = 0x10,
-    estop_button3 = 0x20,
-    estop_button4 = 0x40,
-    estop_guard1 = 0x80,
-    estop_guard2 = 0x100,
-    estop_guard3 = 0x200,
-    estop_guard4 = 0x400,
-    estop_software = 0x800,
-    estop_fault = 0x1000,
-    estop_internal = 0x2000,
-    estop_other = 0x4000,
-    estop_released = 0x8000,
-    enabling_switch = 0x10000,
-    enabled = 0x20000,
-    ready = 0x40000,
-    homed = 0x80000,
-    homing_required = 0x100000,
-    communication_failure = 0x200000,
-    valid_position_command = 0x1000000,
-    valid_velocity_command = 0x2000000,
-    trajectory_running = 0x4000000
-end
-
-struct RobotKinChainInfo
-    field Identifier kin_chain_identifier
-    field Vector3[] H
-    field Vector3[] P
-    field SpatialInertia[] link_inertias
-    field Identifier{list} link_identifiers
-    field Fiducial{list} link_fiducials
-    field uint32[] joint_numbers
-    field Pose flange_pose
-    field Identifier flange_identifier
-    field ToolInfo current_tool
-    field PayloadInfo current_payload
-    field SpatialVelocity tcp_max_velocity
-    field SpatialAcceleration tcp_max_acceleration
-    field SpatialVelocity tcp_reduced_max_velocity
-    field SpatialAcceleration tcp_reduced_max_acceleration
-    field string description
-    field varvalue{string} extended
-end
-
-struct RobotInfo
-    field DeviceInfo device_info
-    field RobotTypeCode robot_type
-    field JointInfo{list} joint_info
-    field RobotKinChainInfo{list} chains
-    field uint32 robot_capabilities
-    field SignalInfo{list} signal_info
-    field ParameterInfo{list} parameter_info
-    field uint16 config_seqno
-    field InterpolationMode{list} trajectory_interpolation_modes
-    field varvalue{string} extended
-end
-
-struct RobotState
-    field TimeSpec3 ts
-    field uint64 seqno
-    field RobotCommandMode command_mode
-    field RobotOperationalMode operational_mode
-    field RobotControllerState controller_state
-    field uint64 robot_state_flags
-    field double[] joint_position
-    field double[] joint_velocity
-    field double[] joint_effort
-    field double[] joint_position_command
-    field double[] joint_velocity_command
-    field Pose[] kin_chain_tcp
-    field SpatialVelocity[] kin_chain_tcp_vel
-    field bool trajectory_running
-end
-
-struct AdvancedRobotState
-    field TimeSpec3 ts
-    field uint64 seqno
-    field RobotCommandMode command_mode
-    field RobotOperationalMode operational_mode
-    field RobotControllerState controller_state
-    field uint64 robot_state_flags
-    field double[] joint_position
-    field double[] joint_velocity
-    field double[] joint_effort
-    field double[] joint_position_command
-    field double[] joint_velocity_command
-    field uint8[] joint_position_units
-    field uint8[] joint_effort_units
-    field Pose[] kin_chain_tcp
-    field SpatialVelocity[] kin_chain_tcp_vel
-    field bool trajectory_running
-    field double trajectory_time
-    field double trajectory_max_time
-    field uint32 trajectory_current_waypoint
-    field uint16 config_seqno
-end
-
-struct RobotStateSensorData
-    field SensorDataHeader data_header
-    field AdvancedRobotState robot_state
-end
-
-struct RobotJointCommand
-    field uint64 seqno
-    field uint64 state_seqno
-    field double[] command
-    # Use JointUnits values
-    field uint8[] units
-end
-
-object Robot
-    implements Device
-    implements DeviceClock
-    implements IsochDevice
-    property DeviceInfo device_info [readonly,nolock]
-    property RobotInfo robot_info [readonly,nolock]
-    property RobotCommandMode command_mode [nolockread]
-    property RobotOperationalMode operational_mode [readonly, nolock]
-    property RobotControllerState controller_state [readonly, nolock]
-    property EventLogMessage{list} current_errors [readonly, nolock]
-    function void halt() [urgent]
-    function void enable()
-    function void disable() [urgent]
-    function void reset_errors()
-    property double speed_ratio
-    function void jog_freespace(double[] joint_position, double[] max_velocity, bool wait)
-    function void jog_joint(double[] joint_velocity, double timeout, bool wait)
-    function void jog_cartesian(SpatialVelocity{int32} max_velocity, double timeout, bool wait)
-    function TrajectoryStatus{generator} execute_trajectory(JointTrajectory trajectory)
-    wire RobotState robot_state [readonly,nolock]
-    wire AdvancedRobotState advanced_robot_state [readonly,nolock]
-    pipe RobotStateSensorData robot_state_sensor_data [readonly,nolock]
-    property IsochInfo isoch_info [readonly,nolock]
-    property uint32 isoch_downsample [perclient]
-    wire DeviceTime device_clock_now [readonly,nolock]
-    wire RobotJointCommand position_command [writeonly]
-    wire RobotJointCommand velocity_command [writeonly]
-    function ActionStatusCode{generator} home()
-    function double[] getf_signal(string signal_name)
-    function void setf_signal(string signal_name, double[] value)
-    function void tool_attached(int32 chain, ToolInfo tool)
-    function void tool_detached(int32 chain, string tool_name)
-    event tool_changed(int32 chain, string tool_name)
-    function void payload_attached(int32 chain, PayloadInfo payload, Pose pose)
-    function void payload_detached(int32 chain, string payload_name)
-    event payload_changed(int32 chain, string payload_name)
-    function varvalue getf_param(string param_name)
-    function void setf_param(string param_name, varvalue value)
-    event param_changed(string param_name)
-end
+service com.robotraconteur.robotics.robot
+
+stdver 0.10
+
+import com.robotraconteur.geometry
+import com.robotraconteur.sensordata
+import com.robotraconteur.device
+import com.robotraconteur.signal
+import com.robotraconteur.param
+import com.robotraconteur.robotics.joints
+import com.robotraconteur.robotics.tool
+import com.robotraconteur.robotics.payload
+import com.robotraconteur.robotics.trajectory
+import com.robotraconteur.identifier
+import com.robotraconteur.action
+import com.robotraconteur.eventlog
+import com.robotraconteur.device.isoch
+import com.robotraconteur.device.clock
+import com.robotraconteur.datetime
+import com.robotraconteur.fiducial
+
+using com.robotraconteur.geometry.Point
+using com.robotraconteur.geometry.Vector3
+using com.robotraconteur.geometry.Transform
+using com.robotraconteur.geometry.SpatialInertia
+using com.robotraconteur.geometry.Pose
+using com.robotraconteur.geometry.SpatialVelocity
+using com.robotraconteur.geometry.SpatialAcceleration
+using com.robotraconteur.sensordata.SensorDataHeader
+using com.robotraconteur.device.DeviceInfo
+using com.robotraconteur.device.Device
+using com.robotraconteur.signal.SignalInfo
+using com.robotraconteur.robotics.joints.JointInfo
+using com.robotraconteur.robotics.tool.ToolInfo
+using com.robotraconteur.robotics.payload.PayloadInfo
+using com.robotraconteur.param.ParameterInfo
+using com.robotraconteur.robotics.trajectory.TrajectoryStatus
+using com.robotraconteur.robotics.trajectory.JointTrajectory
+using com.robotraconteur.robotics.trajectory.InterpolationMode
+using com.robotraconteur.identifier.Identifier
+using com.robotraconteur.action.ActionStatusCode
+using com.robotraconteur.eventlog.EventLogMessage
+using com.robotraconteur.device.isoch.IsochDevice
+using com.robotraconteur.device.isoch.IsochInfo
+using com.robotraconteur.device.clock.DeviceClock
+using com.robotraconteur.device.clock.DeviceTime
+using com.robotraconteur.datetime.TimeSpec3
+using com.robotraconteur.fiducial.Fiducial
+
+
+enum RobotTypeCode
+    unknown = 0,
+    serial = 1,
+    dual_arm,
+    differential_drive,
+    planar,
+    floating,
+    freeform,
+    other
+end
+
+enum RobotCommandMode
+    invalid_state = -1,
+    halt = 0,
+    jog,
+    trajectory,
+    position_command,
+    velocity_command,
+    homing
+end
+
+enum RobotOperationalMode
+    undefined = 0,
+    manual_reduced_speed,
+    manual_full_speed,
+    auto,
+    cobot
+end
+
+enum RobotControllerState
+    undefined = 0,
+    init = 1,
+    motor_on,
+    motor_off,
+    guard_stop,
+    emergency_stop,
+    emergency_stop_reset
+end
+
+enum RobotCapabilities
+    unknown = 0,
+    jog_command = 0x1,
+    trajectory_command = 0x2,
+    position_command = 0x4,
+    velocity_command = 0x8,
+    homing_command = 0x10,
+    software_reset_errors = 0x20,
+    software_enable = 0x40,
+    interpolated_trajectory = 0x80,
+    raster_trajectory = 0x100,
+    trajectory_queueing = 0x200,
+    speed_ratio = 0x400
+end
+
+enum RobotStateFlags
+    unknown = 0,
+    error = 0x1,
+    fatal_error = 0x2,
+    estop = 0x4,
+    estop_button1 = 0x8,
+    estop_button2 = 0x10,
+    estop_button3 = 0x20,
+    estop_button4 = 0x40,
+    estop_guard1 = 0x80,
+    estop_guard2 = 0x100,
+    estop_guard3 = 0x200,
+    estop_guard4 = 0x400,
+    estop_software = 0x800,
+    estop_fault = 0x1000,
+    estop_internal = 0x2000,
+    estop_other = 0x4000,
+    estop_released = 0x8000,
+    enabling_switch = 0x10000,
+    enabled = 0x20000,
+    ready = 0x40000,
+    homed = 0x80000,
+    homing_required = 0x100000,
+    communication_failure = 0x200000,
+    valid_position_command = 0x1000000,
+    valid_velocity_command = 0x2000000,
+    trajectory_running = 0x4000000
+end
+
+struct RobotKinChainInfo
+    field Identifier kin_chain_identifier
+    field Vector3[] H
+    field Vector3[] P
+    field SpatialInertia[] link_inertias
+    field Identifier{list} link_identifiers
+    field Fiducial{list} link_fiducials
+    field uint32[] joint_numbers
+    field Pose flange_pose
+    field Identifier flange_identifier
+    field ToolInfo current_tool
+    field PayloadInfo current_payload
+    field SpatialVelocity tcp_max_velocity
+    field SpatialAcceleration tcp_max_acceleration
+    field SpatialVelocity tcp_reduced_max_velocity
+    field SpatialAcceleration tcp_reduced_max_acceleration
+    field string description
+    field varvalue{string} extended
+end
+
+struct RobotInfo
+    field DeviceInfo device_info
+    field RobotTypeCode robot_type
+    field JointInfo{list} joint_info
+    field RobotKinChainInfo{list} chains
+    field uint32 robot_capabilities
+    field SignalInfo{list} signal_info
+    field ParameterInfo{list} parameter_info
+    field uint16 config_seqno
+    field InterpolationMode{list} trajectory_interpolation_modes
+    field varvalue{string} extended
+end
+
+struct RobotState
+    field TimeSpec3 ts
+    field uint64 seqno
+    field RobotCommandMode command_mode
+    field RobotOperationalMode operational_mode
+    field RobotControllerState controller_state
+    field uint64 robot_state_flags
+    field double[] joint_position
+    field double[] joint_velocity
+    field double[] joint_effort
+    field double[] joint_position_command
+    field double[] joint_velocity_command
+    field Pose[] kin_chain_tcp
+    field SpatialVelocity[] kin_chain_tcp_vel
+    field bool trajectory_running
+end
+
+struct AdvancedRobotState
+    field TimeSpec3 ts
+    field uint64 seqno
+    field RobotCommandMode command_mode
+    field RobotOperationalMode operational_mode
+    field RobotControllerState controller_state
+    field uint64 robot_state_flags
+    field double[] joint_position
+    field double[] joint_velocity
+    field double[] joint_effort
+    field double[] joint_position_command
+    field double[] joint_velocity_command
+    field uint8[] joint_position_units
+    field uint8[] joint_effort_units
+    field Pose[] kin_chain_tcp
+    field SpatialVelocity[] kin_chain_tcp_vel
+    field bool trajectory_running
+    field double trajectory_time
+    field double trajectory_max_time
+    field uint32 trajectory_current_waypoint
+    field uint16 config_seqno
+end
+
+struct RobotStateSensorData
+    field SensorDataHeader data_header
+    field AdvancedRobotState robot_state
+end
+
+struct RobotJointCommand
+    field uint64 seqno
+    field uint64 state_seqno
+    field double[] command
+    # Use JointUnits values
+    field uint8[] units
+end
+
+object Robot
+    implements Device
+    implements DeviceClock
+    implements IsochDevice
+    property DeviceInfo device_info [readonly,nolock]
+    property RobotInfo robot_info [readonly,nolock]
+    property RobotCommandMode command_mode [nolockread]
+    property RobotOperationalMode operational_mode [readonly, nolock]
+    property RobotControllerState controller_state [readonly, nolock]
+    property EventLogMessage{list} current_errors [readonly, nolock]
+    function void halt() [urgent]
+    function void enable()
+    function void disable() [urgent]
+    function void reset_errors()
+    property double speed_ratio
+    function void jog_freespace(double[] joint_position, double[] max_velocity, bool wait)
+    function void jog_joint(double[] joint_velocity, double timeout, bool wait)
+    function void jog_cartesian(SpatialVelocity{int32} max_velocity, double timeout, bool wait)
+    function TrajectoryStatus{generator} execute_trajectory(JointTrajectory trajectory)
+    wire RobotState robot_state [readonly,nolock]
+    wire AdvancedRobotState advanced_robot_state [readonly,nolock]
+    pipe RobotStateSensorData robot_state_sensor_data [readonly,nolock]
+    property IsochInfo isoch_info [readonly,nolock]
+    property uint32 isoch_downsample [perclient]
+    wire DeviceTime device_clock_now [readonly,nolock]
+    wire RobotJointCommand position_command [writeonly]
+    wire RobotJointCommand velocity_command [writeonly]
+    function ActionStatusCode{generator} home()
+    function double[] getf_signal(string signal_name)
+    function void setf_signal(string signal_name, double[] value)
+    function void tool_attached(int32 chain, ToolInfo tool)
+    function void tool_detached(int32 chain, string tool_name)
+    event tool_changed(int32 chain, string tool_name)
+    function void payload_attached(int32 chain, PayloadInfo payload, Pose pose)
+    function void payload_detached(int32 chain, string payload_name)
+    event payload_changed(int32 chain, string payload_name)
+    function varvalue getf_param(string param_name)
+    function void setf_param(string param_name, varvalue value)
+    event param_changed(string param_name)
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.robotics.tool.robdef

 * *Ordering differences only*

```diff
@@ -1,130 +1,130 @@
-service com.robotraconteur.robotics.tool
-
-stdver 0.10
-
-import com.robotraconteur.device
-import com.robotraconteur.geometry
-import com.robotraconteur.sensor
-import com.robotraconteur.robotics.joints
-import com.robotraconteur.units
-import com.robotraconteur.sensordata
-import com.robotraconteur.device.isoch
-import com.robotraconteur.device.clock
-import com.robotraconteur.datetime
-import com.robotraconteur.fiducial
-
-using com.robotraconteur.device.DeviceInfo
-using com.robotraconteur.device.Device
-using com.robotraconteur.geometry.Transform
-using com.robotraconteur.geometry.SpatialInertia
-using com.robotraconteur.sensor.SensorTypeCode
-using com.robotraconteur.robotics.joints.JointPositionUnits
-using com.robotraconteur.units.SIUnit
-using com.robotraconteur.sensordata.SensorDataHeader
-using com.robotraconteur.device.isoch.IsochDevice
-using com.robotraconteur.device.isoch.IsochInfo
-using com.robotraconteur.device.clock.DeviceClock
-using com.robotraconteur.device.clock.DeviceTime
-using com.robotraconteur.datetime.TimeSpec3
-using com.robotraconteur.fiducial.Fiducial
-
-enum ToolTypeCode
-    unknown = 0,
-    basic_gripper,
-    basic_continuous_gripper,
-    pneumatic_gripper,
-    electric_gripper,
-    vacuum_gripper,
-    soft_gripper,
-    welder,
-    hand,
-    palletizer,
-    other
-end
-
-enum ToolCapabilities
-    unknown = 0,
-    open_close_command = 0x1,
-    continuous_command = 0x2,
-    homing_command = 0x4,
-    software_reset_errors = 0x8,
-    software_enable = 0x10,
-    sensor_feedback = 0x20
-end
-
-enum ToolStateFlags
-    unknown = 0,
-    error = 0x1,
-    fatal_error = 0x2,
-    estop = 0x4,
-    communication_failure = 0x8,
-    enabled = 0x10,
-    ready = 0x20,
-    opened = 0x40,
-    closed = 0x80,
-    between = 0x100,
-    actuating = 0x200,
-    homing = 0x400,
-    requires_homing = 0x800,
-    homed = 0x1000,
-    gripping = 0x2000,
-    missed = 0x4000
-end
-
-struct ToolInfo
-    field DeviceInfo device_info
-    field ToolTypeCode tool_type
-    field uint32 tool_capabilities
-    field Transform tcp
-    field SpatialInertia inertia
-    field Fiducial{list} fiducials
-    field double actuation_time
-    field double close_position
-    field double open_position
-    field double command_min
-    field double command_max
-    field double command_close
-    field double command_open
-    field SensorTypeCode{list} sensor_type
-    field double[] sensor_min
-    field double[] sensor_max
-    field SIUnit{list} sensor_units
-    field varvalue{string} extended
-end
-
-struct ToolState
-    field TimeSpec3 ts
-    field uint64 seqno
-    field uint32 tool_state_flags
-    field double position
-    field double command
-    field double[] sensor
-end
-
-struct ToolStateSensorData
-    field SensorDataHeader data_header
-    field ToolState robot_state
-end
-
-object Tool
-    implements Device
-    implements DeviceClock
-    implements IsochDevice
-    property DeviceInfo device_info [readonly,nolock]
-    property ToolInfo tool_info [readonly,nolock]
-    function void open()
-    function void close()
-    function void halt() [urgent]
-    function void setf_command(double command)
-    wire ToolState tool_state [readonly,nolock]
-    pipe ToolStateSensorData tool_state_sensor_data [readonly,nolock]
-    property IsochInfo isoch_info [readonly,nolock]
-    property uint32 isoch_downsample [perclient]
-    wire DeviceTime device_clock_now [readonly,nolock]
-    function varvalue getf_param(string param_name)
-    function void setf_param(string param_name, varvalue value)
-    function void enable()
-    function void disable() [urgent]
-    function void reset_errors()
-    function void home()
-end
+service com.robotraconteur.robotics.tool
+
+stdver 0.10
+
+import com.robotraconteur.device
+import com.robotraconteur.geometry
+import com.robotraconteur.sensor
+import com.robotraconteur.robotics.joints
+import com.robotraconteur.units
+import com.robotraconteur.sensordata
+import com.robotraconteur.device.isoch
+import com.robotraconteur.device.clock
+import com.robotraconteur.datetime
+import com.robotraconteur.fiducial
+
+using com.robotraconteur.device.DeviceInfo
+using com.robotraconteur.device.Device
+using com.robotraconteur.geometry.Transform
+using com.robotraconteur.geometry.SpatialInertia
+using com.robotraconteur.sensor.SensorTypeCode
+using com.robotraconteur.robotics.joints.JointPositionUnits
+using com.robotraconteur.units.SIUnit
+using com.robotraconteur.sensordata.SensorDataHeader
+using com.robotraconteur.device.isoch.IsochDevice
+using com.robotraconteur.device.isoch.IsochInfo
+using com.robotraconteur.device.clock.DeviceClock
+using com.robotraconteur.device.clock.DeviceTime
+using com.robotraconteur.datetime.TimeSpec3
+using com.robotraconteur.fiducial.Fiducial
+
+enum ToolTypeCode
+    unknown = 0,
+    basic_gripper,
+    basic_continuous_gripper,
+    pneumatic_gripper,
+    electric_gripper,
+    vacuum_gripper,
+    soft_gripper,
+    welder,
+    hand,
+    palletizer,
+    other
+end
+
+enum ToolCapabilities
+    unknown = 0,
+    open_close_command = 0x1,
+    continuous_command = 0x2,
+    homing_command = 0x4,
+    software_reset_errors = 0x8,
+    software_enable = 0x10,
+    sensor_feedback = 0x20
+end
+
+enum ToolStateFlags
+    unknown = 0,
+    error = 0x1,
+    fatal_error = 0x2,
+    estop = 0x4,
+    communication_failure = 0x8,
+    enabled = 0x10,
+    ready = 0x20,
+    opened = 0x40,
+    closed = 0x80,
+    between = 0x100,
+    actuating = 0x200,
+    homing = 0x400,
+    requires_homing = 0x800,
+    homed = 0x1000,
+    gripping = 0x2000,
+    missed = 0x4000
+end
+
+struct ToolInfo
+    field DeviceInfo device_info
+    field ToolTypeCode tool_type
+    field uint32 tool_capabilities
+    field Transform tcp
+    field SpatialInertia inertia
+    field Fiducial{list} fiducials
+    field double actuation_time
+    field double close_position
+    field double open_position
+    field double command_min
+    field double command_max
+    field double command_close
+    field double command_open
+    field SensorTypeCode{list} sensor_type
+    field double[] sensor_min
+    field double[] sensor_max
+    field SIUnit{list} sensor_units
+    field varvalue{string} extended
+end
+
+struct ToolState
+    field TimeSpec3 ts
+    field uint64 seqno
+    field uint32 tool_state_flags
+    field double position
+    field double command
+    field double[] sensor
+end
+
+struct ToolStateSensorData
+    field SensorDataHeader data_header
+    field ToolState robot_state
+end
+
+object Tool
+    implements Device
+    implements DeviceClock
+    implements IsochDevice
+    property DeviceInfo device_info [readonly,nolock]
+    property ToolInfo tool_info [readonly,nolock]
+    function void open()
+    function void close()
+    function void halt() [urgent]
+    function void setf_command(double command)
+    wire ToolState tool_state [readonly,nolock]
+    pipe ToolStateSensorData tool_state_sensor_data [readonly,nolock]
+    property IsochInfo isoch_info [readonly,nolock]
+    property uint32 isoch_downsample [perclient]
+    wire DeviceTime device_clock_now [readonly,nolock]
+    function varvalue getf_param(string param_name)
+    function void setf_param(string param_name, varvalue value)
+    function void enable()
+    function void disable() [urgent]
+    function void reset_errors()
+    function void home()
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.robotics.trajectory.robdef

 * *Ordering differences only*

```diff
@@ -1,108 +1,108 @@
-service com.robotraconteur.robotics.trajectory
-
-stdver 0.10
-
-import com.robotraconteur.robotics.joints
-import com.robotraconteur.identifier
-import com.robotraconteur.action
-
-using com.robotraconteur.robotics.joints.JointPositionUnits
-using com.robotraconteur.robotics.joints.JointEffortUnits
-using com.robotraconteur.identifier.Identifier
-using com.robotraconteur.action.ActionStatusCode
-
-enum InterpolationMode
-    default = 0,
-    joint,
-    linear,
-    cylindrical,
-    spherical,
-    joint_cubic_spline,
-    cubic_spline,
-    custom
-end
-
-enum TrajectoryWaypointType
-    unspecified = 0,
-    start = 1,
-    path,
-    goal,
-    intermediate_stop,
-    raster,
-    other
-end
-
-struct JointTrajectoryWaypoint
-    field double[] joint_position
-    field double[] joint_velocity
-    field double[] position_tolerance
-    field double[] velocity_tolerance
-    field InterpolationMode interpolation_mode
-    field TrajectoryWaypointType waypoint_type
-    field double time_from_start
-end
-
-struct JointTrajectory
-    field string{list} joint_names
-    field JointPositionUnits{list} joint_units
-    field JointTrajectoryWaypoint{list} waypoints
-    field varvalue{string} extended
-end
-
-struct TrajectoryStatus
-    field uint64 seqno
-    field ActionStatusCode action_status
-    field uint32 current_waypoint
-    field double trajectory_time
-end
-
-struct AdvancedJointTrajectoryDeviceWaypoint
-    # Use list for compound joints
-    field double[]{list} joint_position
-    field double[]{list} joint_velocity
-    field double[]{list} joint_acceleration
-    field double[]{list} joint_jerk
-    field double[]{list} joint_effort
-    field double[]{list} position_tolerance
-    field double[]{list} velocity_tolerance
-    field InterpolationMode interpolation_mode
-    field TrajectoryWaypointType waypoint_type
-    field varvalue{string} signals
-end
-
-struct AdvancedJointTrajectoryWaypoint
-    field AdvancedJointTrajectoryDeviceWaypoint{list} joints
-    field double time_from_start
-end
-
-struct AdvancedJointTrajectoryDevice
-    field Identifier device
-    field string{list} joint_names
-    field JointPositionUnits{list} joint_units
-    field JointEffortUnits{list} joint_effort_units
-    field varvalue{string} extended
-end
-
-struct AdvancedJointTrajectory
-    field AdvancedJointTrajectoryDevice{list} devices
-    field AdvancedJointTrajectoryWaypoint{list} waypoints
-    field varvalue{string} extended
-end
-
-struct FreeformJointTrajectoryWaypoint
-    field varvalue{list} joint_position
-    field varvalue{list} joint_velocity
-    field varvalue{list} position_tolerance
-    field varvalue{list} velocity_tolerance
-    field string interpolation_mode
-    field varvalue{string} signals
-    field double time_from_start
-    field varvalue{string} extended
-end
-
-struct FreeformJointTrajectory
-    field string{list} joint_names
-    field string{list} joint_units
-    field FreeformJointTrajectoryWaypoint{list} waypoints
-    field varvalue{string} extended
-end
+service com.robotraconteur.robotics.trajectory
+
+stdver 0.10
+
+import com.robotraconteur.robotics.joints
+import com.robotraconteur.identifier
+import com.robotraconteur.action
+
+using com.robotraconteur.robotics.joints.JointPositionUnits
+using com.robotraconteur.robotics.joints.JointEffortUnits
+using com.robotraconteur.identifier.Identifier
+using com.robotraconteur.action.ActionStatusCode
+
+enum InterpolationMode
+    default = 0,
+    joint,
+    linear,
+    cylindrical,
+    spherical,
+    joint_cubic_spline,
+    cubic_spline,
+    custom
+end
+
+enum TrajectoryWaypointType
+    unspecified = 0,
+    start = 1,
+    path,
+    goal,
+    intermediate_stop,
+    raster,
+    other
+end
+
+struct JointTrajectoryWaypoint
+    field double[] joint_position
+    field double[] joint_velocity
+    field double[] position_tolerance
+    field double[] velocity_tolerance
+    field InterpolationMode interpolation_mode
+    field TrajectoryWaypointType waypoint_type
+    field double time_from_start
+end
+
+struct JointTrajectory
+    field string{list} joint_names
+    field JointPositionUnits{list} joint_units
+    field JointTrajectoryWaypoint{list} waypoints
+    field varvalue{string} extended
+end
+
+struct TrajectoryStatus
+    field uint64 seqno
+    field ActionStatusCode action_status
+    field uint32 current_waypoint
+    field double trajectory_time
+end
+
+struct AdvancedJointTrajectoryDeviceWaypoint
+    # Use list for compound joints
+    field double[]{list} joint_position
+    field double[]{list} joint_velocity
+    field double[]{list} joint_acceleration
+    field double[]{list} joint_jerk
+    field double[]{list} joint_effort
+    field double[]{list} position_tolerance
+    field double[]{list} velocity_tolerance
+    field InterpolationMode interpolation_mode
+    field TrajectoryWaypointType waypoint_type
+    field varvalue{string} signals
+end
+
+struct AdvancedJointTrajectoryWaypoint
+    field AdvancedJointTrajectoryDeviceWaypoint{list} joints
+    field double time_from_start
+end
+
+struct AdvancedJointTrajectoryDevice
+    field Identifier device
+    field string{list} joint_names
+    field JointPositionUnits{list} joint_units
+    field JointEffortUnits{list} joint_effort_units
+    field varvalue{string} extended
+end
+
+struct AdvancedJointTrajectory
+    field AdvancedJointTrajectoryDevice{list} devices
+    field AdvancedJointTrajectoryWaypoint{list} waypoints
+    field varvalue{string} extended
+end
+
+struct FreeformJointTrajectoryWaypoint
+    field varvalue{list} joint_position
+    field varvalue{list} joint_velocity
+    field varvalue{list} position_tolerance
+    field varvalue{list} velocity_tolerance
+    field string interpolation_mode
+    field varvalue{string} signals
+    field double time_from_start
+    field varvalue{string} extended
+end
+
+struct FreeformJointTrajectory
+    field string{list} joint_names
+    field string{list} joint_units
+    field FreeformJointTrajectoryWaypoint{list} waypoints
+    field varvalue{string} extended
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.sensor.robdef

 * *Ordering differences only*

```diff
@@ -1,208 +1,208 @@
-service com.robotraconteur.sensor
-
-stdver 0.10
-
-import com.robotraconteur.sensordata
-import com.robotraconteur.device
-import com.robotraconteur.param
-import com.robotraconteur.geometry
-import com.robotraconteur.units
-import com.robotraconteur.datatype
-
-using com.robotraconteur.sensordata.SensorDataHeader
-using com.robotraconteur.device.DeviceInfo
-using com.robotraconteur.device.Device
-using com.robotraconteur.param.ParameterInfo
-using com.robotraconteur.geometry.Vector2
-using com.robotraconteur.geometry.Vector3
-using com.robotraconteur.geometry.Vector6
-using com.robotraconteur.geometry.Wrench
-using com.robotraconteur.units.SIUnit
-using com.robotraconteur.datatype.DataType
-
-enum SensorTypeCode
-    unknown = 0,
-    generic_digital,
-    generic_analog,
-    pushbutton,
-    dial,
-    limitswitch,
-    infrared,
-    pressure,
-    vacuum,
-    temperature,
-    humidity,
-    level,
-    contact,
-    ultrasonic,
-    magnetic,
-    encoder,
-    potentiometer,
-    resolver,
-    linear_encoder,
-    linear_potentiometer,
-    lvds,
-    accelerometer,
-    gyroscopic,
-    velocity,
-    angular_velocity,
-    spatial_velocity,
-    torque,
-    force,
-    proximity,
-    voltage,
-    current,
-    laser,
-    flow,
-    pyrometer,
-    forcetorque,
-    light_color,
-    light_intensity,
-    object_color,
-    altitude,
-    generic_word,
-    generic_vector,
-    position,
-    angle,
-    acceleration,
-    angular_acceleration,
-    inclinometer,
-    tilt,
-    motion,
-    radiation,
-    photoelectric,
-    leak,
-    chemical,
-    particle,
-    metal,
-    smoke,
-    flame,
-    vibration,
-    mark,
-    contamination,
-    inertial,
-    magnetometer,
-    navigation,
-    tactile,
-    meteorological,
-    horizon,
-    sun,
-    star,
-    moon,
-    attitude,
-    airspeed,
-    distance,
-    heading,
-    safety,
-    door,
-    security,
-    other=0x8000,
-    vendor_defined=0x80000
-end
-
-enum SensorDataFlags
-    unknown = 0,
-    enabled = 0x1,
-    streaming = 0x2,
-    calibrated = 0x4,
-    calibration_error = 0x8,
-    out_of_range = 0x10,
-    out_of_range_high = 0x20,
-    out_of_range_low = 0x40,
-    warning = 0x80,
-    error = 0x100,
-    fatal_error = 0x200,
-    ready = 0x400
-end
-
-struct SensorInfo
-    field DeviceInfo device_info
-    field SensorTypeCode sensor_type
-    field SIUnit{list} units
-    field DataType data_type
-    field double[] sensor_resolution
-    field bool analog_sensor
-    field double update_frequency
-    field ParameterInfo{list} parameter_info
-    field varvalue{string} extended
-end
-
-struct SensorData
-    field SensorDataHeader data_header
-    field uint32 data_flags
-    field double[] data
-    field DataType data_type
-    field SIUnit{list} data_units
-    field varvalue{string} parameters
-    field varvalue{string} extended
-end
-
-object Sensor
-    implements Device
-    property DeviceInfo device_info [readonly,nolock]
-    property SensorInfo sensor_info [readonly,nolock]
-    wire double[] sensor_value [readonly,nolock]
-    pipe SensorData sensor_data [readonly,nolock]
-    function varvalue getf_param(string param_name)
-    function void setf_param(string param_name, varvalue value)
-end
-
-object Vector2Sensor
-    implements Device
-    implements Sensor
-    property DeviceInfo device_info [readonly,nolock]
-    property SensorInfo sensor_info [readonly,nolock]
-    wire double[] sensor_value [readonly,nolock]
-    pipe SensorData sensor_data [readonly,nolock]
-    function varvalue getf_param(string param_name)
-    function void setf_param(string param_name, varvalue value)
-    wire Vector2 vector2_sensor_value [readonly,nolock]
-end
-
-object Vector3Sensor
-    implements Sensor
-    implements Device
-    property DeviceInfo device_info [readonly,nolock]
-    property SensorInfo sensor_info [readonly,nolock]
-    wire double[] sensor_value [readonly,nolock]
-    pipe SensorData sensor_data [readonly,nolock]
-    function varvalue getf_param(string param_name)
-    function void setf_param(string param_name, varvalue value)
-    wire Vector3 vector3_sensor_value [readonly,nolock]
-end
-
-object Vector6Sensor
-    implements Sensor
-    implements Device
-    property DeviceInfo device_info [readonly,nolock]
-    property SensorInfo sensor_info [readonly,nolock]
-    wire double[] sensor_value [readonly,nolock]
-    pipe SensorData sensor_data [readonly,nolock]
-    function varvalue getf_param(string param_name)
-    function void setf_param(string param_name, varvalue value)
-    wire Vector6 vector6_sensor_value [readonly,nolock]
-end
-
-object WrenchSensor
-    implements Sensor
-    implements Device
-    property DeviceInfo device_info [readonly,nolock]
-    property SensorInfo sensor_info [readonly,nolock]
-    wire double[] sensor_value [readonly,nolock]
-    pipe SensorData sensor_data [readonly,nolock]
-    function varvalue getf_param(string param_name)
-    function void setf_param(string param_name, varvalue value)
-    wire Wrench wrench_sensor_value [readonly,nolock]
-end
-
-object FreeformSensor
-    implements Sensor
-    implements Device
-    property DeviceInfo device_info [readonly,nolock]
-    property SensorInfo sensor_info [readonly,nolock]
-    wire double[] sensor_value [readonly,nolock]
-    pipe SensorData sensor_data [readonly,nolock]
-    function varvalue getf_param(string param_name)
-    function void setf_param(string param_name, varvalue value)
-    wire varvalue freeform_sensor_value [readonly,nolock]
-end
+service com.robotraconteur.sensor
+
+stdver 0.10
+
+import com.robotraconteur.sensordata
+import com.robotraconteur.device
+import com.robotraconteur.param
+import com.robotraconteur.geometry
+import com.robotraconteur.units
+import com.robotraconteur.datatype
+
+using com.robotraconteur.sensordata.SensorDataHeader
+using com.robotraconteur.device.DeviceInfo
+using com.robotraconteur.device.Device
+using com.robotraconteur.param.ParameterInfo
+using com.robotraconteur.geometry.Vector2
+using com.robotraconteur.geometry.Vector3
+using com.robotraconteur.geometry.Vector6
+using com.robotraconteur.geometry.Wrench
+using com.robotraconteur.units.SIUnit
+using com.robotraconteur.datatype.DataType
+
+enum SensorTypeCode
+    unknown = 0,
+    generic_digital,
+    generic_analog,
+    pushbutton,
+    dial,
+    limitswitch,
+    infrared,
+    pressure,
+    vacuum,
+    temperature,
+    humidity,
+    level,
+    contact,
+    ultrasonic,
+    magnetic,
+    encoder,
+    potentiometer,
+    resolver,
+    linear_encoder,
+    linear_potentiometer,
+    lvds,
+    accelerometer,
+    gyroscopic,
+    velocity,
+    angular_velocity,
+    spatial_velocity,
+    torque,
+    force,
+    proximity,
+    voltage,
+    current,
+    laser,
+    flow,
+    pyrometer,
+    forcetorque,
+    light_color,
+    light_intensity,
+    object_color,
+    altitude,
+    generic_word,
+    generic_vector,
+    position,
+    angle,
+    acceleration,
+    angular_acceleration,
+    inclinometer,
+    tilt,
+    motion,
+    radiation,
+    photoelectric,
+    leak,
+    chemical,
+    particle,
+    metal,
+    smoke,
+    flame,
+    vibration,
+    mark,
+    contamination,
+    inertial,
+    magnetometer,
+    navigation,
+    tactile,
+    meteorological,
+    horizon,
+    sun,
+    star,
+    moon,
+    attitude,
+    airspeed,
+    distance,
+    heading,
+    safety,
+    door,
+    security,
+    other=0x8000,
+    vendor_defined=0x80000
+end
+
+enum SensorDataFlags
+    unknown = 0,
+    enabled = 0x1,
+    streaming = 0x2,
+    calibrated = 0x4,
+    calibration_error = 0x8,
+    out_of_range = 0x10,
+    out_of_range_high = 0x20,
+    out_of_range_low = 0x40,
+    warning = 0x80,
+    error = 0x100,
+    fatal_error = 0x200,
+    ready = 0x400
+end
+
+struct SensorInfo
+    field DeviceInfo device_info
+    field SensorTypeCode sensor_type
+    field SIUnit{list} units
+    field DataType data_type
+    field double[] sensor_resolution
+    field bool analog_sensor
+    field double update_frequency
+    field ParameterInfo{list} parameter_info
+    field varvalue{string} extended
+end
+
+struct SensorData
+    field SensorDataHeader data_header
+    field uint32 data_flags
+    field double[] data
+    field DataType data_type
+    field SIUnit{list} data_units
+    field varvalue{string} parameters
+    field varvalue{string} extended
+end
+
+object Sensor
+    implements Device
+    property DeviceInfo device_info [readonly,nolock]
+    property SensorInfo sensor_info [readonly,nolock]
+    wire double[] sensor_value [readonly,nolock]
+    pipe SensorData sensor_data [readonly,nolock]
+    function varvalue getf_param(string param_name)
+    function void setf_param(string param_name, varvalue value)
+end
+
+object Vector2Sensor
+    implements Device
+    implements Sensor
+    property DeviceInfo device_info [readonly,nolock]
+    property SensorInfo sensor_info [readonly,nolock]
+    wire double[] sensor_value [readonly,nolock]
+    pipe SensorData sensor_data [readonly,nolock]
+    function varvalue getf_param(string param_name)
+    function void setf_param(string param_name, varvalue value)
+    wire Vector2 vector2_sensor_value [readonly,nolock]
+end
+
+object Vector3Sensor
+    implements Sensor
+    implements Device
+    property DeviceInfo device_info [readonly,nolock]
+    property SensorInfo sensor_info [readonly,nolock]
+    wire double[] sensor_value [readonly,nolock]
+    pipe SensorData sensor_data [readonly,nolock]
+    function varvalue getf_param(string param_name)
+    function void setf_param(string param_name, varvalue value)
+    wire Vector3 vector3_sensor_value [readonly,nolock]
+end
+
+object Vector6Sensor
+    implements Sensor
+    implements Device
+    property DeviceInfo device_info [readonly,nolock]
+    property SensorInfo sensor_info [readonly,nolock]
+    wire double[] sensor_value [readonly,nolock]
+    pipe SensorData sensor_data [readonly,nolock]
+    function varvalue getf_param(string param_name)
+    function void setf_param(string param_name, varvalue value)
+    wire Vector6 vector6_sensor_value [readonly,nolock]
+end
+
+object WrenchSensor
+    implements Sensor
+    implements Device
+    property DeviceInfo device_info [readonly,nolock]
+    property SensorInfo sensor_info [readonly,nolock]
+    wire double[] sensor_value [readonly,nolock]
+    pipe SensorData sensor_data [readonly,nolock]
+    function varvalue getf_param(string param_name)
+    function void setf_param(string param_name, varvalue value)
+    wire Wrench wrench_sensor_value [readonly,nolock]
+end
+
+object FreeformSensor
+    implements Sensor
+    implements Device
+    property DeviceInfo device_info [readonly,nolock]
+    property SensorInfo sensor_info [readonly,nolock]
+    wire double[] sensor_value [readonly,nolock]
+    pipe SensorData sensor_data [readonly,nolock]
+    function varvalue getf_param(string param_name)
+    function void setf_param(string param_name, varvalue value)
+    wire varvalue freeform_sensor_value [readonly,nolock]
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.sensordata.robdef

 * *Ordering differences only*

```diff
@@ -1,25 +1,25 @@
-service com.robotraconteur.sensordata
-
-stdver 0.10
-
-import com.robotraconteur.datetime
-import com.robotraconteur.identifier
-import com.robotraconteur.geometry
-
-using com.robotraconteur.datetime.TimeSpec2
-using com.robotraconteur.identifier.Identifier
-using com.robotraconteur.geometry.Pose
-
-struct SensorDataHeader
-    field TimeSpec2 ts
-    field uint64 seqno
-    field SensorDataSourceInfo source_info
-end
-
-struct SensorDataSourceInfo
-    field Identifier source
-    field Pose source_world_pose
-    field string source_config_nonce
-    field varvalue{string} source_params
-    field varvalue{string} extended
-end
+service com.robotraconteur.sensordata
+
+stdver 0.10
+
+import com.robotraconteur.datetime
+import com.robotraconteur.identifier
+import com.robotraconteur.geometry
+
+using com.robotraconteur.datetime.TimeSpec2
+using com.robotraconteur.identifier.Identifier
+using com.robotraconteur.geometry.Pose
+
+struct SensorDataHeader
+    field TimeSpec2 ts
+    field uint64 seqno
+    field SensorDataSourceInfo source_info
+end
+
+struct SensorDataSourceInfo
+    field Identifier source
+    field Pose source_world_pose
+    field string source_config_nonce
+    field varvalue{string} source_params
+    field varvalue{string} extended
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.servo.robdef

 * *Ordering differences only*

```diff
@@ -1,142 +1,142 @@
-service com.robotraconteur.servo
-
-stdver 0.10
-
-import com.robotraconteur.sensordata
-import com.robotraconteur.device
-import com.robotraconteur.signal
-import com.robotraconteur.param
-import com.robotraconteur.robotics.joints
-import com.robotraconteur.device.isoch
-import com.robotraconteur.device.clock
-import com.robotraconteur.datetime
-
-using com.robotraconteur.sensordata.SensorDataHeader
-using com.robotraconteur.device.DeviceInfo
-using com.robotraconteur.device.Device
-using com.robotraconteur.signal.SignalInfo
-using com.robotraconteur.param.ParameterInfo
-using com.robotraconteur.robotics.joints.JointPositionUnits
-using com.robotraconteur.robotics.joints.JointEffortUnits
-using com.robotraconteur.device.isoch.IsochDevice
-using com.robotraconteur.device.isoch.IsochInfo
-using com.robotraconteur.device.clock.DeviceClock
-using com.robotraconteur.device.clock.DeviceTime
-using com.robotraconteur.datetime.TimeSpec3
-
-enum ServoTypeCode
-    unknown = 0,
-    generic_revolute,
-    generic_prismatic,
-    revolute_electric,
-    prismatic_electric,
-    rc_servo
-end
-
-enum ServoCapabilities
-    unknown = 0,
-    position_command = 0x1,
-    velocity_command = 0x2,
-    effort_command = 0x4,
-    trapezoidal_command = 0x8,
-    signals = 0x1000
-end
-
-enum ServoMode
-    error = -2,
-    disabled = -1,
-    halt = 0,
-    position_command,
-    velocity_command,
-    effort_command,
-    trapezoidal_command
-end
-
-enum ServoStateFlags
-    unknown = 0,
-    ready = 0x1,
-    streaming = 0x2,
-    warning = 0x4,
-    error = 0x8,
-    fatal_error = 0x10,
-    e_stop = 0x20,
-    homed = 0x40,
-    homing_required = 0x80,
-    communication_failure = 0x100,
-    valid_command = 0x200,
-    enabled = 0x400
-end
-
-struct ServoInfo
-    field DeviceInfo device_info
-    field ServoTypeCode servo_type
-    field uint32 capabilities
-    field uint32 axis_count
-    field JointPositionUnits{list} position_units
-    field JointEffortUnits{list} effort_units
-    field double[] position_min
-    field double[] position_max
-    field double[] velocity_min
-    field double[] velocity_max
-    field double[] acceleration_min
-    field double[] acceleration_max
-    field double[] torque_min
-    field double[] torque_max
-    field double[] gear_ratio
-    field double[] sensor_resolution
-    field double[] effort_command_resolution
-    field ParameterInfo{list} parameter_info
-    field SignalInfo{list} signal_info
-    field varvalue{string} extended
-end
-
-struct ServoState
-    field TimeSpec3 ts
-    field uint64 seqno
-    field uint32 servo_state_flags
-    field ServoMode mode
-    field double[] position
-    field double[] velocity
-    field double[] acceleration
-    field double[] effort
-    field double[] position_command
-    field double[] velocity_command
-    field double[] effort_command
-end
-
-struct ServoStateSensorData
-    field SensorDataHeader data_header
-    field ServoState servo_state
-    field varvalue{string} extended
-end
-
-struct ServoCommand
-    field uint64 seqno
-    field uint64 status_seqno
-    field double[] command
-end
-
-object Servo
-    implements Device
-    implements DeviceClock
-    implements IsochDevice
-    property DeviceInfo device_info [readonly,nolock]
-    function void halt() [urgent,nolock]
-    property ServoInfo servo_info [readonly,nolock]
-    property ServoMode mode [nolockread]
-    wire double[] position [readonly,nolock]
-    wire double[] velocity [readonly, nolock]
-    wire ServoState servo_state [readonly,nolock]
-    pipe ServoStateSensorData servo_state_sensor_data [readonly,nolock]
-    wire ServoCommand position_command [writeonly]
-    wire ServoCommand velocity_command [writeonly]
-    wire ServoCommand effort_command [writeonly]
-    function void trapezoidal_move(double[] target_pos, double[] target_vel, double[] vel, double[] accel)
-    property IsochInfo isoch_info [readonly,nolock]
-    property uint32 isoch_downsample [perclient]
-    wire DeviceTime device_clock_now [readonly,nolock]
-    function varvalue getf_signal(string signal_name)
-    function void setf_signal(string signal_name, varvalue value)
-    function varvalue getf_param(string param_name)
-    function void setf_param(string param_name, varvalue value)
-end
+service com.robotraconteur.servo
+
+stdver 0.10
+
+import com.robotraconteur.sensordata
+import com.robotraconteur.device
+import com.robotraconteur.signal
+import com.robotraconteur.param
+import com.robotraconteur.robotics.joints
+import com.robotraconteur.device.isoch
+import com.robotraconteur.device.clock
+import com.robotraconteur.datetime
+
+using com.robotraconteur.sensordata.SensorDataHeader
+using com.robotraconteur.device.DeviceInfo
+using com.robotraconteur.device.Device
+using com.robotraconteur.signal.SignalInfo
+using com.robotraconteur.param.ParameterInfo
+using com.robotraconteur.robotics.joints.JointPositionUnits
+using com.robotraconteur.robotics.joints.JointEffortUnits
+using com.robotraconteur.device.isoch.IsochDevice
+using com.robotraconteur.device.isoch.IsochInfo
+using com.robotraconteur.device.clock.DeviceClock
+using com.robotraconteur.device.clock.DeviceTime
+using com.robotraconteur.datetime.TimeSpec3
+
+enum ServoTypeCode
+    unknown = 0,
+    generic_revolute,
+    generic_prismatic,
+    revolute_electric,
+    prismatic_electric,
+    rc_servo
+end
+
+enum ServoCapabilities
+    unknown = 0,
+    position_command = 0x1,
+    velocity_command = 0x2,
+    effort_command = 0x4,
+    trapezoidal_command = 0x8,
+    signals = 0x1000
+end
+
+enum ServoMode
+    error = -2,
+    disabled = -1,
+    halt = 0,
+    position_command,
+    velocity_command,
+    effort_command,
+    trapezoidal_command
+end
+
+enum ServoStateFlags
+    unknown = 0,
+    ready = 0x1,
+    streaming = 0x2,
+    warning = 0x4,
+    error = 0x8,
+    fatal_error = 0x10,
+    e_stop = 0x20,
+    homed = 0x40,
+    homing_required = 0x80,
+    communication_failure = 0x100,
+    valid_command = 0x200,
+    enabled = 0x400
+end
+
+struct ServoInfo
+    field DeviceInfo device_info
+    field ServoTypeCode servo_type
+    field uint32 capabilities
+    field uint32 axis_count
+    field JointPositionUnits{list} position_units
+    field JointEffortUnits{list} effort_units
+    field double[] position_min
+    field double[] position_max
+    field double[] velocity_min
+    field double[] velocity_max
+    field double[] acceleration_min
+    field double[] acceleration_max
+    field double[] torque_min
+    field double[] torque_max
+    field double[] gear_ratio
+    field double[] sensor_resolution
+    field double[] effort_command_resolution
+    field ParameterInfo{list} parameter_info
+    field SignalInfo{list} signal_info
+    field varvalue{string} extended
+end
+
+struct ServoState
+    field TimeSpec3 ts
+    field uint64 seqno
+    field uint32 servo_state_flags
+    field ServoMode mode
+    field double[] position
+    field double[] velocity
+    field double[] acceleration
+    field double[] effort
+    field double[] position_command
+    field double[] velocity_command
+    field double[] effort_command
+end
+
+struct ServoStateSensorData
+    field SensorDataHeader data_header
+    field ServoState servo_state
+    field varvalue{string} extended
+end
+
+struct ServoCommand
+    field uint64 seqno
+    field uint64 status_seqno
+    field double[] command
+end
+
+object Servo
+    implements Device
+    implements DeviceClock
+    implements IsochDevice
+    property DeviceInfo device_info [readonly,nolock]
+    function void halt() [urgent,nolock]
+    property ServoInfo servo_info [readonly,nolock]
+    property ServoMode mode [nolockread]
+    wire double[] position [readonly,nolock]
+    wire double[] velocity [readonly, nolock]
+    wire ServoState servo_state [readonly,nolock]
+    pipe ServoStateSensorData servo_state_sensor_data [readonly,nolock]
+    wire ServoCommand position_command [writeonly]
+    wire ServoCommand velocity_command [writeonly]
+    wire ServoCommand effort_command [writeonly]
+    function void trapezoidal_move(double[] target_pos, double[] target_vel, double[] vel, double[] accel)
+    property IsochInfo isoch_info [readonly,nolock]
+    property uint32 isoch_downsample [perclient]
+    wire DeviceTime device_clock_now [readonly,nolock]
+    function varvalue getf_signal(string signal_name)
+    function void setf_signal(string signal_name, varvalue value)
+    function varvalue getf_param(string param_name)
+    function void setf_param(string param_name, varvalue value)
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.signal.robdef

 * *Ordering differences only*

```diff
@@ -1,103 +1,103 @@
-service com.robotraconteur.signal
-
-stdver 0.10
-
-import com.robotraconteur.identifier
-import com.robotraconteur.datatype
-import com.robotraconteur.device
-import com.robotraconteur.units
-import com.robotraconteur.device
-import com.robotraconteur.device.isoch
-import com.robotraconteur.datetime
-
-using com.robotraconteur.identifier.Identifier
-using com.robotraconteur.datatype.DataType
-using com.robotraconteur.device.DeviceInfo
-using com.robotraconteur.device.DeviceClass
-using com.robotraconteur.units.SIUnit
-using com.robotraconteur.device.Device
-using com.robotraconteur.device.isoch.IsochDevice
-using com.robotraconteur.device.isoch.IsochInfo
-using com.robotraconteur.datetime.TimeSpec3
-
-enum SignalType
-    unknown = 0,
-    digital = 1,
-    analog,
-    digital_port,
-    analog_port,
-    vector3,
-    vector6,
-    wrench,
-    pose,
-    transform,
-    other
-end
-
-enum SignalAccessLevel
-    undefined = 0,
-    internal,
-    restricted,
-    readonly,
-    all
-end
-
-enum SignalDeviceStateFlags
-    unknown = 0,
-    ready = 0x1,
-    streaming = 0x2,
-    warning = 0x4,
-    error = 0x8,
-    fatal_error = 0x10,
-    calibrated = 0x20,
-    calibration_required = 0x40,
-    communication_failure = 0x80
-end
-
-struct SignalInfo
-    field Identifier signal_identifier
-    field DeviceClass signal_class
-    field SIUnit{list} units
-    field DataType data_type
-    field SignalType signal_type
-    field SignalAccessLevel access_level
-    field uint32[] address
-    field string user_description
-    field varvalue min_value
-    field varvalue max_value
-    field varvalue{string} extended
-end
-
-struct SignalDeviceState
-    field TimeSpec3 ts
-    field uint64 seqno
-    field uint32 signal_device_state_flags
-end
-
-struct SignalGroupInfo
-    field Identifier signal_group_identifier
-    field string description
-end
-
-object Signal
-    implements IsochDevice
-    property SignalInfo signal_info [readonly,nolock]
-    wire varvalue signal_value [readonly]
-    wire varvalue signal_command [writeonly]
-    wire double[] signal_value_vec [readonly]
-    wire double[] signal_command_vec [writeonly]
-    property IsochInfo isoch_info [readonly,nolock]
-    property uint32 isoch_downsample [perclient]
-end
-
-object SignalGroup
-    property SignalInfo{list} signal_info [readonly,nolock]
-    objref Signal{int32} signals
-end
-
-object SignalDevice
-    implements Device
-    property DeviceInfo device_info [readonly,nolock]
-    property SignalGroupInfo{list} signal_group_info [readonly,nolock]
-    objref SignalGroup{string} signal_groups
-end
+service com.robotraconteur.signal
+
+stdver 0.10
+
+import com.robotraconteur.identifier
+import com.robotraconteur.datatype
+import com.robotraconteur.device
+import com.robotraconteur.units
+import com.robotraconteur.device
+import com.robotraconteur.device.isoch
+import com.robotraconteur.datetime
+
+using com.robotraconteur.identifier.Identifier
+using com.robotraconteur.datatype.DataType
+using com.robotraconteur.device.DeviceInfo
+using com.robotraconteur.device.DeviceClass
+using com.robotraconteur.units.SIUnit
+using com.robotraconteur.device.Device
+using com.robotraconteur.device.isoch.IsochDevice
+using com.robotraconteur.device.isoch.IsochInfo
+using com.robotraconteur.datetime.TimeSpec3
+
+enum SignalType
+    unknown = 0,
+    digital = 1,
+    analog,
+    digital_port,
+    analog_port,
+    vector3,
+    vector6,
+    wrench,
+    pose,
+    transform,
+    other
+end
+
+enum SignalAccessLevel
+    undefined = 0,
+    internal,
+    restricted,
+    readonly,
+    all
+end
+
+enum SignalDeviceStateFlags
+    unknown = 0,
+    ready = 0x1,
+    streaming = 0x2,
+    warning = 0x4,
+    error = 0x8,
+    fatal_error = 0x10,
+    calibrated = 0x20,
+    calibration_required = 0x40,
+    communication_failure = 0x80
+end
+
+struct SignalInfo
+    field Identifier signal_identifier
+    field DeviceClass signal_class
+    field SIUnit{list} units
+    field DataType data_type
+    field SignalType signal_type
+    field SignalAccessLevel access_level
+    field uint32[] address
+    field string user_description
+    field varvalue min_value
+    field varvalue max_value
+    field varvalue{string} extended
+end
+
+struct SignalDeviceState
+    field TimeSpec3 ts
+    field uint64 seqno
+    field uint32 signal_device_state_flags
+end
+
+struct SignalGroupInfo
+    field Identifier signal_group_identifier
+    field string description
+end
+
+object Signal
+    implements IsochDevice
+    property SignalInfo signal_info [readonly,nolock]
+    wire varvalue signal_value [readonly]
+    wire varvalue signal_command [writeonly]
+    wire double[] signal_value_vec [readonly]
+    wire double[] signal_command_vec [writeonly]
+    property IsochInfo isoch_info [readonly,nolock]
+    property uint32 isoch_downsample [perclient]
+end
+
+object SignalGroup
+    property SignalInfo{list} signal_info [readonly,nolock]
+    objref Signal{int32} signals
+end
+
+object SignalDevice
+    implements Device
+    property DeviceInfo device_info [readonly,nolock]
+    property SignalGroupInfo{list} signal_group_info [readonly,nolock]
+    objref SignalGroup{string} signal_groups
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.units.robdef

 * *Ordering differences only*

```diff
@@ -1,8 +1,8 @@
-service com.robotraconteur.units
-
-stdver 0.10
-
-struct SIUnit
-    field string display_units
-    field string encoded_units
-end
+service com.robotraconteur.units
+
+stdver 0.10
+
+struct SIUnit
+    field string display_units
+    field string encoded_units
+end
```

## RobotRaconteurCompanion/StdRobDef/com.robotraconteur.uuid.robdef

 * *Ordering differences only*

```diff
@@ -1,7 +1,7 @@
-service com.robotraconteur.uuid
-
-stdver 0.10
-
-namedarray UUID
-    field uint8[16] uuid_bytes
-end
+service com.robotraconteur.uuid
+
+stdver 0.10
+
+namedarray UUID
+    field uint8[16] uuid_bytes
+end
```

## RobotRaconteurCompanion/Util/AttributesUtil.py

```diff
@@ -1,38 +1,67 @@
-import RobotRaconteur as RR
-RRN = RR.RobotRaconteurNode.s
-import numpy as np
-
-from .IdentifierUtil import IdentifierUtil
-
-class AttributesUtil(object):
-
-    def __init__(self, node = None, client_obj = None):
-        if node is None:
-            self._node = RRN
-        else:
-            self._node = node
-        self._client_obj = client_obj
-
-        self._ident_util = IdentifierUtil(self._node, self._client_obj)
-
-    def _try_add_identifier(self, o, name, id_):
-        if not self._ident_util.IsIdentifierAny(id_):
-            o[name] =  RR.VarValue(self._ident_util.IdentifierToString(id_),"string")
-            return True
-        return False
-
-    def _try_add_string(self, o, name, str_):
-        if str_ is not None and len(str_) > 0:
-            o[name] = RR.VarValue(str_,"string")
-            return True
-        return False        
-        
-    def GetDefaultServiceAttributesFromDeviceInfo(self, device_info):
-        o = dict()
-        self._try_add_identifier(o,"device", device_info.device)
-        self._try_add_identifier(o,"parent_device", device_info.parent_device)
-        self._try_add_identifier(o,"manufacturer", device_info.manufacturer)
-        self._try_add_identifier(o,"model", device_info.model)
-        self._try_add_string(o,"serial_number",device_info.serial_number)
-        self._try_add_string(o,"user_description",device_info.user_description)
+import RobotRaconteur as RR
+RRN = RR.RobotRaconteurNode.s
+import numpy as np
+
+from .IdentifierUtil import IdentifierUtil
+
+
+class AttributesUtil(object):
+    """  
+    Utility class to get the default attributes from a DeviceInfo structure. These attributes are
+    used to populate the default service attributes when registering a service
+    with a device.
+    
+    The following attributes are used:
+    
+    - device
+    - parent_device
+    - manufacturer
+    - model
+    - serial_number
+    - user_description
+
+    :param node: (optional) The Robot Raconteur node to use for parsing. Defaults to RobotRaconteurNode.s
+    :type node: RobotRaconteur.RobotRaconteurNode
+    :param client_obj: (optional) The client object to use for finding types. Defaults to None
+    :type client_obj: RobotRaconteur.ClientObject
+    """
+
+    def __init__(self, node = None, client_obj = None):
+        if node is None:
+            self._node = RRN
+        else:
+            self._node = node
+        self._client_obj = client_obj
+
+        self._ident_util = IdentifierUtil(self._node, self._client_obj)
+
+    def _try_add_identifier(self, o, name, id_):
+        if not self._ident_util.IsIdentifierAny(id_):
+            o[name] =  RR.VarValue(self._ident_util.IdentifierToString(id_),"string")
+            return True
+        return False
+
+    def _try_add_string(self, o, name, str_):
+        if str_ is not None and len(str_) > 0:
+            o[name] = RR.VarValue(str_,"string")
+            return True
+        return False        
+        
+    def GetDefaultServiceAttributesFromDeviceInfo(self, device_info):
+        """
+        Get the default service attributes from a DeviceInfo structure. These attributes are
+        used to populate the default service attributes when registering a service.
+
+        :param device_info: The device info structure
+        :type device_info: com.robotraconteur.DeviceInfo
+        :return: The default service attributes
+        :rtype: dict
+        """
+        o = dict()
+        self._try_add_identifier(o,"device", device_info.device)
+        self._try_add_identifier(o,"parent_device", device_info.parent_device)
+        self._try_add_identifier(o,"manufacturer", device_info.manufacturer)
+        self._try_add_identifier(o,"model", device_info.model)
+        self._try_add_string(o,"serial_number",device_info.serial_number)
+        self._try_add_string(o,"user_description",device_info.user_description)
         return o
```

## RobotRaconteurCompanion/Util/DateTimeUtil.py

```diff
@@ -1,57 +1,111 @@
-import RobotRaconteur as RR
-RRN = RR.RobotRaconteurNode.s
-import datetime
-import numpy as np
-import math
-
-class DateTimeUtil(object):
-
-    def __init__(self, node = None, client_obj = None):
-        if node is None:
-            self._node = RRN
-        else:
-            self._node = node
-        self._client_obj = client_obj
-
-        self._datetimeutc_dt = self._node.GetPodDType("com.robotraconteur.datetime.DateTimeUTC", self._client_obj)
-        self._datetimelocal = self._node.GetStructureType("com.robotraconteur.datetime.DateTimeLocal", self._client_obj)
-        self._timespec2_dt = self._node.GetPodDType("com.robotraconteur.datetime.TimeSpec2", self._client_obj)
-        self._timespec3_dt = self._node.GetNamedArrayDType("com.robotraconteur.datetime.TimeSpec3", self._client_obj)
-        self._devicetime_dt = self._node.GetPodDType("com.robotraconteur.device.clock.DeviceTime", self._client_obj)
-
-        self._datetime_const = self._node.GetConstants("com.robotraconteur.datetime")
-        self._clock_codes = self._datetime_const["ClockTypeCode"]
-
-    def UtcNow(self, device_info = None):        
-        now_dt = self._node.NowUTC()
-        now = (now_dt - datetime.datetime(1970,1,1,0,0,0,0)).total_seconds()
-        ret = np.zeros((1,),dtype=self._datetimeutc_dt)
-        ret[0]["seconds"] = int(math.floor(now))
-        ret[0]["nanoseconds"] = int((now % 1.0)*1e9)
-        ret[0]["clock_info"]["clock_type"] = self._clock_codes["default"]
-        if device_info is not None and device_info.device is not None:
-            ret[0]["clock_info"]["clock_uuid"] = device_info.device.uuid
-        return ret
-
-    def TimeSpec2Now(self, device_info = None):
-        now_ts = self._node.NowTimeSpec()
-        ret = np.zeros((1,),dtype=self._timespec2_dt)
-        ret[0]["seconds"] = now_ts.seconds
-        ret[0]["nanoseconds"] = now_ts.nanoseconds
-        ret[0]["clock_info"]["clock_type"] = self._clock_codes["default"]
-        if device_info is not None and device_info.device is not None:
-            ret[0]["clock_info"]["clock_uuid"] = device_info.device.uuid
-        return ret
-
-    def TimeSpec3Now(self):
-        now_ts = self._node.NowTimeSpec()
-        ret = np.zeros((1,),dtype=self._timespec3_dt)
-        ret[0]["microseconds"] = now_ts.seconds*1e6 + now_ts.nanoseconds*1e-3
-        return ret
-
-    def FillDeviceTime(self, device_info, seqno):
-        ret = np.zeros((1,),self._devicetime_dt)
-        ret[0]["device_seqno"] = seqno
-        ret[0]["device_ts"] = self.TimeSpec2Now(device_info)
-        ret[0]["device_utc"] = self.UtcNow(device_info)
+import RobotRaconteur as RR
+RRN = RR.RobotRaconteurNode.s
+import datetime
+import numpy as np
+import math
+
+class DateTimeUtil(object):
+    """
+    Utility class to populate Robot Raconteur time structures
+
+    :param node: (optional) The Robot Raconteur node to use for parsing. Defaults to RobotRaconteurNode.s
+    :type node: RobotRaconteur.RobotRaconteurNode
+    :param client_obj: (optional) The client object to use for finding types. Defaults to None
+    :type client_obj: RobotRaconteur.ClientObject
+    """
+
+    def __init__(self, node = None, client_obj = None):
+        if node is None:
+            self._node = RRN
+        else:
+            self._node = node
+        self._client_obj = client_obj
+
+        self._datetimeutc_dt = self._node.GetPodDType("com.robotraconteur.datetime.DateTimeUTC", self._client_obj)
+        self._datetimelocal = self._node.GetStructureType("com.robotraconteur.datetime.DateTimeLocal", self._client_obj)
+        self._timespec2_dt = self._node.GetPodDType("com.robotraconteur.datetime.TimeSpec2", self._client_obj)
+        self._timespec3_dt = self._node.GetNamedArrayDType("com.robotraconteur.datetime.TimeSpec3", self._client_obj)
+        self._devicetime_dt = self._node.GetPodDType("com.robotraconteur.device.clock.DeviceTime", self._client_obj)
+
+        self._datetime_const = self._node.GetConstants("com.robotraconteur.datetime")
+        self._clock_codes = self._datetime_const["ClockTypeCode"]
+
+    def UtcNow(self, device_info = None):
+        """
+        Get the current DateTimeUTC Time from the node
+
+        :param device_info: (optional) The device info structure to use for the clock UUID. Defaults to None
+        :type device_info: com.robotraconteur.device.DeviceInfo
+        :return: The current UTC time
+        :rtype: com.robotraconteur.datetime.DateTimeUTC
+        """
+        now_dt = self._node.NowUTC()
+        now = (now_dt - datetime.datetime(1970,1,1,0,0,0,0)).total_seconds()
+        ret = np.zeros((1,),dtype=self._datetimeutc_dt)
+        ret[0]["seconds"] = int(math.floor(now))
+        ret[0]["nanoseconds"] = int((now % 1.0)*1e9)
+        ret[0]["clock_info"]["clock_type"] = self._clock_codes["default"]
+        if device_info is not None and device_info.device is not None:
+            ret[0]["clock_info"]["clock_uuid"] = device_info.device.uuid
+        return ret
+
+    def TimeSpec2Now(self, device_info = None):
+        """
+        Get the current TimeSpec from the node, stored as TimeSpec2
+
+        TimeSpec is based on the performance counter, and is not guaranteed to be
+        synchronized between nodes or with the system real-time clock. It is expected
+        to be close to the system real-time clock, but may drift over time and is 
+        guaranteed to remain stable even if the system real-time clock is changed.
+
+        :param device_info: (optional) The device info structure to use for the clock UUID. Defaults to None
+        :type device_info: com.robotraconteur.device.DeviceInfo
+        :return: The current TimeSpec as TimeSpec2
+        :rtype: com.robotraconteur.datetime.TimeSpec2
+        """
+        now_ts = self._node.NowTimeSpec()
+        ret = np.zeros((1,),dtype=self._timespec2_dt)
+        ret[0]["seconds"] = now_ts.seconds
+        ret[0]["nanoseconds"] = now_ts.nanoseconds
+        ret[0]["clock_info"]["clock_type"] = self._clock_codes["default"]
+        if device_info is not None and device_info.device is not None:
+            ret[0]["clock_info"]["clock_uuid"] = device_info.device.uuid
+        return ret
+
+    def TimeSpec3Now(self):
+        """
+        Get the current TimeSpec from the node, stored as TimeSpec3
+  
+        The TimeSpec3 is a 64-bit integer representing microseconds since the epoch
+        of the real-time clock. It is intended to be a compact representation of the
+        current time that can be used for timestamping data.
+
+        TimeSpec is based on the performance counter, and is not guaranteed to be
+        synchronized between nodes or with the system real-time clock. It is expected
+        to be close to the system real-time clock, but may drift over time and is 
+        guaranteed to remain stable even if the system real-time clock is changed.
+
+        :return: The current TimeSpec as TimeSpec3
+        :rtype: com.robotraconteur.datetime.TimeSpec3
+        """
+        now_ts = self._node.NowTimeSpec()
+        ret = np.zeros((1,),dtype=self._timespec3_dt)
+        ret[0]["microseconds"] = now_ts.seconds*1e6 + now_ts.nanoseconds*1e-3
+        return ret
+
+    def FillDeviceTime(self, device_info, seqno):
+        """
+        Fill a DeviceTime structure with the current time
+
+        :param device_info: The device info structure to use for the clock UUID
+        :type device_info: com.robotraconteur.device.DeviceInfo
+        :param seqno: The sequence number to use
+        :type seqno: int
+        :return: The DeviceTime structure
+        :rtype: com.robotraconteur.device.clock.DeviceTime
+        """
+        ret = np.zeros((1,),self._devicetime_dt)
+        ret[0]["device_seqno"] = seqno
+        ret[0]["device_ts"] = self.TimeSpec2Now(device_info)
+        ret[0]["device_utc"] = self.UtcNow(device_info)
         return ret
```

## RobotRaconteurCompanion/Util/GeometryUtil.py

```diff
@@ -1,331 +1,725 @@
-import RobotRaconteur as RR
-RRN = RR.RobotRaconteurNode.s
-import numpy as np
-import general_robotics_toolbox as rox
-from .IdentifierUtil import IdentifierUtil
-
-def _name_from_identifier(id_):
-    if id_ is None:
-        return None
-    return id_.name
-
-class GeometryUtil(object):
-    def __init__(self, node = None, client_obj = None):
-        if node is None:
-            self._node = RRN
-        else:
-            self._node = node
-        self._client_obj = client_obj
-
-        self._vector2_type = self._create_dtypes("Vector2")
-        self._vector3_type = self._create_dtypes("Vector3")
-        self._vector6_type = self._create_dtypes("Vector6")
-        self._point2d_type = self._create_dtypes("Point2D")
-        self._point_type = self._create_dtypes("Point")
-        self._size2d_type = self._create_dtypes("Size2D")
-        self._size_type = self._create_dtypes("Size")
-        self._quaternion_type = self._create_dtypes("Quaternion")
-        self._transform_type = self._create_dtypes("Transform")
-        self._named_transform_type = self._create_structtypes("NamedTransform")
-        self._pose_type = self._create_dtypes("Pose")
-        self._named_pose_type = self._create_structtypes("NamedPose")
-        self._spatial_velocity_type = self._create_dtypes("SpatialVelocity")
-        self._spatial_acceleration_type = self._create_dtypes("SpatialAcceleration")
-        self._wrench_type = self._create_dtypes("Wrench")
-
-        self._ident_util = IdentifierUtil(self._node, self._client_obj)
-
-    def _create_dtypes(self, type_name):
-        try:
-            d_type = self._node.GetNamedArrayDType(f"com.robotraconteur.geometry.{type_name}",self._client_obj)
-        except:
-            d_type = None
-        try:
-            f_type = self._node.GetNamedArrayDType(f"com.robotraconteur.geometryf.{type_name}",self._client_obj)
-        except:
-            f_type = None
-        try:
-            i_type = self._node.GetNamedArrayDType(f"com.robotraconteur.geometryi.{type_name}",self._client_obj)
-        except:
-            i_type = None
-
-        assert any((d_type, f_type, i_type)), "No geometry service types registered"
-        return d_type, f_type, i_type
-
-
-
-
-    def _create_structtypes(self, type_name):
-        try:
-            d_type = self._node.GetStructureType(f"com.robotraconteur.geometry.{type_name}",self._client_obj)
-        except:
-            d_type = None
-        try:
-            f_type = self._node.GetStructureType(f"com.robotraconteur.geometryf.{type_name}",self._client_obj)
-        except:
-            f_type = None
-        try:
-            i_type = self._node.GetStructureType(f"com.robotraconteur.geometryi.{type_name}",self._client_obj)
-        except:
-            i_type = None
-        
-        assert any((d_type, f_type, i_type)), "No geometry service types registered"
-        return d_type, f_type, i_type
-
-    def _create_return_np(self, rr_dtypes, dtype):
-        if dtype == np.float64:
-            assert rr_dtypes[0], "com.robotraconteur.geometry not registered"
-            return np.zeros((1,),dtype=rr_dtypes[0])
-        elif dtype == np.float32:
-            assert rr_dtypes[1], "com.robotraconteur.geometryf not registered"
-            return np.zeros((1,),dtype=rr_dtypes[1])
-        elif dtype == np.int32:
-            assert rr_dtypes[2], "com.robotraconteur.geometryi not registered"
-            return np.zeros((1,),dtype=rr_dtypes[2])
-        else:
-            assert False, "Invalid dtype"
-
-    def _create_return_struct(self, rr_struct_types, dtype):
-        if dtype == np.float64:
-            assert rr_struct_types[0], "com.robotraconteur.geometry not registered"
-            return rr_struct_types[0]()
-        elif dtype == np.float32:
-            assert rr_struct_types[1], "com.robotraconteur.geometryf not registered"
-            return rr_struct_types[1]()
-        elif dtype == np.int32:
-            assert rr_struct_types[2], "com.robotraconteur.geometryi not registered"
-            return rr_struct_types[2]()
-        else:
-            assert False, "Invalid dtype"
-
-    def xy_to_vector2(self, xy, dtype=np.float64):
-        ret = self._create_return_np(self._vector2_type, dtype)
-        ret[0]["x"] = xy[0]
-        ret[0]["y"] = xy[1]
-        return ret
-
-    def vector2_to_xy(self, rr_vector2):
-        return np.array([rr_vector2[0]["x"], rr_vector2[0]["y"]])
-
-    def xyz_to_vector3(self, xyz, dtype=np.float64):
-        ret = self._create_return_np(self._vector3_type, dtype)
-        ret[0]["x"] = xyz[0]
-        ret[0]["y"] = xyz[1]
-        ret[0]["z"] = xyz[2]
-        return ret
-
-    def vector3_to_xyz(self, rr_vector3):
-        return np.array([rr_vector3[0]["x"], rr_vector3[0]["y"], rr_vector3[0]["z"]])
-
-    def abgxyz_to_vector6(self, abgxyz, dtype=np.float64):
-        ret = self._create_return_np(self._vector6_type, dtype)
-        ret[0]["alpha"] = abgxyz[0]
-        ret[0]["beta"] = abgxyz[1]
-        ret[0]["gamma"] = abgxyz[2]
-        ret[0]["x"] = abgxyz[3]
-        ret[0]["y"] = abgxyz[4]
-        ret[0]["z"] = abgxyz[5]
-        return ret
-
-    def vector6_to_abgxyz(self, rr_vector6):
-        return np.array([rr_vector6[0]["alpha"], rr_vector6[0]["beta"], rr_vector6[0]["gamma"], \
-            rr_vector6[0]["x"], rr_vector6[0]["y"], rr_vector6[0]["z"]])
-
-    def xy_to_point2d(self, xy, dtype=np.float64):
-        ret = self._create_return_np(self._point2d_type, dtype)
-        ret[0]["x"] = xy[0]
-        ret[0]["y"] = xy[1]
-        return ret
-
-    def point2d_to_xy(self, rr_point2d):
-        return np.array([rr_point2d[0]["x"], rr_point2d[0]["y"]])
-
-    def xyz_to_point(self, xyz, dtype=np.float64):
-        ret = self._create_return_np(self._point_type, dtype)
-        ret[0]["x"] = xyz[0]
-        ret[0]["y"] = xyz[1]
-        ret[0]["z"] = xyz[2]
-        return ret
-
-    def point_to_xyz(self, rr_point):
-        return np.array([rr_point[0]["x"], rr_point[0]["y"], rr_point[0]["z"]])
-
-
-    def wh_to_size2d(self, wh, dtype=np.float64):
-        ret = self._create_return_np(self._size2d_type, dtype)
-        ret[0]["width"] = wh[0]
-        ret[0]["height"] = wh[1]
-        return ret
-
-    def size2d_to_wh(self, rr_size2d):
-        return np.array([rr_size2d[0]["width"], rr_size2d[0]["height"]])
-
-    def whd_to_size(self, whd, dtype=np.float64):
-        ret = self._create_return_np(self._size_type, dtype)
-        ret[0]["width"] = whd[0]
-        ret[0]["height"] = whd[1]
-        ret[0]["depth"] = whd[2]
-        return ret
-
-    def size_to_whd(self, rr_size):
-        return np.array([rr_size[0]["width"], rr_size[0]["height"], rr_size[0]["depth"]])
-
-    def q_to_quaternion(self, q, dtype=np.float64):
-        ret = self._create_return_np(self._quaternion_type, dtype)
-        ret[0]["w"] = q[0]
-        ret[0]["x"] = q[1]
-        ret[0]["y"] = q[2]
-        ret[0]["z"] = q[3]
-        return ret
-
-    def quaternion_to_q(self, rr_quaternion):
-        return np.array([rr_quaternion[0]["w"],rr_quaternion[0]["x"],rr_quaternion[0]["y"],rr_quaternion[0]["z"]])
-
-    def R_to_quaternion(self, R, dtype=np.float64):
-        return self.q_to_quaternion(rox.R2q(R), dtype)
-
-    def quaternion_to_R(self, rr_quaternion):
-        return rox.q2R(self.quaternion_to_q(rr_quaternion))
-
-    def rpy_to_quaternion(self, rpy, dtype=np.float64):
-        return self.q_to_quaternion(rox.R2q(rox.rpy2R(rpy)), dtype)
-
-    def quaternion_to_rpy(self, rr_quaternion):
-        return rox.R2rpy(rox.q2R(self.quaternion_to_q(rr_quaternion)))
-
-    def rox_transform_to_transform(self, rox_transform, dtype=np.float64):
-        ret = self._create_return_np(self._transform_type, dtype)
-        ret[0]["rotation"] = self.R_to_quaternion(rox_transform.R)
-        ret[0]["translation"] = self.xyz_to_vector3(rox_transform.p)
-        return ret
-
-    def transform_to_rox_transform(self, rr_transform):
-        R = self.quaternion_to_R(rr_transform["rotation"])
-        p = self.vector3_to_xyz(rr_transform["translation"])
-        return rox.Transform(R,p)
-
-    def _xyz_rpy_to_rox_transform(self, xyz,rpy,parent_frame_id=None,child_frame_id=None):
-        p = xyz
-        R = rox.rpy2R(rpy)
-        return rox.Transform(R,p,parent_frame_id,child_frame_id)
-
-    def _rox_transform_to_xyz_rpy(self, rox_transform):
-        R = rox_transform.R
-        p = rox_transform.p
-        return p, rox.R2rpy(R)
-
-    def _rox_transform_to_xyz_rpy_named(self, rox_transform):
-        R = rox_transform.R
-        p = rox_transform.p
-        parent_frame_id = rox_transform.parent_frame_id
-        child_frame_id = rox_transform.child_frame_id
-        return p, rox.R2rpy(R), parent_frame_id, child_frame_id
-
-    def xyz_rpy_to_transform(self, xyz, rpy, dtype=np.float64):
-        return self.rox_transform_to_transform(self._xyz_rpy_to_rox_transform(xyz,rpy),dtype)
-
-    def transform_to_xyz_rpy(self, transform):
-        return self._rox_transform_to_xyz_rpy(self.transform_to_rox_transform(transform))
-
-    def rox_transform_to_named_transform(self, rox_transform, dtype=np.float64):
-        ret = self._create_return_struct(self._named_transform_type, dtype)
-        ret.transform = self.rox_transform_to_transform(rox_transform)
-        ret.child_frame = self._ident_util.CreateIdentifierFromName(rox_transform.child_frame_id)
-        ret.parent_frame = self._ident_util.CreateIdentifierFromName(rox_transform.parent_frame_id)
-        return ret
-
-    def named_transform_to_rox_transform(self, rr_named_transform):
-        R = self.quaternion_to_R(rr_named_transform.transform["rotation"])
-        p = self.vector3_to_xyz(rr_named_transform.transform["translation"])
-        return rox.Transform(R,p, _name_from_identifier(rr_named_transform.parent_frame), \
-            _name_from_identifier(rr_named_transform.child_frame))
-
-    def xyz_rpy_to_named_transform(self, xyz, rpy, parent_frame_id, child_frame_id, dtype=np.float64):
-        return self.rox_transform_to_named_transform(self._xyz_rpy_to_rox_transform(xyz,rpy,parent_frame_id,child_frame_id),dtype)
-
-    def named_transform_to_xyz_rpy(self, transform):
-        return self._rox_transform_to_xyz_rpy_named(self.named_transform_to_rox_transform(transform))
-
-    def rox_transform_to_pose(self, rox_transform, dtype=np.float64):
-        ret = self._create_return_np(self._pose_type, dtype)
-        ret[0]["orientation"] = self.R_to_quaternion(rox_transform.R)
-        ret[0]["position"] = self.xyz_to_point(rox_transform.p)
-        return ret
-
-    def pose_to_rox_transform(self, rr_pose):
-        R = self.quaternion_to_R(rr_pose["orientation"])
-        p = self.vector3_to_xyz(rr_pose["position"])
-        return rox.Transform(R,p)
-
-    def xyz_rpy_to_pose(self, xyz, rpy, dtype=np.float64):
-        return self.rox_transform_to_pose(self._xyz_rpy_to_rox_transform(xyz,rpy),dtype)
-
-    def pose_to_xyz_rpy(self, transform):
-        return self._rox_transform_to_xyz_rpy(self.pose_to_rox_transform(transform))
-
-    def rox_transform_to_named_pose(self, rox_transform, dtype=np.float64):
-        ret = self._create_return_struct(self._named_pose_type, dtype)
-        ret.pose = self.rox_transform_to_pose(rox_transform)
-        ret.frame = self._ident_util.CreateIdentifierFromName(rox_transform.child_frame_id)
-        ret.parent_frame = self._ident_util.CreateIdentifierFromName(rox_transform.parent_frame_id)
-        return ret
-
-    def named_pose_to_rox_transform(self, rr_named_pose):
-        R = self.quaternion_to_R(rr_named_pose.pose["orientation"])
-        p = self.vector3_to_xyz(rr_named_pose.pose["position"])
-        return rox.Transform(R,p,_name_from_identifier(rr_named_pose.parent_frame), \
-            _name_from_identifier(rr_named_pose.frame))
-
-    def xyz_rpy_to_named_pose(self, xyz, rpy, parent_frame_id, child_frame_id, dtype=np.float64):
-        return self.rox_transform_to_named_pose(self._xyz_rpy_to_rox_transform(xyz,rpy,parent_frame_id,child_frame_id),dtype)
-
-    def named_pose_to_xyz_rpy(self, transform):
-        return self._rox_transform_to_xyz_rpy_named(self.named_pose_to_rox_transform(transform))
-
-    def array_to_spatial_velocity(self, spatial_velocity, dtype=np.float64):
-        ret = self._create_return_np(self._spatial_velocity_type, dtype)
-        ret[0]["angular"]["x"] = spatial_velocity[0]
-        ret[0]["angular"]["y"] = spatial_velocity[1]
-        ret[0]["angular"]["z"] = spatial_velocity[2]
-        ret[0]["linear"]["x"] = spatial_velocity[3]
-        ret[0]["linear"]["y"] = spatial_velocity[4]
-        ret[0]["linear"]["z"] = spatial_velocity[5]
-        return ret
-
-    def spatial_velocity_to_array(self, rr_spatial_velocity):
-        return np.array([rr_spatial_velocity[0]["angular"]["x"], rr_spatial_velocity[0]["angular"]["y"],\
-            rr_spatial_velocity[0]["angular"]["z"], rr_spatial_velocity[0]["linear"]["x"], \
-            rr_spatial_velocity[0]["linear"]["y"], rr_spatial_velocity[0]["linear"]["z"]])
-
-    def array_to_spatial_acceleration(self, spatial_acceleration, dtype=np.float64):
-        ret = self._create_return_np(self._spatial_acceleration_type, dtype)
-        ret[0]["angular"]["x"] = spatial_acceleration[0]
-        ret[0]["angular"]["y"] = spatial_acceleration[1]
-        ret[0]["angular"]["z"] = spatial_acceleration[2]
-        ret[0]["linear"]["x"] = spatial_acceleration[3]
-        ret[0]["linear"]["y"] = spatial_acceleration[4]
-        ret[0]["linear"]["z"] = spatial_acceleration[5]
-        return ret
-
-    def spatial_acceleration_to_array(self, rr_spatial_acceleration):
-        return np.array([rr_spatial_acceleration[0]["angular"]["x"], rr_spatial_acceleration[0]["angular"]["y"],\
-            rr_spatial_acceleration[0]["angular"]["z"], rr_spatial_acceleration[0]["linear"]["x"], \
-            rr_spatial_acceleration[0]["linear"]["y"], rr_spatial_acceleration[0]["linear"]["z"]])
-
-    
-    def array_to_wrench(self, wrench, dtype=np.float64):
-        ret = self._create_return_np(self._wrench_type, dtype)
-        ret[0]["torque"]["x"] = wrench[0]
-        ret[0]["torque"]["y"] = wrench[1]
-        ret[0]["torque"]["z"] = wrench[2]
-        ret[0]["force"]["x"] = wrench[3]
-        ret[0]["force"]["y"] = wrench[4]
-        ret[0]["force"]["z"] = wrench[5]
-        return ret
-
-    def wrench_to_array(self, rr_wrench):
-        return np.array([rr_wrench[0]["torque"]["x"], rr_wrench[0]["torque"]["y"],\
-            rr_wrench[0]["torque"]["z"], rr_wrench[0]["force"]["x"], \
-            rr_wrench[0]["force"]["y"], rr_wrench[0]["force"]["z"]])
-
-    
+import RobotRaconteur as RR
+RRN = RR.RobotRaconteurNode.s
+import numpy as np
+import general_robotics_toolbox as rox
+from .IdentifierUtil import IdentifierUtil
+
+def _name_from_identifier(id_):
+    if id_ is None:
+        return None
+    return id_.name
+
+"""
+Utility class to convert between Robot Raconteur types and Python types. Python numpy or general_robotics_toolbox
+types are used when applicable.
+
+:param node: (optional) The Robot Raconteur node to use for parsing. Defaults to RobotRaconteurNode.s
+:type node: RobotRaconteur.RobotRaconteurNode
+:param client_obj: (optional) The client object to use for finding types. Defaults to None
+:type client_obj: RobotRaconteur.ClientObject
+"""
+class GeometryUtil(object):
+    def __init__(self, node = None, client_obj = None):
+        if node is None:
+            self._node = RRN
+        else:
+            self._node = node
+        self._client_obj = client_obj
+
+        self._vector2_type = self._create_dtypes("Vector2")
+        self._vector3_type = self._create_dtypes("Vector3")
+        self._vector6_type = self._create_dtypes("Vector6")
+        self._point2d_type = self._create_dtypes("Point2D")
+        self._point_type = self._create_dtypes("Point")
+        self._size2d_type = self._create_dtypes("Size2D")
+        self._size_type = self._create_dtypes("Size")
+        self._quaternion_type = self._create_dtypes("Quaternion")
+        self._transform_type = self._create_dtypes("Transform")
+        self._named_transform_type = self._create_structtypes("NamedTransform")
+        self._pose_type = self._create_dtypes("Pose")
+        self._named_pose_type = self._create_structtypes("NamedPose")
+        self._spatial_velocity_type = self._create_dtypes("SpatialVelocity")
+        self._spatial_acceleration_type = self._create_dtypes("SpatialAcceleration")
+        self._wrench_type = self._create_dtypes("Wrench")
+
+        self._ident_util = IdentifierUtil(self._node, self._client_obj)
+
+    def _create_dtypes(self, type_name):
+        try:
+            d_type = self._node.GetNamedArrayDType(f"com.robotraconteur.geometry.{type_name}",self._client_obj)
+        except:
+            d_type = None
+        try:
+            f_type = self._node.GetNamedArrayDType(f"com.robotraconteur.geometryf.{type_name}",self._client_obj)
+        except:
+            f_type = None
+        try:
+            i_type = self._node.GetNamedArrayDType(f"com.robotraconteur.geometryi.{type_name}",self._client_obj)
+        except:
+            i_type = None
+
+        assert any((d_type, f_type, i_type)), "No geometry service types registered"
+        return d_type, f_type, i_type
+
+
+
+
+    def _create_structtypes(self, type_name):
+        try:
+            d_type = self._node.GetStructureType(f"com.robotraconteur.geometry.{type_name}",self._client_obj)
+        except:
+            d_type = None
+        try:
+            f_type = self._node.GetStructureType(f"com.robotraconteur.geometryf.{type_name}",self._client_obj)
+        except:
+            f_type = None
+        try:
+            i_type = self._node.GetStructureType(f"com.robotraconteur.geometryi.{type_name}",self._client_obj)
+        except:
+            i_type = None
+        
+        assert any((d_type, f_type, i_type)), "No geometry service types registered"
+        return d_type, f_type, i_type
+
+    def _create_return_np(self, rr_dtypes, dtype):
+        if dtype == np.float64:
+            assert rr_dtypes[0], "com.robotraconteur.geometry not registered"
+            return np.zeros((1,),dtype=rr_dtypes[0])
+        elif dtype == np.float32:
+            assert rr_dtypes[1], "com.robotraconteur.geometryf not registered"
+            return np.zeros((1,),dtype=rr_dtypes[1])
+        elif dtype == np.int32:
+            assert rr_dtypes[2], "com.robotraconteur.geometryi not registered"
+            return np.zeros((1,),dtype=rr_dtypes[2])
+        else:
+            assert False, "Invalid dtype"
+
+    def _create_return_struct(self, rr_struct_types, dtype):
+        if dtype == np.float64:
+            assert rr_struct_types[0], "com.robotraconteur.geometry not registered"
+            return rr_struct_types[0]()
+        elif dtype == np.float32:
+            assert rr_struct_types[1], "com.robotraconteur.geometryf not registered"
+            return rr_struct_types[1]()
+        elif dtype == np.int32:
+            assert rr_struct_types[2], "com.robotraconteur.geometryi not registered"
+            return rr_struct_types[2]()
+        else:
+            assert False, "Invalid dtype"
+
+    def xy_to_vector2(self, xy, dtype=np.float64):
+        """
+        Converts a 2 element vector to a Robot Raconteur Vector2 type
+
+        :param xy: The 2D vector
+        :type xy: numpy.ndarray
+        :param dtype: The numpy dtype of the vector. Must be float64, float32, or int32. Defaults to float64
+        :type dtype: com.robotraconteur.geometry.Vector2
+        """
+        ret = self._create_return_np(self._vector2_type, dtype)
+        ret[0]["x"] = xy[0]
+        ret[0]["y"] = xy[1]
+        return ret
+
+    def vector2_to_xy(self, rr_vector2):
+        """
+        Converts a Robot Raconteur Vector2 to a 2 element vector
+
+        :param rr_vector2: The Robot Raconteur Vector2 
+        :type rr_vector2: com.robotraconteur.geometry.Vector2
+        :return: The 2D vector
+        :rtype: numpy.ndarray
+        """
+        return np.array([rr_vector2[0]["x"], rr_vector2[0]["y"]])
+
+    def xyz_to_vector3(self, xyz, dtype=np.float64):
+        ret = self._create_return_np(self._vector3_type, dtype)
+        ret[0]["x"] = xyz[0]
+        ret[0]["y"] = xyz[1]
+        ret[0]["z"] = xyz[2]
+        return ret
+
+    def vector3_to_xyz(self, rr_vector3):
+        """"
+        Converts a Robot Raconteur Vector3 to a 3 element vector
+
+        :param rr_vector3: The Robot Raconteur Vector3
+        :type rr_vector3: com.robotraconteur.geometry.Vector3
+        :return: The 3D vector
+        :rtype: numpy.ndarray
+        """
+        return np.array([rr_vector3[0]["x"], rr_vector3[0]["y"], rr_vector3[0]["z"]])
+
+    def abgxyz_to_vector6(self, abgxyz, dtype=np.float64):
+        """
+        Converts a 6 element vector to a Robot Raconteur Vector6
+
+        :param abgxyz: The 6D vector
+        :type abgxyz: numpy.ndarray
+        :param dtype: The numpy dtype of the vector. Must be float64, float32, or int32. Defaults to float64
+        :type dtype: com.robotraconteur.geometry.Vector6
+        :return: The Robot Raconteur Vector6
+        :rtype: com.robotraconteur.geometry.Vector6
+        """
+        ret = self._create_return_np(self._vector6_type, dtype)
+        ret[0]["alpha"] = abgxyz[0]
+        ret[0]["beta"] = abgxyz[1]
+        ret[0]["gamma"] = abgxyz[2]
+        ret[0]["x"] = abgxyz[3]
+        ret[0]["y"] = abgxyz[4]
+        ret[0]["z"] = abgxyz[5]
+        return ret
+
+    def vector6_to_abgxyz(self, rr_vector6):
+        """
+        Converts a Robot Raconteur Vector6 to a 6 element vector
+
+        :param rr_vector6: The Robot Raconteur Vector6
+        :type rr_vector6: com.robotraconteur.geometry.Vector6
+        :return: The 6D vector
+        :rtype: numpy.ndarray
+        """
+        return np.array([rr_vector6[0]["alpha"], rr_vector6[0]["beta"], rr_vector6[0]["gamma"], \
+            rr_vector6[0]["x"], rr_vector6[0]["y"], rr_vector6[0]["z"]])
+
+    def xy_to_point2d(self, xy, dtype=np.float64):
+        """
+        Converts a 2 element vector to a Robot Raconteur Point2D
+
+        :param xy: The 2 element vector
+        :type xy: numpy.ndarray
+        :param dtype: The numpy dtype of the vector. Must be float64, float32, or int32. Defaults to float64
+        :type dtype: com.robotraconteur.geometry.Point2D
+        """
+        ret = self._create_return_np(self._point2d_type, dtype)
+        ret[0]["x"] = xy[0]
+        ret[0]["y"] = xy[1]
+        return ret
+
+    def point2d_to_xy(self, rr_point2d):
+        """
+        Converts a Robot Raconteur Point2D to a 2 element vector
+
+        :param rr_point2d: The Robot Raconteur Point2D
+        :type rr_point2d: com.robotraconteur.geometry.Point2D
+        :return: The 2D vector
+        :rtype: numpy.ndarray
+        """
+
+        return np.array([rr_point2d[0]["x"], rr_point2d[0]["y"]])
+
+    def xyz_to_point(self, xyz, dtype=np.float64):
+        """
+        Converts a 3 element vector to a Robot Raconteur Point
+
+        :param xyz: The 3 element vector
+        :type xyz: numpy.ndarray
+        :param dtype: The numpy dtype of the vector. Must be float64, float32, or int32. Defaults to float64
+        :type dtype: com.robotraconteur.geometry.Point
+        :return: The Robot Raconteur Point
+        :rtype: com.robotraconteur.geometry.Point
+        """
+        ret = self._create_return_np(self._point_type, dtype)
+        ret[0]["x"] = xyz[0]
+        ret[0]["y"] = xyz[1]
+        ret[0]["z"] = xyz[2]
+        return ret
+
+    def point_to_xyz(self, rr_point):
+        """
+        Converts a Robot Raconteur Point to a 3 element vector
+
+        :param rr_point: The Robot Raconteur Point
+        :type rr_point: com.robotraconteur.geometry.Point
+        :return: The 3 element vector
+        :rtype: numpy.ndarray
+        """
+        return np.array([rr_point[0]["x"], rr_point[0]["y"], rr_point[0]["z"]])
+
+
+    def wh_to_size2d(self, wh, dtype=np.float64):
+        """
+        Converts a 2 element vector to a Robot Raconteur Size2D
+
+        :param wh: The 2 element vector
+        :type wh: numpy.ndarray
+        :param dtype: The numpy dtype of the vector. Must be float64, float32, or int32. Defaults to float64
+        :type dtype: com.robotraconteur.geometry.Size2D
+        :return: The Robot Raconteur Size2D
+        :rtype: com.robotraconteur.geometry.Size2D
+        """
+        ret = self._create_return_np(self._size2d_type, dtype)
+        ret[0]["width"] = wh[0]
+        ret[0]["height"] = wh[1]
+        return ret
+
+    def size2d_to_wh(self, rr_size2d):
+        """
+        Converts a Robot Raconteur Size2D to a 2 element vector
+
+        :param rr_size2d: The Robot Raconteur Size2D
+        :type rr_size2d: com.robotraconteur.geometry.Size2D
+        :return: The 2 element vector
+        :rtype: numpy.ndarray
+        """
+        return np.array([rr_size2d[0]["width"], rr_size2d[0]["height"]])
+
+    def whd_to_size(self, whd, dtype=np.float64):
+        """
+        Converts a 3 element vector to a Robot Raconteur Size
+
+        :param whd: The 3 element vector
+        :type whd: numpy.ndarray
+        :param dtype: The numpy dtype of the vector. Must be float64, float32, or int32. Defaults to float64
+        :type dtype: com.robotraconteur.geometry.Size
+        :return: The Robot Raconteur Size
+        :rtype: com.robotraconteur.geometry.Size
+        """
+        ret = self._create_return_np(self._size_type, dtype)
+        ret[0]["width"] = whd[0]
+        ret[0]["height"] = whd[1]
+        ret[0]["depth"] = whd[2]
+        return ret
+
+    def size_to_whd(self, rr_size):
+        """
+        Converts a Robot Raconteur Size to a 3 element vector
+
+        :param rr_size: The Robot Raconteur Size
+        :type rr_size: com.robotraconteur.geometry.Size
+        :return: The 3 element vector
+        :rtype: numpy.ndarray
+        """
+        return np.array([rr_size[0]["width"], rr_size[0]["height"], rr_size[0]["depth"]])
+
+    def q_to_quaternion(self, q, dtype=np.float64):
+        """
+        Converts a 4 element vector to a Robot Raconteur Quaternion. The order of the elements is [w,x,y,z]
+
+        :param q: The 4 element vector
+        :type q: numpy.ndarray
+        :param dtype: The numpy dtype of the vector. Must be float64, float32, or int32. Defaults to float64
+        :type dtype: com.robotraconteur.geometry.Quaternion
+        :return: The Robot Raconteur Quaternion
+        :rtype: com.robotraconteur.geometry.Quaternion
+        """
+        ret = self._create_return_np(self._quaternion_type, dtype)
+        ret[0]["w"] = q[0]
+        ret[0]["x"] = q[1]
+        ret[0]["y"] = q[2]
+        ret[0]["z"] = q[3]
+        return ret
+
+    def quaternion_to_q(self, rr_quaternion):
+        """
+        Converts a Robot Raconteur Quaternion to a 4 element vector. The order of the elements is [w,x,y,z]
+
+        :param rr_quaternion: The Robot Raconteur Quaternion
+        :type rr_quaternion: com.robotraconteur.geometry.Quaternion
+        :return: The 4 element vector
+        :rtype: numpy.ndarray
+        """
+        return np.array([rr_quaternion[0]["w"],rr_quaternion[0]["x"],rr_quaternion[0]["y"],rr_quaternion[0]["z"]])
+
+    def R_to_quaternion(self, R, dtype=np.float64):
+        """
+        Converts a 3x3 rotation matrix to a Robot Raconteur Quaternion
+
+        :param R: The 3x3 rotation matrix
+        :type R: numpy.ndarray
+        :param dtype: The numpy dtype of the vector. Must be float64, float32, or int32. Defaults to float64
+        :type dtype: com.robotraconteur.geometry.Quaternion
+        :return: The Robot Raconteur Quaternion
+        :rtype: com.robotraconteur.geometry.Quaternion
+        """
+        return self.q_to_quaternion(rox.R2q(R), dtype)
+
+    def quaternion_to_R(self, rr_quaternion):
+        """
+        Converts a Robot Raconteur Quaternion to a 3x3 rotation matrix
+
+        :param rr_quaternion: The Robot Raconteur Quaternion
+        :type rr_quaternion: com.robotraconteur.geometry.Quaternion
+        :return: The 3x3 rotation matrix
+        :rtype: numpy.ndarray
+        """
+        return rox.q2R(self.quaternion_to_q(rr_quaternion))
+
+    def rpy_to_quaternion(self, rpy, dtype=np.float64):
+        """
+        Convert a roll-pitch-yaw vector in radians to a Robot Raconteur Quaternion
+
+        :param rpy: The roll-pitch-yaw vector
+        :type rpy: numpy.ndarray
+        :param dtype: The numpy dtype of the vector. Must be float64, float32, or int32. Defaults to float64
+        :type dtype: com.robotraconteur.geometry.Quaternion
+        :return: The Robot Raconteur Quaternion
+        :rtype: com.robotraconteur.geometry.Quaternion
+        """
+        return self.q_to_quaternion(rox.R2q(rox.rpy2R(rpy)), dtype)
+
+    def quaternion_to_rpy(self, rr_quaternion):
+        """
+        Convert a Robot Raconteur Quaternion to a roll-pitch-yaw vector in radians
+
+        :param rr_quaternion: The Robot Raconteur Quaternion
+        :type rr_quaternion: com.robotraconteur.geometry.Quaternion
+        :return: The roll-pitch-yaw vector
+        :rtype: numpy.ndarray
+        """
+        return rox.R2rpy(rox.q2R(self.quaternion_to_q(rr_quaternion)))
+
+    def rox_transform_to_transform(self, rox_transform, dtype=np.float64):
+        """
+        Converts a general_robotics_toolbox Transform to a Robot Raconteur Transform
+
+        :param rox_transform: The general_robotics_toolbox Transform
+        :type rox_transform: general_robotics_toolbox.Transform
+        :param dtype: The numpy dtype of the transform. Must be float64, float32, or int32. Defaults to float64
+        :type dtype: com.robotraconteur.geometry.Transform
+        :return: The Robot Raconteur Transform
+        """
+        ret = self._create_return_np(self._transform_type, dtype)
+        ret[0]["rotation"] = self.R_to_quaternion(rox_transform.R)
+        ret[0]["translation"] = self.xyz_to_vector3(rox_transform.p)
+        return ret
+
+    def transform_to_rox_transform(self, rr_transform):
+        """
+        Converts a Robot Raconteur Transform to a general_robotics_toolbox Transform
+
+        :param rr_transform: The Robot Raconteur Transform
+        :type rr_transform: com.robotraconteur.geometry.Transform
+        :return: The general_robotics_toolbox Transform
+        :rtype: general_robotics_toolbox.Transform
+        """
+        R = self.quaternion_to_R(rr_transform["rotation"])
+        p = self.vector3_to_xyz(rr_transform["translation"])
+        return rox.Transform(R,p)
+
+    def _xyz_rpy_to_rox_transform(self, xyz,rpy,parent_frame_id=None,child_frame_id=None):
+        p = xyz
+        R = rox.rpy2R(rpy)
+        return rox.Transform(R,p,parent_frame_id,child_frame_id)
+
+    def _rox_transform_to_xyz_rpy(self, rox_transform):
+        R = rox_transform.R
+        p = rox_transform.p
+        return p, rox.R2rpy(R)
+
+    def _rox_transform_to_xyz_rpy_named(self, rox_transform):
+        R = rox_transform.R
+        p = rox_transform.p
+        parent_frame_id = rox_transform.parent_frame_id
+        child_frame_id = rox_transform.child_frame_id
+        return p, rox.R2rpy(R), parent_frame_id, child_frame_id
+
+    def xyz_rpy_to_transform(self, xyz, rpy, dtype=np.float64):
+        """
+        Converts a 3 element position vector and 3 element roll-pitch-yaw vector in radians to a 
+        Robot Raconteur Transform
+
+        :param xyz: The 3 element position vector
+        :type xyz: numpy.ndarray
+        :param rpy: The 3 element roll-pitch-yaw vector in radians
+        :type rpy: numpy.ndarray
+        :param dtype: The numpy dtype of the transform. Must be float64, float32, or int32. Defaults to float64
+        :type dtype: com.robotraconteur.geometry.Transform
+        :return: The Robot Raconteur Transform
+        :rtype: com.robotraconteur.geometry.Transform
+        """
+        return self.rox_transform_to_transform(self._xyz_rpy_to_rox_transform(xyz,rpy),dtype)
+
+    def transform_to_xyz_rpy(self, transform):
+        """
+        Converts a Robot Raconteur Transform to a 3 element position vector and 3 element roll-pitch-yaw vector 
+        in radians.
+
+        :param transform: The Robot Raconteur Transform
+        :type transform: com.robotraconteur.geometry.Transform
+        :return: The 3 element position vector and 3 element roll-pitch-yaw vector in radians
+        :rtype: Tuple[numpy.ndarray, numpy.ndarray]
+        """
+        return self._rox_transform_to_xyz_rpy(self.transform_to_rox_transform(transform))
+
+    def rox_transform_to_named_transform(self, rox_transform, dtype=np.float64):
+        """
+        Converts a general_robotics_toolbox Transform to a Robot Raconteur NamedTransform. The rox_transform
+        must have parent_frame_id and child_frame_id set.
+
+        :param rox_transform: The general_robotics_toolbox Transform
+        :type rox_transform: general_robotics_toolbox.Transform
+        :param dtype: The numpy dtype of the transform. Must be float64, float32, or int32. Defaults to float64
+        :type dtype: com.robotraconteur.geometry.NamedTransform
+        :return: The Robot Raconteur NamedTransform
+        :rtype: com.robotraconteur.geometry.NamedTransform
+        """
+        ret = self._create_return_struct(self._named_transform_type, dtype)
+        ret.transform = self.rox_transform_to_transform(rox_transform)
+        ret.child_frame = self._ident_util.CreateIdentifierFromName(rox_transform.child_frame_id)
+        ret.parent_frame = self._ident_util.CreateIdentifierFromName(rox_transform.parent_frame_id)
+        return ret
+
+    def named_transform_to_rox_transform(self, rr_named_transform):
+        """
+        Convert a Robot Raconteur NamedTransform to a general_robotics_toolbox Transform
+
+        :param rr_named_transform: The Robot Raconteur NamedTransform
+        :type rr_named_transform: com.robotraconteur.geometry.NamedTransform
+        :return: The general_robotics_toolbox Transform
+        :rtype: general_robotics_toolbox.Transform
+        """
+        R = self.quaternion_to_R(rr_named_transform.transform["rotation"])
+        p = self.vector3_to_xyz(rr_named_transform.transform["translation"])
+        return rox.Transform(R,p, _name_from_identifier(rr_named_transform.parent_frame), \
+            _name_from_identifier(rr_named_transform.child_frame))
+
+    def xyz_rpy_to_named_transform(self, xyz, rpy, parent_frame_id, child_frame_id, dtype=np.float64):
+        """
+        Converts a 3 element position vector and 3 element roll-pitch-yaw vector in radians to a
+        Robot Raconteur NamedTransform
+
+        :param xyz: The 3 element position vector
+        :type xyz: numpy.ndarray
+        :param rpy: The 3 element roll-pitch-yaw vector in radians
+        :type rpy: numpy.ndarray
+        :param parent_frame_id: The parent frame name
+        :type parent_frame_id: str
+        :param child_frame_id: The child frame name
+        :type child_frame_id: str
+        :param dtype: The numpy dtype of the transform. Must be float64, float32, or int32. Defaults to float64
+        :type dtype: com.robotraconteur.geometry.NamedTransform
+        :return: The Robot Raconteur NamedTransform
+        :rtype: com.robotraconteur.geometry.NamedTransform
+        """
+        return self.rox_transform_to_named_transform(self._xyz_rpy_to_rox_transform(xyz,rpy,parent_frame_id,child_frame_id),dtype)
+
+    def named_transform_to_xyz_rpy(self, transform):
+        """
+        Converts a Robot Raconteur NamedTransform to a 3 element position vector and 3 element roll-pitch-yaw vector
+        in radians.
+
+        :param transform: The Robot Raconteur NamedTransform
+        :type transform: com.robotraconteur.geometry.NamedTransform
+        :return: The 3 element position vector and 3 element roll-pitch-yaw vector in radians
+        :rtype: Tuple[numpy.ndarray, numpy.ndarray]
+        """
+        return self._rox_transform_to_xyz_rpy_named(self.named_transform_to_rox_transform(transform))
+
+    def rox_transform_to_pose(self, rox_transform, dtype=np.float64):
+        """
+        Converts a general_robotics_toolbox Transform to a Robot Raconteur Pose
+
+        :param rox_transform: The general_robotics_toolbox Transform
+        :type rox_transform: general_robotics_toolbox.Transform
+        :param dtype: The numpy dtype of the transform. Must be float64, float32, or int32. Defaults to float64
+        :type dtype: com.robotraconteur.geometry.Pose
+        :return: The Robot Raconteur Pose
+        :rtype: com.robotraconteur.geometry.Pose
+        """
+        ret = self._create_return_np(self._pose_type, dtype)
+        ret[0]["orientation"] = self.R_to_quaternion(rox_transform.R)
+        ret[0]["position"] = self.xyz_to_point(rox_transform.p)
+        return ret
+
+    def pose_to_rox_transform(self, rr_pose):
+        """
+        Convert a Robot Raconteur Pose to a general_robotics_toolbox Transform
+
+        :param rr_pose: The Robot Raconteur Pose
+        :type rr_pose: com.robotraconteur.geometry.Pose
+        :return: The general_robotics_toolbox Transform
+        :rtype: general_robotics_toolbox.Transform
+        """
+        R = self.quaternion_to_R(rr_pose["orientation"])
+        p = self.vector3_to_xyz(rr_pose["position"])
+        return rox.Transform(R,p)
+
+    def xyz_rpy_to_pose(self, xyz, rpy, dtype=np.float64):
+        """
+        Converts a 3 element position vector and 3 element roll-pitch-yaw vector in radians to a
+        Robot Raconteur Pose
+
+        :param xyz: The 3 element position vector
+        :type xyz: numpy.ndarray
+        :param rpy: The 3 element roll-pitch-yaw vector in radians
+        :type rpy: numpy.ndarray
+        :param dtype: The numpy dtype of the transform. Must be float64, float32, or int32. Defaults to float64
+        :type dtype: com.robotraconteur.geometry.Pose
+        :return: The Robot Raconteur Pose
+        :rtype: com.robotraconteur.geometry.Pose
+        """
+        return self.rox_transform_to_pose(self._xyz_rpy_to_rox_transform(xyz,rpy),dtype)
+
+    def pose_to_xyz_rpy(self, transform):
+        """
+        Converts a Robot Raconteur Pose to a 3 element position vector and 3 element roll-pitch-yaw vector
+
+        :param transform: The Robot Raconteur Pose
+        :type transform: com.robotraconteur.geometry.Pose
+        :return: The 3 element position vector and 3 element roll-pitch-yaw vector
+        :rtype: Tuple[numpy.ndarray, numpy.ndarray]
+        """
+        return self._rox_transform_to_xyz_rpy(self.pose_to_rox_transform(transform))
+
+    def rox_transform_to_named_pose(self, rox_transform, dtype=np.float64):
+        """
+        Converts a general_robotics_toolbox Transform to a Robot Raconteur NamedPose. The client_frame_id
+        and parent_frame_id must be set in the general_robotics_toolbox Transform.
+
+        :param rox_transform: The general_robotics_toolbox Transform
+        :type rox_transform: general_robotics_toolbox.Transform
+        :param dtype: The numpy dtype of the transform. Must be float64, float32, or int32. Defaults to float64
+        :type dtype: com.robotraconteur.geometry.NamedPose
+        :return: The Robot Raconteur NamedPose
+        :rtype: com.robotraconteur.geometry.NamedPose
+        """
+        ret = self._create_return_struct(self._named_pose_type, dtype)
+        ret.pose = self.rox_transform_to_pose(rox_transform)
+        ret.frame = self._ident_util.CreateIdentifierFromName(rox_transform.child_frame_id)
+        ret.parent_frame = self._ident_util.CreateIdentifierFromName(rox_transform.parent_frame_id)
+        return ret
+
+    def named_pose_to_rox_transform(self, rr_named_pose):
+        """
+        Convert a Robot Raconteur NamedPose to a general_robotics_toolbox Transform
+
+        :param rr_named_pose: The Robot Raconteur NamedPose
+        :type rr_named_pose: com.robotraconteur.geometry.NamedPose
+        :return: The general_robotics_toolbox Transform
+        :rtype: general_robotics_toolbox.Transform
+        """
+        R = self.quaternion_to_R(rr_named_pose.pose["orientation"])
+        p = self.vector3_to_xyz(rr_named_pose.pose["position"])
+        return rox.Transform(R,p,_name_from_identifier(rr_named_pose.parent_frame), \
+            _name_from_identifier(rr_named_pose.frame))
+
+    def xyz_rpy_to_named_pose(self, xyz, rpy, parent_frame_id, child_frame_id, dtype=np.float64):
+        """
+        Converts a 3 element position vector and 3 element roll-pitch-yaw vector in radians to a
+        Robot Raconteur NamedPose
+
+        :param xyz: The 3 element position vector
+        :type xyz: numpy.ndarray
+        :param rpy: The 3 element roll-pitch-yaw vector in radians
+        :type rpy: numpy.ndarray
+        :param parent_frame_id: The parent frame identifier
+        :type parent_frame_id: str
+        :param child_frame_id: The child frame identifier
+        :type child_frame_id: str
+
+        """
+        return self.rox_transform_to_named_pose(self._xyz_rpy_to_rox_transform(xyz,rpy,parent_frame_id,child_frame_id),dtype)
+
+    def named_pose_to_xyz_rpy(self, transform):
+        """
+        Convert a Robot Raconteur NamedPose to a 3 element position vector and 3 element roll-pitch-yaw vector in radians
+
+        :param transform: The Robot Raconteur NamedPose
+        :type transform: com.robotraconteur.geometry.NamedPose
+        :return: The 3 element position vector and 3 element roll-pitch-yaw vector
+        :rtype: Tuple[numpy.ndarray, numpy.ndarray]
+        """
+        return self._rox_transform_to_xyz_rpy_named(self.named_pose_to_rox_transform(transform))
+
+    def array_to_spatial_velocity(self, spatial_velocity, dtype=np.float64):
+        """
+        Converts a 6 element spatial velocity vector to a Robot Raconteur SpatialVelocity
+
+        :param spatial_velocity: The 6 element spatial velocity vector
+        :type spatial_velocity: numpy.ndarray
+        :param dtype: The numpy dtype of the transform. Must be float64, float32, or int32. Defaults to float64
+        :type dtype: com.robotraconteur.geometry.SpatialVelocity
+        :return: The Robot Raconteur SpatialVelocity
+        :rtype: com.robotraconteur.geometry.SpatialVelocity
+        """
+        ret = self._create_return_np(self._spatial_velocity_type, dtype)
+        ret[0]["angular"]["x"] = spatial_velocity[0]
+        ret[0]["angular"]["y"] = spatial_velocity[1]
+        ret[0]["angular"]["z"] = spatial_velocity[2]
+        ret[0]["linear"]["x"] = spatial_velocity[3]
+        ret[0]["linear"]["y"] = spatial_velocity[4]
+        ret[0]["linear"]["z"] = spatial_velocity[5]
+        return ret
+
+    def spatial_velocity_to_array(self, rr_spatial_velocity):
+        """
+        Converts a Robot Raconteur SpatialVelocity to a 6 element spatial velocity vector
+
+        :param rr_spatial_velocity: The Robot Raconteur SpatialVelocity
+        :type rr_spatial_velocity: com.robotraconteur.geometry.SpatialVelocity
+        :return: The 6 element spatial velocity vector
+        :rtype: numpy.ndarray
+        """
+        return np.array([rr_spatial_velocity[0]["angular"]["x"], rr_spatial_velocity[0]["angular"]["y"],\
+            rr_spatial_velocity[0]["angular"]["z"], rr_spatial_velocity[0]["linear"]["x"], \
+            rr_spatial_velocity[0]["linear"]["y"], rr_spatial_velocity[0]["linear"]["z"]])
+
+    def array_to_spatial_acceleration(self, spatial_acceleration, dtype=np.float64):
+        """
+        Converts a 6 element spatial acceleration vector to a Robot Raconteur SpatialAcceleration
+
+        :param spatial_acceleration: The 6 element spatial acceleration vector
+        :type spatial_acceleration: numpy.ndarray
+        :param dtype: The numpy dtype of the transform. Must be float64, float32, or int32. Defaults to float64
+        :type dtype: com.robotraconteur.geometry.SpatialAcceleration
+        :return: The Robot Raconteur SpatialAcceleration
+        :rtype: com.robotraconteur.geometry.SpatialAcceleration
+        """
+        ret = self._create_return_np(self._spatial_acceleration_type, dtype)
+        ret[0]["angular"]["x"] = spatial_acceleration[0]
+        ret[0]["angular"]["y"] = spatial_acceleration[1]
+        ret[0]["angular"]["z"] = spatial_acceleration[2]
+        ret[0]["linear"]["x"] = spatial_acceleration[3]
+        ret[0]["linear"]["y"] = spatial_acceleration[4]
+        ret[0]["linear"]["z"] = spatial_acceleration[5]
+        return ret
+
+    def spatial_acceleration_to_array(self, rr_spatial_acceleration):
+        """
+        Converts a Robot Raconteur SpatialAcceleration to a 6 element spatial acceleration vector
+
+        :param rr_spatial_acceleration: The Robot Raconteur SpatialAcceleration
+        :type rr_spatial_acceleration: com.robotraconteur.geometry.SpatialAcceleration
+        :return: The 6 element spatial acceleration vector
+        :rtype: numpy.ndarray
+        """
+        return np.array([rr_spatial_acceleration[0]["angular"]["x"], rr_spatial_acceleration[0]["angular"]["y"],\
+            rr_spatial_acceleration[0]["angular"]["z"], rr_spatial_acceleration[0]["linear"]["x"], \
+            rr_spatial_acceleration[0]["linear"]["y"], rr_spatial_acceleration[0]["linear"]["z"]])
+
+    
+    def array_to_wrench(self, wrench, dtype=np.float64):
+        """
+        Converts a 6 element wrench vector to a Robot Raconteur Wrench
+
+        :param wrench: The 6 element wrench vector
+        :type wrench: numpy.ndarray
+        :param dtype: The numpy dtype of the transform. Must be float64, float32, or int32. Defaults to float64
+        :type dtype: com.robotraconteur.geometry.Wrench
+        :return: The Robot Raconteur Wrench
+        :rtype: com.robotraconteur.geometry.Wrench
+        """
+        ret = self._create_return_np(self._wrench_type, dtype)
+        ret[0]["torque"]["x"] = wrench[0]
+        ret[0]["torque"]["y"] = wrench[1]
+        ret[0]["torque"]["z"] = wrench[2]
+        ret[0]["force"]["x"] = wrench[3]
+        ret[0]["force"]["y"] = wrench[4]
+        ret[0]["force"]["z"] = wrench[5]
+        return ret
+
+    def wrench_to_array(self, rr_wrench):
+        """
+        Converts a Robot Raconteur Wrench to a 6 element wrench vector
+
+        :param rr_wrench: The Robot Raconteur Wrench
+        :type rr_wrench: com.robotraconteur.geometry.Wrench
+        :return: The 6 element wrench vector
+        :rtype: numpy.ndarray
+        """
+        return np.array([rr_wrench[0]["torque"]["x"], rr_wrench[0]["torque"]["y"],\
+            rr_wrench[0]["torque"]["z"], rr_wrench[0]["force"]["x"], \
+            rr_wrench[0]["force"]["y"], rr_wrench[0]["force"]["z"]])
+
+
```

## RobotRaconteurCompanion/Util/IdentifierUtil.py

```diff
@@ -1,114 +1,199 @@
-import RobotRaconteur as RR
-RRN = RR.RobotRaconteurNode.s
-import numpy as np
-import re
-
-from .UuidUtil import UuidUtil
-
-class IdentifierUtil(object):
-
-    def __init__(self, node = None, client_obj = None):
-        if node is None:
-            self._node = RRN
-        else:
-            self._node = node
-        self._client_obj = client_obj
-
-        self._identifier = self._node.GetStructureType("com.robotraconteur.identifier.Identifier", self._client_obj)
-        self._uuid_dt = self._node.GetNamedArrayDType("com.robotraconteur.uuid.UUID", self._client_obj)
-
-        self._uuid_util = UuidUtil(node,client_obj)
-
-    def IsIdentifierAnyUuid(self,identifier):
-        if identifier is None or identifier.uuid is None:
-            return True
-        return np.all(identifier.uuid["uuid_bytes"] == 0)
-
-    def IsIdentifierAnyName(self,identifier):
-        if identifier is None or identifier.name is None:
-            return True
-        return len(identifier.name) == 0
-
-    def IsIdentifierAny(self,identifier):
-        if identifier is None:
-            return True
-        if not self.IsIdentifierAnyUuid(identifier):
-            return False
-        if not self.IsIdentifierAnyName(identifier):
-            return False
-        return True
-
-    def IsIdentifierMatch(self, expected, test):
-        if self.IsIdentifierAny(expected) or self.IsIdentifierAny(test):
-            return True
-        
-        name_match = False
-        uuid_match = False
-
-        if self.IsIdentifierAnyName(expected) or self.IsIdentifierAnyName(test):
-            name_match = True
-        else:
-            if expected.name == test.name:
-                name_match = True
-
-        if self.IsIdentifierAnyUuid(expected) or self.IsIdentifierAnyUuid(test):
-            uuid_match = True
-        else:
-            if np.all(expected.uuid["uuid_bytes"] == test.uuid["uuid_bytes"]):
-                uuid_match = True
-
-        return name_match and uuid_match
-
-    def CreateIdentifier(self,name,uuid):
-        ret = self._identifier()        
-        ret.name = name if name is not None else ""
-        if uuid is not None:
-            ret.uuid = self._uuid_util.ParseUuid(uuid)
-        else:
-            ret.uuid = np.zeros((1,),dtype=self._uuid_dt)
-        return ret
-
-    def CreateIdentifierFromName(self,name):
-        assert name is not None
-        ret = self._identifier()        
-        ret.name = name        
-        ret.uuid = np.zeros((1,),dtype=self._uuid_dt)
-        return ret
-
-    def IdentifierToString(self,identifier):
-        if identifier is None:
-            return ""
-        if not self.IsIdentifierAnyName(identifier) and not self.IsIdentifierAnyUuid(identifier):
-            return identifier.name + "|" + self._uuid_util.UuidToString(identifier.uuid)
-        if not self.IsIdentifierAny(identifier):
-            return identifier.name
-        if not self.IsIdentifierAnyUuid(identifier):
-            return identifier.uuid
-        return ""
-
-    def StringToIdentifier(self, string_id):
-        name_regex_str = "(?:[a-zA-Z](?:[a-zA-Z0-9_]*[a-zA-Z0-9])?)(?:\\.[a-zA-Z](?:[a-zA-Z0-9_]*[a-zA-Z0-9])?)*"
-        uuid_regex_str = "\\{?[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}\\}?"
-        identifier_regex = "(?:(" + name_regex_str + ")\\|(" + uuid_regex_str + "))|(" + name_regex_str + ")|(" + uuid_regex_str + ")"
-
-        r_res = re.match(identifier_regex, string_id)
-        if r_res is None:
-            raise RR.InvalidArgumentException("Invalid identifier string")
-
-        if r_res.group(1) is not None and r_res.group(2) is not None:
-            return self.CreateIdentifier(r_res.group(1), r_res.group(2))
-        
-        if r_res.group(3) is not None:
-            return self.CreateIdentifierFromName(r_res.group(3))
-
-        if r_res.group(4) is not None:
-            return self.CreateIdentifier("", r_res.group(4))
-
-        raise RR.InvalidArgumentException("Invalid identifier string")
-
-
-
-
-        
-
+import RobotRaconteur as RR
+RRN = RR.RobotRaconteurNode.s
+import numpy as np
+import re
+
+from .UuidUtil import UuidUtil
+
+class IdentifierUtil(object):
+    """
+    Utility class for working with Robot Raconteur identifiers
+
+    :param node: (optional) The Robot Raconteur node to use for parsing. Defaults to RobotRaconteurNode.s
+    :type node: RobotRaconteur.RobotRaconteurNode
+    :param client_obj: (optional) The client object to use for finding types. Defaults to None
+    :type client_obj: RobotRaconteur.ClientObject
+    """
+
+    def __init__(self, node = None, client_obj = None):
+        if node is None:
+            self._node = RRN
+        else:
+            self._node = node
+        self._client_obj = client_obj
+
+        self._identifier = self._node.GetStructureType("com.robotraconteur.identifier.Identifier", self._client_obj)
+        self._uuid_dt = self._node.GetNamedArrayDType("com.robotraconteur.uuid.UUID", self._client_obj)
+
+        self._uuid_util = UuidUtil(node,client_obj)
+
+    def IsIdentifierAnyUuid(self,identifier):
+        """
+        Check if an identifier is "any" (UUID is all zeros)
+
+        :param identifier: The identifier to check
+        :type identifier: com.robotraconteur.identifier.Identifier
+        :return: True if the identifier is "any"
+        :rtype: bool
+        """
+        if identifier is None or identifier.uuid is None:
+            return True
+        return np.all(identifier.uuid["uuid_bytes"] == 0)
+
+    def IsIdentifierAnyName(self,identifier):
+        """
+        Check if an identifier is "any" (name is empty)
+
+        :param identifier: The identifier to check
+        :type identifier: com.robotraconteur.identifier.Identifier
+        :return: True if the identifier is "any"
+        :rtype: bool
+        """
+        if identifier is None or identifier.name is None:
+            return True
+        return len(identifier.name) == 0
+
+    def IsIdentifierAny(self,identifier):
+        """
+        Check if an identifier is "any" (UUID is all zeros and name is empty)
+
+        :param identifier: The identifier to check
+        :type identifier: com.robotraconteur.identifier.Identifier
+        :return: True if the identifier is "any"
+        :rtype: bool
+        """
+        if identifier is None:
+            return True
+        if not self.IsIdentifierAnyUuid(identifier):
+            return False
+        if not self.IsIdentifierAnyName(identifier):
+            return False
+        return True
+
+    def IsIdentifierMatch(self, expected, test):
+        """
+        Check if two identifiers match
+      
+        Identifiers have a complex matching rules:
+        
+        - If both identifiers are "any", they match
+        - If either identifier is "any", they match
+        - If both identifiers have the same name and UUID, they match
+        - If the name is Any for either identifier and UUID matches, they match
+        - If the UUID is Any for either identifier and name matches, they match
+        - Otherwise, they do not match
+
+        :param expected: The expected identifier
+        :type expected: com.robotraconteur.identifier.Identifier
+        :param test: The test identifier
+        :type test: com.robotraconteur.identifier.Identifier
+        :return: True if the identifiers match
+        :rtype: bool
+        """
+        if self.IsIdentifierAny(expected) or self.IsIdentifierAny(test):
+            return True
+        
+        name_match = False
+        uuid_match = False
+
+        if self.IsIdentifierAnyName(expected) or self.IsIdentifierAnyName(test):
+            name_match = True
+        else:
+            if expected.name == test.name:
+                name_match = True
+
+        if self.IsIdentifierAnyUuid(expected) or self.IsIdentifierAnyUuid(test):
+            uuid_match = True
+        else:
+            if np.all(expected.uuid["uuid_bytes"] == test.uuid["uuid_bytes"]):
+                uuid_match = True
+
+        return name_match and uuid_match
+
+    def CreateIdentifier(self,name,uuid):
+        """
+        Create an identifier from a name and UUID
+
+        :param name: The name of the identifier
+        :type name: str
+        :param uuid: The UUID of the identifier
+        :type uuid: str
+        :return: The created identifier
+        :rtype: com.robotraconteur.identifier.Identifier
+        """
+        ret = self._identifier()        
+        ret.name = name if name is not None else ""
+        if uuid is not None:
+            ret.uuid = self._uuid_util.ParseUuid(uuid)
+        else:
+            ret.uuid = np.zeros((1,),dtype=self._uuid_dt)
+        return ret
+
+    def CreateIdentifierFromName(self,name):
+        """
+        Create an identifier from a name. The UUID will be all zeros.
+
+        :param name: The name of the identifier
+        :type name: str
+        :return: The created identifier
+        :rtype: com.robotraconteur.identifier.Identifier
+        """
+        assert name is not None
+        ret = self._identifier()        
+        ret.name = name        
+        ret.uuid = np.zeros((1,),dtype=self._uuid_dt)
+        return ret
+
+    def IdentifierToString(self,identifier):
+        """
+        Create a string representation of an identifier. The string representation is in the form "name|uuid".
+
+        :param identifier: The identifier to convert to a string
+        :type identifier: com.robotraconteur.identifier.Identifier
+        :return: The string representation of the identifier
+        :rtype: str
+        """
+        if identifier is None:
+            return ""
+        if not self.IsIdentifierAnyName(identifier) and not self.IsIdentifierAnyUuid(identifier):
+            return identifier.name + "|" + self._uuid_util.UuidToString(identifier.uuid)
+        if not self.IsIdentifierAny(identifier):
+            return identifier.name
+        if not self.IsIdentifierAnyUuid(identifier):
+            return identifier.uuid
+        return ""
+
+    def StringToIdentifier(self, string_id):
+        """
+        Parse a string representation of an identifier. The string representation is in the form "name|uuid".
+
+        :param string_id: The string representation of the identifier
+        :type string_id: str
+        :return: The parsed identifier
+        :rtype: com.robotraconteur.identifier.Identifier
+        """
+        name_regex_str = "(?:[a-zA-Z](?:[a-zA-Z0-9_]*[a-zA-Z0-9])?)(?:\\.[a-zA-Z](?:[a-zA-Z0-9_]*[a-zA-Z0-9])?)*"
+        uuid_regex_str = "\\{?[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}\\}?"
+        identifier_regex = "(?:(" + name_regex_str + ")\\|(" + uuid_regex_str + "))|(" + name_regex_str + ")|(" + uuid_regex_str + ")"
+
+        r_res = re.match(identifier_regex, string_id)
+        if r_res is None:
+            raise RR.InvalidArgumentException("Invalid identifier string")
+
+        if r_res.group(1) is not None and r_res.group(2) is not None:
+            return self.CreateIdentifier(r_res.group(1), r_res.group(2))
+        
+        if r_res.group(3) is not None:
+            return self.CreateIdentifierFromName(r_res.group(3))
+
+        if r_res.group(4) is not None:
+            return self.CreateIdentifier("", r_res.group(4))
+
+        raise RR.InvalidArgumentException("Invalid identifier string")
+
+
+
+
+        
+
```

## RobotRaconteurCompanion/Util/ImageUtil.py

```diff
@@ -1,192 +1,267 @@
-import RobotRaconteur as RR
-RRN = RR.RobotRaconteurNode.s
-import numpy as np
-
-import sys
-
-try:
-    import cv2
-except:
-    cv2 = None
-
-class ImageUtil(object):
-
-    def __init__(self, node = None, client_obj = None):
-        if node is None:
-            self._node = RRN
-        else:
-            self._node = node
-        self._client_obj = client_obj
-        
-        self._image_type = self._node.GetStructureType("com.robotraconteur.image.Image", self._client_obj)
-        self._image_info_type = self._node.GetStructureType("com.robotraconteur.image.ImageInfo", self._client_obj)
-        self._compressed_image_type = self._node.GetStructureType("com.robotraconteur.image.CompressedImage", self._client_obj)
-        self._image_const = self._node.GetConstants("com.robotraconteur.image", self._client_obj)
-        
-    def image_to_array(self, rr_image):
-
-        encoding = rr_image.image_info.encoding
-
-        encodings = self._image_const["ImageEncoding"]
-
-        if encoding == encodings["bgr888"]:
-            return rr_image.data.reshape([rr_image.image_info.height, rr_image.image_info.width, 3], order='C')
-
-        if encoding == encodings["rgb888"]:
-            img1 = rr_image.data.reshape([rr_image.image_info.height, rr_image.image_info.width, 3], order='C')
-            return img1[...,::-1].copy()
-
-        if encoding == encodings["bgra8888"]:
-            return rr_image.data.reshape([rr_image.image_info.height, rr_image.image_info.width, 4], order='C')
-
-        if encoding == encodings["rgba8888"]:
-            img1 = rr_image.data.reshape([rr_image.image_info.height, rr_image.image_info.width, 4], order='C')
-            img2 = img1.copy()
-            img2[...,0] = img1[...,2]
-            img2[...,2] = img1[...,0]
-            return img2
-
-        if encoding == encodings["mono8"]:
-            return rr_image.data.reshape([rr_image.image_info.height, rr_image.image_info.width], order='C')
-
-        if encoding == encodings["mono16"] or encoding == encodings["depth_u16"]:
-            assert sys.byteorder == "little"
-            return rr_image.data.view(dtype=np.uint16).reshape([rr_image.image_info.height, rr_image.image_info.width], order='C').copy()
-
-        if encoding == encodings["mono32"] or encoding == encodings["depth_u32"]:
-            assert sys.byteorder == "little"
-            return rr_image.data.view(dtype=np.uint32).reshape([rr_image.image_info.height, rr_image.image_info.width], order='C').copy()
-
-        if encoding == encodings["depth_f32"]:
-            assert sys.byteorder == "little"
-            return rr_image.data.view(dtype=np.float32).reshape([rr_image.image_info.height, rr_image.image_info.width], order='C').copy()
-        
-        assert False, f"Unknown image encoding: {encoding}"
-
-    def array_to_image(self, arr, encoding):
-
-        encodings = self._image_const["ImageEncoding"]
-
-        rr_image = self._image_type()
-        rr_image_info = self._image_info_type()
-
-        rr_image.image_info = rr_image_info
-        rr_image_info.width = arr.shape[1]
-        rr_image_info.height = arr.shape[0]
-
-        if encoding == "bgr888":
-            assert arr.shape[2] == 3
-            assert arr.dtype == np.uint8
-            rr_image.image_info.encoding = encodings["bgr888"]
-            rr_image.image_info.step = rr_image.image_info.width * 3
-            rr_image.data = arr.flatten(order="C")
-            return rr_image
-
-        if encoding == "rgb888":
-            assert arr.shape[2] == 3
-            assert arr.dtype == np.uint8
-            rr_image.image_info.encoding = encodings["rgb888"]
-            rr_image.image_info.step = rr_image.image_info.width * 3
-            rr_image.data = arr.flatten(order="C")
-            rr_image.data[0::3] = arr[...,2].flatten(order="C")
-            rr_image.data[2::3] = arr[...,0].flatten(order="C")
-            return rr_image
-
-        if encoding == "bgra8888":
-            assert arr.shape[2] == 4
-            assert arr.dtype == np.uint8
-            rr_image.image_info.encoding = encodings["bgra8888"]
-            rr_image.image_info.step = rr_image.image_info.width * 4
-            rr_image.data = arr.flatten(order="C")
-            return rr_image
-
-        if encoding == "rgba8888":
-            assert arr.shape[2] == 4
-            assert arr.dtype == np.uint8
-            rr_image.image_info.encoding = encodings["rgba8888"]
-            rr_image.image_info.step = rr_image.image_info.width * 4
-            rr_image.data = np.zeros((arr.size,),dtype=np.uint8)
-            rr_image.data[0::4] = arr[...,2].flatten(order="C")
-            rr_image.data[1::4] = arr[...,1].flatten(order="C")
-            rr_image.data[2::4] = arr[...,0].flatten(order="C")
-            rr_image.data[3::4] = arr[...,3].flatten(order="C")
-            return rr_image
-
-        if encoding == "mono8":
-            assert arr.ndim ==2 or arr.shape[2] == 1
-            assert arr.dtype == np.uint8
-            rr_image.image_info.encoding = encodings["mono8"]
-            rr_image.image_info.step = rr_image.image_info.width
-            rr_image.data = arr.flatten(order="C")
-            return rr_image
-
-        if encoding == "mono16" or encoding == "depth_u16":
-            assert arr.ndim ==2 or arr.shape[2] == 1
-            assert arr.dtype == np.uint16
-            assert sys.byteorder == "little"
-            rr_image.image_info.encoding = encodings[encoding]
-            rr_image.image_info.step = rr_image.image_info.width * 2
-            rr_image.data = arr.flatten(order="C").view(dtype=np.uint8).copy()
-            return rr_image
-
-        if encoding == "mono32" or encoding == "depth_u32":
-            assert arr.ndim ==2 or arr.shape[2] == 1
-            assert arr.dtype == np.uint32
-            assert sys.byteorder == "little"
-            rr_image.image_info.encoding = encodings[encoding]
-            rr_image.image_info.step = rr_image.image_info.width * 4
-            rr_image.data = arr.flatten(order="C").view(dtype=np.uint8).copy()
-            return rr_image
-
-        if encoding == "depth_f32":
-            assert arr.ndim ==2 or arr.shape[2] == 1
-            assert arr.dtype == np.float32
-            assert sys.byteorder == "little"
-            rr_image.image_info.encoding = encodings[encoding]
-            rr_image.image_info.step = rr_image.image_info.width * 4
-            rr_image.data = arr.flatten(order="C").view(dtype=np.uint8).copy()
-            return rr_image
-
-        assert False, f"Unknown image encoding: {encoding}"
-
-    def array_to_compressed_image_jpg(self, arr, quality = 95):
-        assert cv2, "OpenCV required for image compression"
-
-        rr_image = self._compressed_image_type()
-        rr_image_info = self._image_info_type()
-
-        rr_image.image_info = rr_image_info
-        rr_image_info.width = arr.shape[1]
-        rr_image_info.height = arr.shape[0]
-        rr_image_info.encoding = self._image_const["ImageEncoding"]["compressed"]
-
-        res, encimg = cv2.imencode(".jpg",arr,[int(cv2.IMWRITE_JPEG_QUALITY), quality])
-
-        assert res, "Image compression failed"
-
-        rr_image.data = encimg
-        return rr_image
-
-    def array_to_compressed_image_png(self, arr):
-        assert cv2, "OpenCV required for image compression"
-
-        rr_image = self._compressed_image_type()
-        rr_image_info = self._image_info_type()
-
-        rr_image.image_info = rr_image_info
-        rr_image_info.width = arr.shape[1]
-        rr_image_info.height = arr.shape[0]
-        rr_image_info.encoding = self._image_const["ImageEncoding"]["compressed"]
-
-        res, encimg = cv2.imencode(".png",arr)
-
-        assert res, "Image compression failed"
-
-        rr_image.data = encimg
-        return rr_image
-
-    def compressed_image_to_array(self,rr_compressed_image,flags=-1):
-
-        return cv2.imdecode(rr_compressed_image.data,flags)
-
-    
+import RobotRaconteur as RR
+RRN = RR.RobotRaconteurNode.s
+import numpy as np
+
+import sys
+
+try:
+    import cv2
+except:
+    cv2 = None
+
+"""
+Utility class to convert between Robot Raconteur Image structures and OpenCV format images. The OpenCV format
+images are typically numpy arrays in monochrom, BGR, or BGRA format.
+
+:param node: (optional) The Robot Raconteur node to use for parsing. Defaults to RobotRaconteurNode.s
+:type node: RobotRaconteur.RobotRaconteurNode
+:param client_obj: (optional) The client object to use for finding types. Defaults to None
+:type client_obj: RobotRaconteur.ClientObject
+"""
+class ImageUtil(object):
+
+    def __init__(self, node = None, client_obj = None):
+        if node is None:
+            self._node = RRN
+        else:
+            self._node = node
+        self._client_obj = client_obj
+        
+        self._image_type = self._node.GetStructureType("com.robotraconteur.image.Image", self._client_obj)
+        self._image_info_type = self._node.GetStructureType("com.robotraconteur.image.ImageInfo", self._client_obj)
+        self._compressed_image_type = self._node.GetStructureType("com.robotraconteur.image.CompressedImage", self._client_obj)
+        self._image_const = self._node.GetConstants("com.robotraconteur.image", self._client_obj)
+        
+    def image_to_array(self, rr_image):
+        """
+        Convert a Robot Raconteur Image to an array. The array will be in the format specified by the image encoding.
+
+        The following image encoding codes are supported:
+
+        - bgr888
+        - rgb888
+        - bgra8888
+        - rgba8888
+        - mono8
+        - mono16
+        - mono32
+        - depth_f32
+
+        :param rr_image: The Robot Raconteur Image to convert
+        :type rr_image: com.robotraconteur.image.Image
+        :return: The converted image
+        :rtype: numpy.ndarray
+        """
+
+        encoding = rr_image.image_info.encoding
+
+        encodings = self._image_const["ImageEncoding"]
+
+        if encoding == encodings["bgr888"]:
+            return rr_image.data.reshape([rr_image.image_info.height, rr_image.image_info.width, 3], order='C')
+
+        if encoding == encodings["rgb888"]:
+            img1 = rr_image.data.reshape([rr_image.image_info.height, rr_image.image_info.width, 3], order='C')
+            return img1[...,::-1].copy()
+
+        if encoding == encodings["bgra8888"]:
+            return rr_image.data.reshape([rr_image.image_info.height, rr_image.image_info.width, 4], order='C')
+
+        if encoding == encodings["rgba8888"]:
+            img1 = rr_image.data.reshape([rr_image.image_info.height, rr_image.image_info.width, 4], order='C')
+            img2 = img1.copy()
+            img2[...,0] = img1[...,2]
+            img2[...,2] = img1[...,0]
+            return img2
+
+        if encoding == encodings["mono8"]:
+            return rr_image.data.reshape([rr_image.image_info.height, rr_image.image_info.width], order='C')
+
+        if encoding == encodings["mono16"] or encoding == encodings["depth_u16"]:
+            assert sys.byteorder == "little"
+            return rr_image.data.view(dtype=np.uint16).reshape([rr_image.image_info.height, rr_image.image_info.width], order='C').copy()
+
+        if encoding == encodings["mono32"] or encoding == encodings["depth_u32"]:
+            assert sys.byteorder == "little"
+            return rr_image.data.view(dtype=np.uint32).reshape([rr_image.image_info.height, rr_image.image_info.width], order='C').copy()
+
+        if encoding == encodings["depth_f32"]:
+            assert sys.byteorder == "little"
+            return rr_image.data.view(dtype=np.float32).reshape([rr_image.image_info.height, rr_image.image_info.width], order='C').copy()
+        
+        assert False, f"Unknown image encoding: {encoding}"
+
+    def array_to_image(self, arr, encoding):
+        """
+        Convert a numpy array to a Robot Raconteur Image. The array must be in the format specified by the image encoding.
+
+        The following image encoding codes are supported:
+
+        - bgr888
+        - rgb888
+        - bgra8888
+        - rgba8888
+        - mono8
+        - mono16
+        - mono32
+        - depth_f32
+
+        :param arr: The array to convert
+        :type arr: numpy.ndarray
+        :encoding: The image encoding
+        :type encoding: str
+        :return: The converted image
+        :rtype: com.robotraconteur.image.Image
+        """
+
+        encodings = self._image_const["ImageEncoding"]
+
+        rr_image = self._image_type()
+        rr_image_info = self._image_info_type()
+
+        rr_image.image_info = rr_image_info
+        rr_image_info.width = arr.shape[1]
+        rr_image_info.height = arr.shape[0]
+
+        if encoding == "bgr888":
+            assert arr.shape[2] == 3
+            assert arr.dtype == np.uint8
+            rr_image.image_info.encoding = encodings["bgr888"]
+            rr_image.image_info.step = rr_image.image_info.width * 3
+            rr_image.data = arr.flatten(order="C")
+            return rr_image
+
+        if encoding == "rgb888":
+            assert arr.shape[2] == 3
+            assert arr.dtype == np.uint8
+            rr_image.image_info.encoding = encodings["rgb888"]
+            rr_image.image_info.step = rr_image.image_info.width * 3
+            rr_image.data = arr.flatten(order="C")
+            rr_image.data[0::3] = arr[...,2].flatten(order="C")
+            rr_image.data[2::3] = arr[...,0].flatten(order="C")
+            return rr_image
+
+        if encoding == "bgra8888":
+            assert arr.shape[2] == 4
+            assert arr.dtype == np.uint8
+            rr_image.image_info.encoding = encodings["bgra8888"]
+            rr_image.image_info.step = rr_image.image_info.width * 4
+            rr_image.data = arr.flatten(order="C")
+            return rr_image
+
+        if encoding == "rgba8888":
+            assert arr.shape[2] == 4
+            assert arr.dtype == np.uint8
+            rr_image.image_info.encoding = encodings["rgba8888"]
+            rr_image.image_info.step = rr_image.image_info.width * 4
+            rr_image.data = np.zeros((arr.size,),dtype=np.uint8)
+            rr_image.data[0::4] = arr[...,2].flatten(order="C")
+            rr_image.data[1::4] = arr[...,1].flatten(order="C")
+            rr_image.data[2::4] = arr[...,0].flatten(order="C")
+            rr_image.data[3::4] = arr[...,3].flatten(order="C")
+            return rr_image
+
+        if encoding == "mono8":
+            assert arr.ndim ==2 or arr.shape[2] == 1
+            assert arr.dtype == np.uint8
+            rr_image.image_info.encoding = encodings["mono8"]
+            rr_image.image_info.step = rr_image.image_info.width
+            rr_image.data = arr.flatten(order="C")
+            return rr_image
+
+        if encoding == "mono16" or encoding == "depth_u16":
+            assert arr.ndim ==2 or arr.shape[2] == 1
+            assert arr.dtype == np.uint16
+            assert sys.byteorder == "little"
+            rr_image.image_info.encoding = encodings[encoding]
+            rr_image.image_info.step = rr_image.image_info.width * 2
+            rr_image.data = arr.flatten(order="C").view(dtype=np.uint8).copy()
+            return rr_image
+
+        if encoding == "mono32" or encoding == "depth_u32":
+            assert arr.ndim ==2 or arr.shape[2] == 1
+            assert arr.dtype == np.uint32
+            assert sys.byteorder == "little"
+            rr_image.image_info.encoding = encodings[encoding]
+            rr_image.image_info.step = rr_image.image_info.width * 4
+            rr_image.data = arr.flatten(order="C").view(dtype=np.uint8).copy()
+            return rr_image
+
+        if encoding == "depth_f32":
+            assert arr.ndim ==2 or arr.shape[2] == 1
+            assert arr.dtype == np.float32
+            assert sys.byteorder == "little"
+            rr_image.image_info.encoding = encodings[encoding]
+            rr_image.image_info.step = rr_image.image_info.width * 4
+            rr_image.data = arr.flatten(order="C").view(dtype=np.uint8).copy()
+            return rr_image
+
+        assert False, f"Unknown image encoding: {encoding}"
+
+    def array_to_compressed_image_jpg(self, arr, quality = 95):
+        """
+        Convert a numpy array to a compressed Robot Raconteur Image in jpg format.
+
+        :param arr: The array to convert
+        :type arr: numpy.ndarray
+        :param quality: The JPEG quality (0-100). Default is 95.
+        :type quality: int
+        :return: The converted image
+        :rtype: com.robotraconteur.image.CompressedImage
+        """
+        assert cv2, "OpenCV required for image compression"
+
+        rr_image = self._compressed_image_type()
+        rr_image_info = self._image_info_type()
+
+        rr_image.image_info = rr_image_info
+        rr_image_info.width = arr.shape[1]
+        rr_image_info.height = arr.shape[0]
+        rr_image_info.encoding = self._image_const["ImageEncoding"]["compressed"]
+
+        res, encimg = cv2.imencode(".jpg",arr,[int(cv2.IMWRITE_JPEG_QUALITY), quality])
+
+        assert res, "Image compression failed"
+
+        rr_image.data = encimg
+        return rr_image
+
+    def array_to_compressed_image_png(self, arr):
+        """
+        Convert a numpy array to a compressed Robot Raconteur Image in png format.
+
+        :param arr: The array to convert
+        :type arr: numpy.ndarray
+        :return: The converted image
+        :rtype: com.robotraconteur.image.CompressedImage
+        """
+        assert cv2, "OpenCV required for image compression"
+
+        rr_image = self._compressed_image_type()
+        rr_image_info = self._image_info_type()
+
+        rr_image.image_info = rr_image_info
+        rr_image_info.width = arr.shape[1]
+        rr_image_info.height = arr.shape[0]
+        rr_image_info.encoding = self._image_const["ImageEncoding"]["compressed"]
+
+        res, encimg = cv2.imencode(".png",arr)
+
+        assert res, "Image compression failed"
+
+        rr_image.data = encimg
+        return rr_image
+
+    def compressed_image_to_array(self,rr_compressed_image,flags=-1):
+        """
+        Convert a compressed Robot Raconteur Image to a numpy array. This function uses cv2.imdecode to decode the image.
+
+        :param rr_compressed_image: The image to convert
+        :type rr_compressed_image: com.robotraconteur.image.CompressedImage
+        :param flags: OpenCV flags for decoding. Default is -1.
+        :type flags: int
+        """
+
+        return cv2.imdecode(rr_compressed_image.data,flags)
+
+
```

## RobotRaconteurCompanion/Util/InfoFileLoader.py

```diff
@@ -1,53 +1,91 @@
-import RobotRaconteur as RR
-RRN = RR.RobotRaconteurNode.s
-import numpy as np
-import re
-
-from .LocalIdentifiersManager import LocalIdentifiersManager
-from .IdentifierUtil import IdentifierUtil
-from ..InfoParser import InfoParser
-
-class InfoFileLoader(object):
-
-    def __init__(self, node = None, client_obj = None):
-        if node is None:
-            self._node = RRN
-        else:
-            self._node = node
-        self._client_obj = client_obj
-
-        self._info_parser = InfoParser(self._node,self._client_obj)
-        self._id_manager = LocalIdentifiersManager(self._node,self._client_obj)
-        self._id_util = IdentifierUtil(self._node,self._client_obj)
-
-    def _load_device_identifier(self, info_file, category):
-        
-        if hasattr(info_file,"device_info"):
-            if info_file is not None and info_file.device_info is not None and info_file.device_info.device is not None \
-                and not self._id_util.IsIdentifierAnyName(info_file.device_info.device) and \
-                self._id_util.IsIdentifierAnyUuid(info_file.device_info.device):
-
-                dev_id, lock_fd = self._id_manager.GetIdentifierForNameAndLock(category, info_file.device_info.device.name)
-                info_file.device_info.device = dev_id
-                return True, dev_id,lock_fd
-            return False, None, None
-        elif hasattr(info_file,"device"):
-            if info_file is not None and info_file.device \
-                and not self._id_util.IsIdentifierAnyName(info_file.device) and \
-                self._id_util.IsIdentifierAnyUuid(info_file.device):
-
-                dev_id, lock_fd = self._id_manager.GetIdentifierForNameAndLock(category, info_file.device.name)
-                info_file.device = dev_id
-                return True, dev_id,lock_fd
-            return False, None, None
-        return False, None, None
-
-    def LoadInfoFileFromString(self, info_text, info_type_name, category = "unspecified"):
-        info = self._info_parser.ParseInfoString(info_text, info_type_name)
-        _, _, fds = self._load_device_identifier(info,category)
-        return info, fds
-
-    def LoadInfoFile(self, file_name, info_type_name, category = "unspecified"):
-        info = self._info_parser.ParseInfoFile(file_name, info_type_name)
-        _, _, fds = self._load_device_identifier(info,category)
+import RobotRaconteur as RR
+RRN = RR.RobotRaconteurNode.s
+import numpy as np
+import re
+
+from .LocalIdentifiersManager import LocalIdentifiersManager
+from .IdentifierUtil import IdentifierUtil
+from ..InfoParser import InfoParser
+
+class InfoFileLoader(object):
+    """
+    Utility class to load device info Yaml structures from file
+
+    See the Robot Raconteur camera driver for an example of using this class.
+
+    :param node: (optional) The Robot Raconteur node to use for parsing. Defaults to RobotRaconteurNode.s
+    :type node: RobotRaconteur.RobotRaconteurNode
+    :param client_obj: (optional) The client object to use for finding types. Defaults to None
+    :type client_obj: RobotRaconteur.ClientObject
+    """
+
+    def __init__(self, node = None, client_obj = None):
+        if node is None:
+            self._node = RRN
+        else:
+            self._node = node
+        self._client_obj = client_obj
+
+        self._info_parser = InfoParser(self._node,self._client_obj)
+        self._id_manager = LocalIdentifiersManager(self._node,self._client_obj)
+        self._id_util = IdentifierUtil(self._node,self._client_obj)
+
+    def _load_device_identifier(self, info_file, category):
+        
+        if hasattr(info_file,"device_info"):
+            if info_file is not None and info_file.device_info is not None and info_file.device_info.device is not None \
+                and not self._id_util.IsIdentifierAnyName(info_file.device_info.device) and \
+                self._id_util.IsIdentifierAnyUuid(info_file.device_info.device):
+
+                dev_id, lock_fd = self._id_manager.GetIdentifierForNameAndLock(category, info_file.device_info.device.name)
+                info_file.device_info.device = dev_id
+                return True, dev_id,lock_fd
+            return False, None, None
+        elif hasattr(info_file,"device"):
+            if info_file is not None and info_file.device \
+                and not self._id_util.IsIdentifierAnyName(info_file.device) and \
+                self._id_util.IsIdentifierAnyUuid(info_file.device):
+
+                dev_id, lock_fd = self._id_manager.GetIdentifierForNameAndLock(category, info_file.device.name)
+                info_file.device = dev_id
+                return True, dev_id,lock_fd
+            return False, None, None
+        return False, None, None
+
+    def LoadInfoFileFromString(self, info_text, info_type_name, category = "unspecified"):
+        """
+        Load a device info Yaml structure from a string and assign a device identifier
+
+        In most cases the category should be set to "device".
+
+        :param info_text: The info Yaml structure to load
+        :type info_text: str
+        :param info_type_name: The type name of the info Yaml structure
+        :type info_type_name: str
+        :param category: (optional) The category of the device identifier. Defaults to "unspecified".
+        :type category: str
+        :return: The loaded info Yaml structure and the device identifier lock file descriptor
+        :rtype: tuple
+        """
+        info = self._info_parser.ParseInfoString(info_text, info_type_name)
+        _, _, fds = self._load_device_identifier(info,category)
+        return info, fds
+
+    def LoadInfoFile(self, file_name, info_type_name, category = "unspecified"):
+        """
+        Load a device info Yaml structure from a file and assign a device identifier
+
+        In most cases the category should be set to "device".
+
+        :param file_name: The file name of the info Yaml structure to load
+        :type file_name: str
+        :param info_type_name: The type name of the info Yaml structure
+        :type info_type_name: str
+        :param category: (optional) The category of the device identifier. Defaults to "unspecified".
+        :type category: str
+        :return: The loaded info Yaml structure and the device identifier lock file descriptor
+        :rtype: tuple
+        """
+        info = self._info_parser.ParseInfoFile(file_name, info_type_name)
+        _, _, fds = self._load_device_identifier(info,category)
         return info, fds
```

## RobotRaconteurCompanion/Util/LocalIdentifiersManager.py

```diff
@@ -1,145 +1,78 @@
-
-import os
-import ctypes
-from pathlib import Path
-import re
-import sys
-import RobotRaconteur as RR
-import uuid
-import numpy as np
-import stat
-import errno
-
-if sys.platform == 'win32':
-    import msvcrt
-else:
-    import fcntl
-
-def _get_user_data_path():
-    if sys.platform == 'win32':
-        buf = ctypes.create_unicode_buffer(1024)
-        assert ctypes.windll.shell32.SHGetFolderPathW(None,0x001c | 0x8000, None, 0, buf) == 0
-        p = Path(buf.value).joinpath("RobotRaconteur")
-        p.mkdir(parents = True, exist_ok = True)
-        return p
-    else:
-        path1 = os.environ["HOME"]
-        assert path1 is not None, "Home directory not set"
-        p = Path(path1).joinpath(".config").joinpath("RobotRaconteur")
-        p.mkdir(parents = True, exist_ok = True)
-        return p
-
-def _get_user_run_path():
-    if sys.platform == 'win32':
-        buf = ctypes.create_unicode_buffer(1024)
-        assert ctypes.windll.shell32.SHGetFolderPathW(None,0x001c | 0x8000, None, 0, buf) == 0
-        p = Path(buf.value).joinpath("RobotRaconteur").joinpath("run")
-        p.mkdir(parents = True, exist_ok = True)
-        return p
-    elif sys.platform == 'darwin':
-        u = os.getuid()
-        if u == 0:
-            path = Path("/var/run/robotraconteur/root")
-            path.mkdir(parents = True, exist_ok = True)
-            path.chmod(stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR)
-        else:
-            path1 = os.environ["TMPDIR"]
-            assert path1 is not None, "Could not activate system for local identifier manager"
-            path = Path(path1).parent.joinpath("C")
-            assert path.is_dir(), "Could not activate system for local identifier manager"
-            path = path.joinpath("robotraconteur")
-        path.mkdir(parents = True, exist_ok = True)
-        return path
-    else:
-        u = os.getuid()
-        if u == 0:
-            path = Path("/var/run/robotraconteur/root")
-            path.mkdir(parents = True, exist_ok = True)
-            path.chmod(stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR)
-        else:
-            path1 = os.environ["XDG_RUNTIME_DIR"]
-            assert path1 is not None, "Could not activate system for local identifier manager"
-            path = Path(path1)
-            assert path.is_dir(), "Could not activate system for local identifier manager"
-            path = path.joinpath("robotraconteur")
-        path.mkdir(parents = True, exist_ok = True)
-        return path
-
-def _get_user_identifier_path():
-    p = _get_user_data_path().joinpath("identifiers")
-    p.mkdir(parents = True, exist_ok = True)
-    return p
-
-def _open_lock_write(file_path):    
-    if sys.platform == "win32":
-        fname_buf = ctypes.create_unicode_buffer(str(file_path))
-        h = ctypes.windll.kernel32.CreateFileW(fname_buf, 0x80000000 | 0x40000000, 0x00000001, None, 4, 0x00000080)
-        if h == -1:
-            win_err = ctypes.windll.kernel32.GetLastError()
-            if win_err ==  32:
-                raise RR.InvalidOperationException("Identifier name in use")
-            else:
-                assert False, "Could not activate system for local identifier manager"
-        fd = msvcrt.open_osfhandle(h,os.O_APPEND | os.O_TEXT)
-        f = os.fdopen(fd, "r+",encoding="ascii")
-        return f
-    else:
-        fd1 = os.open(str(file_path),os.O_CLOEXEC | os.O_RDWR | os.O_APPEND | os.O_CREAT, stat.S_IRUSR | stat.S_IWUSR | stat.S_IRGRP | stat.S_IWGRP)        
-        f = os.fdopen(fd1, "r+",encoding="ascii")
-        fcntl.lockf(f,fcntl.LOCK_EX)
-        return f
-        
-
-class LocalIdentifiersManager(object):
-
-    def __init__(self,node,client_object = None):
-        self._node = node
-        self._client_object = client_object
-
-    def GetIdentifierForNameAndLock(self, category, name):
-        
-        assert re.match("^[a-zA-Z][a-zA-Z0-9_\\.\\-]*$",name) is not None, "Invalid identifier name"
-        category2=category.lower()
-
-        p1 = _get_user_identifier_path().joinpath(category)
-        p1.mkdir(parents = True, exist_ok = True)
-        p = p1.joinpath(name)
-
-        if sys.platform == "win32":
-            f = _open_lock_write(p)
-        else:
-            p_lock1 = _get_user_run_path().joinpath("identifiers").joinpath(category)
-            p_lock1.mkdir(parents = True, exist_ok = True)
-            p_lock = p_lock1.joinpath(name + ".pid")
-            f_run = _open_lock_write(p_lock)
-            f_run.seek(0,0)
-            f_run.truncate()
-            f_run.write(str(os.getpid()))
-
-            try:
-                f = _open_lock_write(p)
-            except OSError as x:
-                if x.errno == errno.EROFS:
-                    f = open(p,'r',encoding="ascii")
-                else:
-                    raise
-
-        f.seek(0,0)
-        f_text = f.read()
-        if len(f_text) == 0:
-            ident_uuid = uuid.uuid4()
-            f.write("{" + str(ident_uuid) + "}")
-        else:
-            ident_uuid = uuid.UUID(str(f_text))
-
-        ident_type = self._node.GetStructureType("com.robotraconteur.identifier.Identifier",self._client_object)
-        uuid_dtype = self._node.GetNamedArrayDType("com.robotraconteur.uuid.UUID",self._client_object)
-        ret = ident_type()
-        ret.name = name
-        ret.uuid = np.zeros((1,),dtype=uuid_dtype)
-        ret.uuid["uuid_bytes"] = np.frombuffer(ident_uuid.bytes,dtype=np.uint8)
-        if sys.platform == "win32":
-            return ret,f
-        else:
-            f.close()
-            return ret,f_run
+
+import os
+import ctypes
+from pathlib import Path
+import re
+import sys
+import RobotRaconteur as RR
+import uuid
+import numpy as np
+import stat
+import errno
+
+class _LocalIdentifiersManagerFD(object):
+    """
+    Class to hold lock on device identifier file
+    """
+    def __init__(self,fd):
+        self.fd = fd
+    def __enter__(self):
+        pass
+
+    def __exit__(self, exc_type, exc_value, traceback):
+        if self.fd is not None:
+            fd = self.fd
+            self.fd = None
+            del fd
+
+class LocalIdentifiersManager(object):
+    """
+    Utility class to manage device identifiers and locks
+
+    See the Robot Raconteur camera driver for an example of using this class.
+
+    Users do not normally need to use this class directly.
+
+    :param node: (optional) The Robot Raconteur node to use for parsing. Defaults to RobotRaconteurNode.s
+    :type node: RobotRaconteur.RobotRaconteurNode
+    :param client_object: (optional) The client object to use for finding types. Defaults to None
+    :type client_object: RobotRaconteur.ClientObject
+    """
+
+    def __init__(self,node,client_object = None):
+        self._node = node
+        self._client_object = client_object
+
+    def GetIdentifierForNameAndLock(self, category, name):
+        """
+        Get a device identifier for a given name and lock the identifier file for exclusive access.
+        The category should be "device" for most devices.
+
+        :param category: The category of the identifier
+        :type category: str
+        :param name: The name of the identifier
+        :type name: str
+        :return: The identifier and lock
+        :rtype: (RobotRaconteur.Identifier, LocalIdentifiersManagerFD)
+        """
+        
+        assert re.match("^[a-zA-Z][a-zA-Z0-9_\\.\\-]*$",name) is not None, "Invalid identifier name"
+        category2=category.lower()
+
+        node_dirs = self._node.GetNodeDirectories()
+        p = RR.GetUuidForNameAndLock(node_dirs,name,["identifiers",category2])
+
+        f = p.fd
+        f_text = p.uuid.ToString("D")
+        
+        ident_uuid = uuid.UUID(str(f_text))
+
+        ident_type = self._node.GetStructureType("com.robotraconteur.identifier.Identifier",self._client_object)
+        uuid_dtype = self._node.GetNamedArrayDType("com.robotraconteur.uuid.UUID",self._client_object)
+        ret = ident_type()
+        ret.name = name
+        ret.uuid = np.zeros((1,),dtype=uuid_dtype)
+        ret.uuid["uuid_bytes"] = np.frombuffer(ident_uuid.bytes,dtype=np.uint8)
+        
+        return ret, _LocalIdentifiersManagerFD(f)
+
```

## RobotRaconteurCompanion/Util/RobDef.py

```diff
@@ -1,27 +1,67 @@
-import RobotRaconteur as RR
-import importlib.resources
-
-def register_service_type_from_resource(node, package, resource):
-    robdef_text = get_service_type_from_resource(package,resource)
-    node.RegisterServiceType(robdef_text)
-
-def register_service_types_from_resources(node, package, resources):
-    robdefs_text = get_service_types_from_resources(package,resources)
-    node.RegisterServiceTypes(robdefs_text)
-
-def get_service_type_from_resource(package, resource):
-    ext = ""
-    if importlib.resources.is_resource(package, resource + ".robdef"):
-        ext = ".robdef"    
-    robdef_text = importlib.resources.read_text(package,resource + ext)
-    return robdef_text
-
-def get_service_types_from_resources(package, resources):
-    robdefs_text = []
-    for resource in resources:
-        ext = ""
-        if importlib.resources.is_resource(package, resource + ".robdef"):
-            ext = ".robdef"
-        robdef_text = importlib.resources.read_text(package,resource + ext)
-        robdefs_text.append(robdef_text)
+import RobotRaconteur as RR
+import importlib.resources
+
+def register_service_type_from_resource(node, package, resource):
+    """
+    Register a service type from a package resource
+
+    :param node: The node to register the service type with
+    :type node: RobotRaconteur.RobotRaconteurNode
+    :param package: The package containing the resource
+    :type package: str
+    :param resource: The resource name
+    :type resource: str
+    """
+    robdef_text = get_service_type_from_resource(package,resource)
+    node.RegisterServiceType(robdef_text)
+
+def register_service_types_from_resources(node, package, resources):
+    """
+    Register a list of service types from a package resource
+
+    :param node: The node to register the service types with
+    :type node: RobotRaconteur.RobotRaconteurNode
+    :param package: The package containing the resource
+    :type package: str
+    :param resources: The list of resource names
+    :type resources: list[str]
+    """
+    robdefs_text = get_service_types_from_resources(package,resources)
+    node.RegisterServiceTypes(robdefs_text)
+
+def get_service_type_from_resource(package, resource):
+    """
+    Return the text of a service type from a package resource
+
+    :param package: The package containing the resource
+    :type package: str
+    :param resource: The resource name
+    :type resource: str
+    :return: The service type text
+    :rtype: str
+    """
+    ext = ""
+    if importlib.resources.is_resource(package, resource + ".robdef"):
+        ext = ".robdef"    
+    robdef_text = (importlib.resources.files(package) / (resource + ext)).read_text()
+    return robdef_text
+
+def get_service_types_from_resources(package, resources):
+    """
+    Get a list of service type texts from a package resource
+
+    :param package: The package containing the resource
+    :type package: str
+    :param resources: The list of resource names
+    :type resources: list[str]
+    :return: The list of service type texts
+    :rtype: list[str]
+    """
+    robdefs_text = []
+    for resource in resources:
+        ext = ""
+        if importlib.resources.is_resource(package, resource + ".robdef"):
+            ext = ".robdef"
+        robdef_text = (importlib.resources.read_text(package) / (resource + ext)).read_text()
+        robdefs_text.append(robdef_text)
     return robdefs_text
```

## RobotRaconteurCompanion/Util/RobotUtil.py

```diff
@@ -1,100 +1,133 @@
-import general_robotics_toolbox as rox
-import RobotRaconteur as RR
-RRN = RR.RobotRaconteurNode.s
-import numpy as np
-
-def _check_list(l, error_msg, expected_count = -1):
-    if l is None:
-        raise RR.InvalidArgumentException(error_msg)
-
-    if expected_count >= 0:
-        if len(l) != expected_count:
-            raise RR.InvalidArgumentException(error_msg)
-
-class RobotUtil:
-    def __init__(self, node = None, client_obj = None):
-        if node is None:
-            self._node = RRN
-        else:
-            self._node = node
-        self._client_obj = client_obj
-
-    def robot_info_to_rox_robot(self, robot_info, chain_number):
-        _check_list(robot_info.chains, f"could not find kinematic chain number {chain_number}")
-        if chain_number >= len(robot_info.chains): 
-            raise RR.InvalidArgumentException(f"invalid kinematic chain number {chain_number}")
-
-        chain = robot_info.chains[chain_number]
-        joint_count = len(chain.joint_numbers)
-        for i in range(1,joint_count):
-            if chain.joint_numbers[i-1] >= chain.joint_numbers[i]:
-                raise RR.InvalidArgumentException(f"joint numbers must be increasing in chain number {chain_number}")
-
-            if chain.joint_numbers[i] >= len(robot_info.joint_info):
-                raise RR.InvalidArgumentException(f"joint number out of bounds in chain number {chain_number}")
-
-        _check_list(chain.H, f"invalid shape for H in chain number {chain_number}", joint_count)
-        _check_list(chain.P, f"invalid shape for P in chain number {chain_number}", joint_count + 1)
-
-        H = np.zeros((3, joint_count),dtype=np.float64)
-        for i in range(joint_count):
-            H[0, i] = chain.H[i]["x"]
-            H[1, i] = chain.H[i]["y"]
-            H[2, i] = chain.H[i]["z"]
-
-        P = np.zeros((3, joint_count + 1),dtype=np.float64)
-        for i in range(joint_count+1):
-            P[0, i] = chain.P[i]["x"]
-            P[1, i] = chain.P[i]["y"]
-            P[2, i] = chain.P[i]["z"]
-
-        joint_type = [0]*joint_count
-        joint_lower_limit = np.zeros((joint_count,),dtype=np.float64)
-        joint_upper_limit = np.zeros((joint_count,),dtype=np.float64)
-        joint_vel_limit = np.zeros((joint_count,),dtype=np.float64)
-        joint_acc_limit = np.zeros((joint_count,),dtype=np.float64)
-        joint_names = [None]*joint_count
-
-        for i in range(joint_count):
-            j = robot_info.joint_info[i]
-            if j.joint_type == 1:
-                # Revolute joint
-                joint_type[i] = 0
-            elif j.joint_type == 3:
-                # Prismatic joint
-                joint_type[i] = 1
-            else:
-                raise RR.InvalidArgumentException(f"invalid joint type: {j.joint_type}");                        
-            
-            
-            if j.joint_limits is None:
-                raise RR.InvalidArgumentException("joint_limits must not be null")
-            joint_lower_limit[i] = j.joint_limits.lower
-            joint_upper_limit[i] = j.joint_limits.upper
-            joint_vel_limit[i] = j.joint_limits.velocity
-            joint_acc_limit[i] = j.joint_limits.acceleration
-            if j.joint_identifier is not None:
-                joint_names[i] = j.joint_identifier.name
-            else:
-                joint_names[i] = ""
-
-        root_link_name = None
-        if chain.link_identifiers is not None and len(chain.link_identifiers) > 0 and chain.link_identifiers[0] is not None:
-            root_link_name = chain.link_identifiers[0].name
-
-        tip_link_name = None
-        if chain.flange_identifier is not None:
-            tip_link_name = chain.flange_identifier.name
-        
-        flange_q = chain.flange_pose["orientation"]
-        flange_p = chain.flange_pose["position"]
-
-        r_tool = rox.q2R(self._node.NamedArrayToArray(flange_q).flatten())
-        p_tool = np.array(self._node.NamedArrayToArray(flange_p).flatten())
-
-        rox_robot = rox.Robot(H, P, joint_type, joint_lower_limit, joint_upper_limit, joint_vel_limit,
-            joint_acc_limit, None, r_tool, p_tool, joint_names, root_link_name, tip_link_name)
-
-        return rox_robot
-            
-    
+import general_robotics_toolbox as rox
+import RobotRaconteur as RR
+RRN = RR.RobotRaconteurNode.s
+import numpy as np
+
+def _check_list(l, error_msg, expected_count = -1):
+    if l is None:
+        raise RR.InvalidArgumentException(error_msg)
+
+    if expected_count >= 0:
+        if len(l) != expected_count:
+            raise RR.InvalidArgumentException(error_msg)
+
+class RobotUtil:
+    """
+    Utility class to convert a Robot Raconteur com.robotraconteur.robotics.robot.RobotInfo to
+    a general_robotics_toolbox.Robot object.
+
+    The RobotInfo is provided by robot drivers and is used to describe the kinematics of the robot.
+
+    :param node: (optional) The Robot Raconteur node to use for parsing. Defaults to RobotRaconteurNode.s
+    :type node: RobotRaconteur.RobotRaconteurNode
+    :param client_obj: (optional) The client object to use for finding types. Defaults to None
+    :type client_obj: RobotRaconteur.ClientObject
+    """
+    def __init__(self, node = None, client_obj = None):
+        if node is None:
+            self._node = RRN
+        else:
+            self._node = node
+        self._client_obj = client_obj
+
+    def robot_info_to_rox_robot(self, robot_info, chain_number):
+        """
+        Convert a RobotInfo to a general_robotics_toolbox.Robot object
+
+        :param robot_info: The RobotInfo to convert
+        :type robot_info: com.robotraconteur.robotics.robot.RobotInfo
+        :param chain_number: The kinematic chain number to convert. For a single arm robot, this is 0. 
+            For a dual arm robot, this is 0 for the left arm and 1 for the right arm.
+        :type chain_number: int
+        :return: The converted robot
+        :rtype: general_robotics_toolbox.Robot
+        """
+        _check_list(robot_info.chains, f"could not find kinematic chain number {chain_number}")
+        if chain_number >= len(robot_info.chains): 
+            raise RR.InvalidArgumentException(f"invalid kinematic chain number {chain_number}")
+
+        chain = robot_info.chains[chain_number]
+        joint_count = len(chain.joint_numbers)
+        for i in range(1,joint_count):
+            if chain.joint_numbers[i-1] >= chain.joint_numbers[i]:
+                raise RR.InvalidArgumentException(f"joint numbers must be increasing in chain number {chain_number}")
+
+            if chain.joint_numbers[i] >= len(robot_info.joint_info):
+                raise RR.InvalidArgumentException(f"joint number out of bounds in chain number {chain_number}")
+
+        _check_list(chain.H, f"invalid shape for H in chain number {chain_number}", joint_count)
+        _check_list(chain.P, f"invalid shape for P in chain number {chain_number}", joint_count + 1)
+
+        H = np.zeros((3, joint_count),dtype=np.float64)
+        for i in range(joint_count):
+            H[0, i] = chain.H[i]["x"]
+            H[1, i] = chain.H[i]["y"]
+            H[2, i] = chain.H[i]["z"]
+
+        P = np.zeros((3, joint_count + 1),dtype=np.float64)
+        for i in range(joint_count+1):
+            P[0, i] = chain.P[i]["x"]
+            P[1, i] = chain.P[i]["y"]
+            P[2, i] = chain.P[i]["z"]
+
+        joint_type = [0]*joint_count
+        joint_lower_limit = np.zeros((joint_count,),dtype=np.float64)
+        joint_upper_limit = np.zeros((joint_count,),dtype=np.float64)
+        joint_vel_limit = np.zeros((joint_count,),dtype=np.float64)
+        joint_acc_limit = np.zeros((joint_count,),dtype=np.float64)
+        joint_names = [None]*joint_count
+
+        for i in range(joint_count):
+            j = robot_info.joint_info[i]
+            if j.joint_type == 1:
+                # Revolute joint
+                joint_type[i] = 0
+            elif j.joint_type == 3:
+                # Prismatic joint
+                joint_type[i] = 1
+            else:
+                raise RR.InvalidArgumentException(f"invalid joint type: {j.joint_type}");                        
+            
+            
+            if j.joint_limits is None:
+                raise RR.InvalidArgumentException("joint_limits must not be null")
+            joint_lower_limit[i] = j.joint_limits.lower
+            joint_upper_limit[i] = j.joint_limits.upper
+            joint_vel_limit[i] = j.joint_limits.velocity
+            joint_acc_limit[i] = j.joint_limits.acceleration
+            if j.joint_identifier is not None:
+                joint_names[i] = j.joint_identifier.name
+            else:
+                joint_names[i] = ""
+
+        root_link_name = None
+        if chain.link_identifiers is not None and len(chain.link_identifiers) > 0 and chain.link_identifiers[0] is not None:
+            root_link_name = chain.link_identifiers[0].name
+
+        tip_link_name = None
+        if chain.flange_identifier is not None:
+            tip_link_name = chain.flange_identifier.name
+        
+        flange_q = chain.flange_pose["orientation"]
+        flange_p = chain.flange_pose["position"]
+
+        r_flange = rox.q2R(self._node.NamedArrayToArray(flange_q).flatten())
+        p_flange = np.array(self._node.NamedArrayToArray(flange_p).flatten())
+
+        T_base = None
+        if robot_info.device_info is not None:
+            robot_device_info = robot_info.device_info
+            if robot_device_info.device_origin_pose is not None:
+                robot_origin_pose = robot_device_info.device_origin_pose
+                if robot_origin_pose.pose is not None:
+                    r_base = rox.q2R(self._node.NamedArrayToArray(robot_origin_pose.pose["orientation"]).flatten())
+                    p_base = np.array(self._node.NamedArrayToArray(robot_origin_pose.pose["position"]).flatten())
+                    T_base = rox.Transform(r_base, p_base)
+
+        rox_robot = rox.Robot(H, P, joint_type, joint_lower_limit, joint_upper_limit, joint_vel_limit,
+            joint_acc_limit, joint_names=joint_names, root_link_name=root_link_name, tip_link_name=tip_link_name,
+            T_flange=rox.Transform(r_flange,p_flange), T_base=T_base)
+
+        return rox_robot
+            
+
```

## RobotRaconteurCompanion/Util/RobustFunctionCaller.py

```diff
@@ -1,120 +1,149 @@
-import RobotRaconteur as RR
-RRN = RR.RobotRaconteurNode.s
-import threading
-import traceback
-
-class RobustPollingAsyncFunctionCaller:
-    """
-    Class to call function that is polled periodically, or
-    when requested
-    """
-
-    def __init__(self, f, f_args, retry_backoff = 1, max_retry_attempts = 10, poll_interval = 30, call_timeout = 1, error_handler = None, node = None, client_obj = None):
-        if node is None:
-            self._node = RRN
-        else:
-            self._node = node
-        self._client_obj = client_obj
-
-        self._f = f
-        self._f_args = f_args
-        self._retry_backoff = retry_backoff
-        self._max_retry_attempts = max_retry_attempts
-        self._poll_interval = poll_interval
-        self._lock = threading.RLock()
-        self._error_handler = error_handler
-        self._call_timeout = call_timeout
-        self._refresh_timer = None
-        self._retry_attempts = 0
-
-        self._refreshing = False
-        self._refresh_requested = False
-
-        self._poll_data = RR.EventHook()
-
-        self._poll_timer = self._node.CreateTimer(self._poll_interval, self._handle_poll_timer)
-        self._poll_timer.Start()
-        with self._lock:
-            self._refresh_retry()
-
-    @property
-    def poll_data(self):
-        return self._poll_data
-    @poll_data.setter
-    def poll_data(self,value):
-        assert value == self._poll_data
-
-    def request_poll(self):
-        """
-        Call to request a poll
-        """
-
-        with self._lock:
-            if self._refreshing:
-                self._refresh_requested = True
-                return
-            else:
-                self._do_refresh()
-
-    def _do_refresh(self):
-        try:
-            if len(self._f_args) == 0:
-                self._f(self._refresh_handler,self._call_timeout)
-            else:
-                self._f(*self._f_args,self._refresh_handler,self._call_timeout)
-    
-            self._refreshing = True
-        except Exception as e:
-            try:
-                if self._error_handler is not None:
-                    self._error_handler(e)
-            except:
-                traceback.print_exc()            
-            self._refresh_retry()
-
-    def _refresh_handler(self, val, err):
-        with self._lock:
-            if err is not None:
-                # TODO: log internal error
-                self._refresh_retry()
-                return
-            self._retry_attempts = 0
-        
-        try:
-            self._poll_data.fire(val)
-        except Exception as e:
-            try:
-                if self._error_handler is not None:
-                    self._error_handler(e)
-            except:
-                traceback.print_exc()
-
-        with self._lock:
-            if self._refresh_requested:                
-                self._refresh_retry()
-            else:
-                self._refreshing = False
-
-    def _refresh_retry(self):
-        if self._retry_attempts >= self._max_retry_attempts:
-            return
-        self._refresh_requested = False
-        self._refresh_timer = self._node.CreateTimer(self._retry_backoff, self._refresh_timer_handler, oneshot=True)
-        self._refresh_timer.Start()
-        self._retry_attempts += 1
-
-    def _refresh_timer_handler(self, timer_evt):
-        with self._lock:
-            self._refresh_timer = None
-            self._do_refresh()
-
-    def _handle_poll_timer(self, timer_evt):
-        if timer_evt.stopped:
-            return
-        with self._lock:
-            self._retry_attempts = 0
-        self.request_poll()
-
-    def close(self):
-        self._poll_timer.Stop()
+import RobotRaconteur as RR
+RRN = RR.RobotRaconteurNode.s
+import threading
+import traceback
+
+class RobustPollingAsyncFunctionCaller:
+    """
+    Class to call function that is polled periodically, or
+    when requested
+
+    :param f: The function to call
+    :type f: callable
+    :param f_args: The arguments to pass to the function
+    :type f_args: list
+    :param retry_backoff: The time to wait before retrying a failed call
+    :type retry_backoff: float
+    :param max_retry_attempts: The maximum number of retry attempts
+    :type max_retry_attempts: int
+    :param poll_interval: The polling interval in seconds
+    :type poll_interval: float
+    :param call_timeout: The timeout for the function call
+    :type call_timeout: float
+    :param error_handler: The error handler to call if the function call fails
+    :type error_handler: callable
+    :param node: (optional) The Robot Raconteur node to use for parsing. Defaults to RobotRaconteurNode.s
+    :type node: RobotRaconteur.RobotRaconteurNode
+    :param client_obj: (optional) The client object to use for finding types. Defaults to None
+    :type client_obj: RobotRaconteur.ClientObject
+    """
+
+    def __init__(self, f, f_args, retry_backoff = 1, max_retry_attempts = 10, poll_interval = 30, call_timeout = 1, error_handler = None, node = None, client_obj = None):
+        if node is None:
+            self._node = RRN
+        else:
+            self._node = node
+        self._client_obj = client_obj
+
+        self._f = f
+        self._f_args = f_args
+        self._retry_backoff = retry_backoff
+        self._max_retry_attempts = max_retry_attempts
+        self._poll_interval = poll_interval
+        self._lock = threading.RLock()
+        self._error_handler = error_handler
+        self._call_timeout = call_timeout
+        self._refresh_timer = None
+        self._retry_attempts = 0
+
+        self._refreshing = False
+        self._refresh_requested = False
+
+        self._poll_data = RR.EventHook()
+
+        self._poll_timer = self._node.CreateTimer(self._poll_interval, self._handle_poll_timer)
+        self._poll_timer.Start()
+        with self._lock:
+            self._refresh_retry()
+
+    @property
+    def poll_data(self):
+        """
+        Returns the current polled data
+        """
+        return self._poll_data
+    @poll_data.setter
+    def poll_data(self,value):
+        assert value == self._poll_data
+
+    def request_poll(self):
+        """
+        Call to request a poll
+        """
+
+        with self._lock:
+            if self._refreshing:
+                self._refresh_requested = True
+                return
+            else:
+                self._do_refresh()
+
+    def _do_refresh(self):
+        try:
+            if len(self._f_args) == 0:
+                self._f(self._refresh_handler,self._call_timeout)
+            else:
+                self._f(*self._f_args,self._refresh_handler,self._call_timeout)
+    
+            self._refreshing = True
+        except Exception as e:
+            try:
+                if self._error_handler is not None:
+                    self._error_handler(e)
+            except:
+                traceback.print_exc()
+            try:
+                self._refresh_retry()
+            except RR.InvalidOperationException:
+                pass
+
+
+    def _refresh_handler(self, val, err):
+        with self._lock:
+            if err is not None:
+                # TODO: log internal error
+                self._refresh_retry()
+                return
+            self._retry_attempts = 0
+        
+        try:
+            self._poll_data.fire(val)
+        except Exception as e:
+            try:
+                if self._error_handler is not None:
+                    self._error_handler(e)
+            except:
+                traceback.print_exc()
+
+        with self._lock:
+            if self._refresh_requested:                
+                self._refresh_retry()
+            else:
+                self._refreshing = False
+
+    def _refresh_retry(self):
+        if self._retry_attempts >= self._max_retry_attempts:
+            return
+        self._refresh_requested = False
+        self._refresh_timer = self._node.CreateTimer(self._retry_backoff, self._refresh_timer_handler, oneshot=True)
+        self._refresh_timer.Start()
+        self._retry_attempts += 1
+
+    def _refresh_timer_handler(self, timer_evt):
+        with self._lock:
+            self._refresh_timer = None
+            self._do_refresh()
+
+    def _handle_poll_timer(self, timer_evt):
+        if timer_evt.stopped:
+            return
+        with self._lock:
+            self._retry_attempts = 0
+        self.request_poll()
+
+    def close(self):
+        """
+        Close the polling function caller
+        """
+        self._poll_timer.Stop()
         self._poll_timer = None
```

## RobotRaconteurCompanion/Util/SensorDataUtil.py

```diff
@@ -1,30 +1,46 @@
-import RobotRaconteur as RR
-RRN = RR.RobotRaconteurNode.s
-import numpy as np
-
-from .DateTimeUtil import DateTimeUtil
-
-class SensorDataUtil(object):
-
-    def __init__(self, node = None, client_obj = None):
-        if node is None:
-            self._node = RRN
-        else:
-            self._node = node
-        self._client_obj = client_obj
-
-        self._sensordataheader = self._node.GetStructureType("com.robotraconteur.sensordata.SensorDataHeader", self._client_obj)
-        self._sourceinfo = self._node.GetStructureType("com.robotraconteur.sensordata.SensorDataSourceInfo", self._client_obj)
-        self._pose_dt = self._node.GetNamedArrayDType("com.robotraconteur.geometry.Pose")
-        
-        self._datetime_util = DateTimeUtil(node,client_obj)
-
-    def FillSensorDataHeader(self, device_info, seqno):
-        ret = self._sensordataheader()
-        ret.seqno = seqno
-        ret.ts = self._datetime_util.TimeSpec2Now(device_info)
-        ret.source_info = self._sourceinfo()
-        ret.source_info.source = device_info.device
-        ret.source_info.source_world_pose = np.zeros((1,),self._pose_dt)
-        return ret
-
+import RobotRaconteur as RR
+RRN = RR.RobotRaconteurNode.s
+import numpy as np
+
+from .DateTimeUtil import DateTimeUtil
+
+class SensorDataUtil(object):
+    """
+    Fill in a SensorDataHeader with the current time and sequence number
+
+    :param node: (optional) The Robot Raconteur node to use for parsing. Defaults to RobotRaconteurNode.s
+    :type node: RobotRaconteur.RobotRaconteurNode
+    :param client_obj: (optional) The client object to use for finding types. Defaults to None
+    :type client_obj: RobotRaconteur.ClientObject
+    """
+
+    def __init__(self, node = None, client_obj = None):
+        if node is None:
+            self._node = RRN
+        else:
+            self._node = node
+        self._client_obj = client_obj
+
+        self._sensordataheader = self._node.GetStructureType("com.robotraconteur.sensordata.SensorDataHeader", self._client_obj)
+        self._sourceinfo = self._node.GetStructureType("com.robotraconteur.sensordata.SensorDataSourceInfo", self._client_obj)
+        self._pose_dt = self._node.GetNamedArrayDType("com.robotraconteur.geometry.Pose")
+        
+        self._datetime_util = DateTimeUtil(node,client_obj)
+
+    def FillSensorDataHeader(self, device_info, seqno):
+        """
+        Fill in a SensorDataHeader with the current time and sequence number
+
+        :param device_info: The device info to use for the source info
+        :type device_info: com.robotraconteur.device.DeviceInfo
+        :param seqno: The sequence number to use
+        :type seqno: int
+        """
+        ret = self._sensordataheader()
+        ret.seqno = seqno
+        ret.ts = self._datetime_util.TimeSpec2Now(device_info)
+        ret.source_info = self._sourceinfo()
+        ret.source_info.source = device_info.device
+        ret.source_info.source_world_pose = np.zeros((1,),self._pose_dt)
+        return ret
+
```

## RobotRaconteurCompanion/Util/UuidUtil.py

```diff
@@ -1,35 +1,79 @@
-import RobotRaconteur as RR
-RRN = RR.RobotRaconteurNode.s
-import numpy as np
-import uuid as py_uuid
-
-class UuidUtil(object):
-
-    def __init__(self, node = None, client_obj = None):
-        if node is None:
-            self._node = RRN
-        else:
-            self._node = node
-        self._client_obj = client_obj
-        
-        self._uuid_dt = self._node.GetNamedArrayDType("com.robotraconteur.uuid.UUID", self._client_obj)
-
-    def UuidFromPyUuid(self, py_uuid):
-        ret_bytes = np.frombuffer(py_uuid.bytes,dtype=np.uint8)
-        ret = np.zeros((1,),dtype=self._uuid_dt)
-        ret[0]["uuid_bytes"]=ret_bytes
-        return ret
-
-    def UuidToPyUuid(self, uuid):
-        uuid_bytes = uuid["uuid_bytes"].tobytes()
-        return py_uuid.UUID(bytes=uuid_bytes)
-
-    def NewRandomUuid(self):
-        new_uuid = py_uuid.uuid4()
-        return self.UuidFromPyUuid(new_uuid)
-
-    def ParseUuid(self,uuid_str):
-        return self.UuidFromPyUuid(py_uuid.UUID(uuid_str))
-
-    def UuidToString(self,uuid):
-        return str(self.UuidToPyUuid(uuid))
+import RobotRaconteur as RR
+RRN = RR.RobotRaconteurNode.s
+import numpy as np
+import uuid as py_uuid
+
+class UuidUtil(object):
+    """
+    Utility class for working with Robot Raconteur UUIDs
+
+    :param node: (optional) The Robot Raconteur node to use for parsing. Defaults to RobotRaconteurNode.s
+    :type node: RobotRaconteur.RobotRaconteurNode
+    :param client_obj: (optional) The client object to use for finding types. Defaults to None
+    :type client_obj: RobotRaconteur.ClientObject
+    """
+
+    def __init__(self, node = None, client_obj = None):
+        if node is None:
+            self._node = RRN
+        else:
+            self._node = node
+        self._client_obj = client_obj
+        
+        self._uuid_dt = self._node.GetNamedArrayDType("com.robotraconteur.uuid.UUID", self._client_obj)
+
+    def UuidFromPyUuid(self, py_uuid):
+        """
+        Create a Robot Raconteur UUID from a Python UUID
+
+        :param py_uuid: The Python UUID to convert
+        :type py_uuid: uuid.UUID
+        :return: The Robot Raconteur UUID
+        :rtype: com.robotraconteur.uuid.UUID
+        """
+        ret_bytes = np.frombuffer(py_uuid.bytes,dtype=np.uint8)
+        ret = np.zeros((1,),dtype=self._uuid_dt)
+        ret[0]["uuid_bytes"]=ret_bytes
+        return ret
+
+    def UuidToPyUuid(self, uuid):
+        """
+        Create a Python UUID from a Robot Raconteur UUID
+
+        :param uuid: The Robot Raconteur UUID to convert
+        :type uuid: com.robotraconteur.uuid.UUID
+        :return: The Python UUID
+        :rtype: uuid.UUID
+        """
+        uuid_bytes = uuid["uuid_bytes"].tobytes()
+        return py_uuid.UUID(bytes=uuid_bytes)
+
+    def NewRandomUuid(self):
+        """
+        Create a new random Robot Raconteur UUID
+
+        :return: The new UUID
+        :rtype: com.robotraconteur.uuid.UUID
+        """
+        new_uuid = py_uuid.uuid4()
+        return self.UuidFromPyUuid(new_uuid)
+
+    def ParseUuid(self,uuid_str):
+        """
+        Parse a UUID string into a Robot Raconteur UUID
+
+        :param uuid_str: The UUID string to parse
+        :type uuid_str: str
+        """
+        return self.UuidFromPyUuid(py_uuid.UUID(uuid_str))
+
+    def UuidToString(self,uuid):
+        """
+        Convert a Robot Raconteur UUID to a string
+
+        :param uuid: The Robot Raconteur UUID to convert
+        :type uuid: com.robotraconteur.uuid.UUID
+        :return: The UUID string
+        :rtype: str
+        """
+        return str(self.UuidToPyUuid(uuid))
```

## Comparing `RobotRaconteurCompanion-0.1.9.dist-info/LICENSE.txt` & `RobotRaconteurCompanion-0.2.0.dist-info/LICENSE.txt`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,201 +1,201 @@
-                                Apache License
-                           Version 2.0, January 2004
-                        http://www.apache.org/licenses/
-
-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-   1. Definitions.
-
-      "License" shall mean the terms and conditions for use, reproduction,
-      and distribution as defined by Sections 1 through 9 of this document.
-
-      "Licensor" shall mean the copyright owner or entity authorized by
-      the copyright owner that is granting the License.
-
-      "Legal Entity" shall mean the union of the acting entity and all
-      other entities that control, are controlled by, or are under common
-      control with that entity. For the purposes of this definition,
-      "control" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
-      otherwise, or (ii) ownership of fifty percent (50%) or more of the
-      outstanding shares, or (iii) beneficial ownership of such entity.
-
-      "You" (or "Your") shall mean an individual or Legal Entity
-      exercising permissions granted by this License.
-
-      "Source" form shall mean the preferred form for making modifications,
-      including but not limited to software source code, documentation
-      source, and configuration files.
-
-      "Object" form shall mean any form resulting from mechanical
-      transformation or translation of a Source form, including but
-      not limited to compiled object code, generated documentation,
-      and conversions to other media types.
-
-      "Work" shall mean the work of authorship, whether in Source or
-      Object form, made available under the License, as indicated by a
-      copyright notice that is included in or attached to the work
-      (an example is provided in the Appendix below).
-
-      "Derivative Works" shall mean any work, whether in Source or Object
-      form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
-      represent, as a whole, an original work of authorship. For the purposes
-      of this License, Derivative Works shall not include works that remain
-      separable from, or merely link (or bind by name) to the interfaces of,
-      the Work and Derivative Works thereof.
-
-      "Contribution" shall mean any work of authorship, including
-      the original version of the Work and any modifications or additions
-      to that Work or Derivative Works thereof, that is intentionally
-      submitted to Licensor for inclusion in the Work by the copyright owner
-      or by an individual or Legal Entity authorized to submit on behalf of
-      the copyright owner. For the purposes of this definition, "submitted"
-      means any form of electronic, verbal, or written communication sent
-      to the Licensor or its representatives, including but not limited to
-      communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
-      Licensor for the purpose of discussing and improving the Work, but
-      excluding communication that is conspicuously marked or otherwise
-      designated in writing by the copyright owner as "Not a Contribution."
-
-      "Contributor" shall mean Licensor and any individual or Legal Entity
-      on behalf of whom a Contribution has been received by Licensor and
-      subsequently incorporated within the Work.
-
-   2. Grant of Copyright License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      copyright license to reproduce, prepare Derivative Works of,
-      publicly display, publicly perform, sublicense, and distribute the
-      Work and such Derivative Works in Source or Object form.
-
-   3. Grant of Patent License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      (except as stated in this section) patent license to make, have made,
-      use, offer to sell, sell, import, and otherwise transfer the Work,
-      where such license applies only to those patent claims licensable
-      by such Contributor that are necessarily infringed by their
-      Contribution(s) alone or by combination of their Contribution(s)
-      with the Work to which such Contribution(s) was submitted. If You
-      institute patent litigation against any entity (including a
-      cross-claim or counterclaim in a lawsuit) alleging that the Work
-      or a Contribution incorporated within the Work constitutes direct
-      or contributory patent infringement, then any patent licenses
-      granted to You under this License for that Work shall terminate
-      as of the date such litigation is filed.
-
-   4. Redistribution. You may reproduce and distribute copies of the
-      Work or Derivative Works thereof in any medium, with or without
-      modifications, and in Source or Object form, provided that You
-      meet the following conditions:
-
-      (a) You must give any other recipients of the Work or
-          Derivative Works a copy of this License; and
-
-      (b) You must cause any modified files to carry prominent notices
-          stating that You changed the files; and
-
-      (c) You must retain, in the Source form of any Derivative Works
-          that You distribute, all copyright, patent, trademark, and
-          attribution notices from the Source form of the Work,
-          excluding those notices that do not pertain to any part of
-          the Derivative Works; and
-
-      (d) If the Work includes a "NOTICE" text file as part of its
-          distribution, then any Derivative Works that You distribute must
-          include a readable copy of the attribution notices contained
-          within such NOTICE file, excluding those notices that do not
-          pertain to any part of the Derivative Works, in at least one
-          of the following places: within a NOTICE text file distributed
-          as part of the Derivative Works; within the Source form or
-          documentation, if provided along with the Derivative Works; or,
-          within a display generated by the Derivative Works, if and
-          wherever such third-party notices normally appear. The contents
-          of the NOTICE file are for informational purposes only and
-          do not modify the License. You may add Your own attribution
-          notices within Derivative Works that You distribute, alongside
-          or as an addendum to the NOTICE text from the Work, provided
-          that such additional attribution notices cannot be construed
-          as modifying the License.
-
-      You may add Your own copyright statement to Your modifications and
-      may provide additional or different license terms and conditions
-      for use, reproduction, or distribution of Your modifications, or
-      for any such Derivative Works as a whole, provided Your use,
-      reproduction, and distribution of the Work otherwise complies with
-      the conditions stated in this License.
-
-   5. Submission of Contributions. Unless You explicitly state otherwise,
-      any Contribution intentionally submitted for inclusion in the Work
-      by You to the Licensor shall be under the terms and conditions of
-      this License, without any additional terms or conditions.
-      Notwithstanding the above, nothing herein shall supersede or modify
-      the terms of any separate license agreement you may have executed
-      with Licensor regarding such Contributions.
-
-   6. Trademarks. This License does not grant permission to use the trade
-      names, trademarks, service marks, or product names of the Licensor,
-      except as required for reasonable and customary use in describing the
-      origin of the Work and reproducing the content of the NOTICE file.
-
-   7. Disclaimer of Warranty. Unless required by applicable law or
-      agreed to in writing, Licensor provides the Work (and each
-      Contributor provides its Contributions) on an "AS IS" BASIS,
-      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-      implied, including, without limitation, any warranties or conditions
-      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
-      PARTICULAR PURPOSE. You are solely responsible for determining the
-      appropriateness of using or redistributing the Work and assume any
-      risks associated with Your exercise of permissions under this License.
-
-   8. Limitation of Liability. In no event and under no legal theory,
-      whether in tort (including negligence), contract, or otherwise,
-      unless required by applicable law (such as deliberate and grossly
-      negligent acts) or agreed to in writing, shall any Contributor be
-      liable to You for damages, including any direct, indirect, special,
-      incidental, or consequential damages of any character arising as a
-      result of this License or out of the use or inability to use the
-      Work (including but not limited to damages for loss of goodwill,
-      work stoppage, computer failure or malfunction, or any and all
-      other commercial damages or losses), even if such Contributor
-      has been advised of the possibility of such damages.
-
-   9. Accepting Warranty or Additional Liability. While redistributing
-      the Work or Derivative Works thereof, You may choose to offer,
-      and charge a fee for, acceptance of support, warranty, indemnity,
-      or other liability obligations and/or rights consistent with this
-      License. However, in accepting such obligations, You may act only
-      on Your own behalf and on Your sole responsibility, not on behalf
-      of any other Contributor, and only if You agree to indemnify,
-      defend, and hold each Contributor harmless for any liability
-      incurred by, or claims asserted against, such Contributor by reason
-      of your accepting any such warranty or additional liability.
-
-   END OF TERMS AND CONDITIONS
-
-   APPENDIX: How to apply the Apache License to your work.
-
-      To apply the Apache License to your work, attach the following
-      boilerplate notice, with the fields enclosed by brackets "[]"
-      replaced with your own identifying information. (Don't include
-      the brackets!)  The text should be enclosed in the appropriate
-      comment syntax for the file format. We also recommend that a
-      file or class name and description of purpose be included on the
-      same "printed page" as the copyright notice for easier
-      identification within third-party archives.
-
-   Copyright 2011-2020 Wason Technology, LLC
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
+                                Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright 2011-2020 Wason Technology, LLC
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
    limitations under the License.
```

## Comparing `RobotRaconteurCompanion-0.1.9.dist-info/RECORD` & `RobotRaconteurCompanion-0.2.0.dist-info/RECORD`

 * *Files 6% similar despite different names*

```diff
@@ -1,67 +1,65 @@
-RobotRaconteurCompanion/__init__.py,sha256=7_TRIMQccjnmJtIfbJhSNeCTcOidyGV5ddOSLgRCw9g,367
-RobotRaconteurCompanion/InfoParser/__init__.py,sha256=LH83wF3oX8juwTyAHA1RsbPJ6yqdG2P0okXu5F5Tiac,11362
-RobotRaconteurCompanion/StdRobDef/__init__.py,sha256=TzXqk_uP0vtVIW-NQIoMakUlMFdNxvef8u9y6GqofKg,2150
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.action.robdef,sha256=gTkvtUdPLZZlSLE-_Hv-1LVPnz18NBilgFgb10Ttqd8,195
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.actuator.robdef,sha256=Td5dU4z8HH_Z3bUCcvVDKdTpyk5C-fpEgTmd90Z7l80,2291
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.bignum.robdef,sha256=VTxJfpsgF1acspdM9aNDvFn3OP1sCV-59hvwjsW2wyo,393
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.color.robdef,sha256=2YKsZegpYTYafKgs4Wbbg6mHwvcWioKUfK-dwrirHX4,836
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.datatype.robdef,sha256=Q7zqsok36Oees_0oSoscIP5wlIsZN-5betCXsDha8ac,1066
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.datetime.clock.robdef,sha256=D5da42_Zdylgt7RN1mEWpPVjei3jPMce2sSOoI088BU,1076
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.datetime.robdef,sha256=7qBbR1X70VyqVU5wtTgBAbIjEUyCwS2HG6S6TJfW6_o,1492
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.device.clock.robdef,sha256=-ttwdWEcSgP71RaqvbMZTs83OdhAYJ4UpcpkGl3vvD0,390
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.device.isoch.robdef,sha256=7J8d2LVcFS3c306ld7Bi_nHPIWga-vw0SpSmMQEGlRE,392
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.device.robdef,sha256=UI_stTfVubYU7epLUPvMXkPN1Ezw_NxMxFSqiD9AQHc,1690
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.eventlog.robdef,sha256=UtLhfp1H7BE4jsqB9uvE-pn7KQDKrVkRY-Q_H2bQJO4,1906
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.fiducial.robdef,sha256=pNCgzs_sx4ATrOP--Jnp_Yr-TQ_g8AxnCD-32lGOpis,3195
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.geometry.robdef,sha256=krUHyaDCpyPVJwKtCEiwuhCcn4o7CAKUwKr9kS9EXbc,3013
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.geometry.shapes.robdef,sha256=GyaMFTtR-7bybP0P16zcfHK5frH_UAxa0oeA03WMeV0,2193
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.geometryf.robdef,sha256=36g9oVvcGMyUPsBfaAIkFl1a02-7_Qu4lt2EwAaRm_4,3014
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.geometryi.robdef,sha256=aFPt0gXS71J4nnRbzbAbM40Giqhus5nyU0fSpD-jVxA,2978
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.gps.robdef,sha256=iNb0dgZ9CuC3_jm_1Y8qTY_-vsfvzGw1luWjmzX44wI,2552
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.hid.joystick.robdef,sha256=i45t-mdaW6iBdXAop3IZ7TzcO2dQV2jW-2moaFlJGRc,3076
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.identifier.robdef,sha256=Lww5KpWjkqjuEPNialfWYvbzGEt34lH_ZOqRh6cYuug,196
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.image.robdef,sha256=2GlAoczZ2ifaRaLdprNgAx2Yor9Rpt58W-8gZNASlBY,2583
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.imaging.camerainfo.robdef,sha256=eMVRUrYqRChsRu6yjp_kjhiAwg9jDewSf9ipykLogeo,1048
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.imaging.robdef,sha256=Ls42legpe7pQsx9VqvsEdUn0aatvEuGvMcW64J2k1EM,4237
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.imu.robdef,sha256=QaS_gpdmpNfz_umF5QVp-egUF1_hK5RsGnD51qpLuCI,1187
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.laserscan.robdef,sha256=xU6F2VjFgVgYeGdE1wiXdRhgGPJ1vJUR7HhGVwFMgB4,2204
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.laserscanner.robdef,sha256=8i6vjKFxESWXDO3Y-t70deGOns8Lq9PAnjuYS1zdkg4,1315
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.lighting.robdef,sha256=vpkAYzVlD2_EUPL1xod8Q5wmI8UBJUSyalcyzLGXdRQ,1081
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.objectrecognition.robdef,sha256=sUsYraEzgDveTLe7dRV0INvKcsM-WDPkGw_CGGt8tyk,3061
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.octree.robdef,sha256=6A-y9_ABjtD78-oM6E6rrGQmPU8vTaWuR1fsk5EPOUA,939
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.param.robdef,sha256=h7uM-VlloMPjrO-nqS7uVuYEzo4NXiBu0NL7wU5GHmU,747
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.pid.robdef,sha256=Bl_KSEA65bkhMvYpSC7abezUFZayzcS--9LtGSxzehM,229
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.pointcloud.robdef,sha256=jGcQp-ST-KFasu0Lv4hBFZYZ56m0EHF56gfx620heTA,2929
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.pointcloud.sensor.robdef,sha256=XS7SEJgDh0AMxsCwWd2v1B1SLquNRuUWvyO2m1gMF0Q,4624
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.resource.device.robdef,sha256=RYXiVO3y7yGTbscRnsfMmV9ehuEhcEz0Ep2eU2RyiSI,1539
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.resource.robdef,sha256=smtoQEhEetVtznG3i9PBfIjmhRCK1gO2LI8zuItXKO8,2137
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.robotics.joints.robdef,sha256=YpBFPan5srrG4hsJ3_g2q3e3QeypqF2Pef9YTcLK-RI,2297
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.robotics.payload.robdef,sha256=DElYyNrcUQWX-lTVXZkhKP9dw-QMWchrI1NZHQ_gmnQ,521
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.robotics.planning.robdef,sha256=9QBXtRI044HhXNi652Z7AUYImxK9RqNSTEf_DJvC9Eg,10184
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.robotics.robot.robdef,sha256=n0v1CJFXvkqw2lgiuh0Q7YGtxSTIN8BjxOoMXLbYtSE,8700
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.robotics.scene.robdef,sha256=Js_AX-BAnsemqCspDF5Wki1aR6e8SsNntC819wS4E8Q,2041
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.robotics.tool.robdef,sha256=UGCiP0uvo0hXmzCLFRvMvvVbvGRPgZqjG9BMYjily3I,3731
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.robotics.trajectory.robdef,sha256=FKDXhjlHBNTczxmjUjITpssR3PmP1mZZE2RGY4n3ELY,3060
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.sensor.robdef,sha256=hFWVLS-BV2_KKYXQfjeVCeuBavZM5Oh1hYmEfDZOmVA,5569
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.sensordata.robdef,sha256=4Rkd1JjZ7JnuZ5zM12pAdSnxFYqz7CvS5dwB_Kznt-Q,641
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.servo.robdef,sha256=IU4iECEmSTV3sTd8dNaIxGBqcg6Ig-LFHh5OBzZMQTQ,4308
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.signal.robdef,sha256=Mcm_59rk6x7B7M0RcXdLZJeX2QkWNGwbG5hhMd54AaM,2625
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.units.robdef,sha256=l2rMBUyTfaNj3EIUsrbbjRfrUushTRm0uVbEn0O0x48,135
-RobotRaconteurCompanion/StdRobDef/com.robotraconteur.uuid.robdef,sha256=oUg5mATaqt-n7ZPiji_yZgSUaFN-zNaqM4kvRnnDmBE,104
-RobotRaconteurCompanion/Util/AttributesUtil.py,sha256=sw63eeXevn3pry5mPceXrCbYLadXqKGamx3b7x7LHtc,1438
-RobotRaconteurCompanion/Util/DateTimeUtil.py,sha256=cunaf8rxOKDba7lGxgQj6HKkpVNbvN4LkpwZH2pgmEg,2651
-RobotRaconteurCompanion/Util/GeometryUtil.py,sha256=wnXYHqs7aFEeE8mXm2L72Q2mO2FXGqb4hsLWmKUsHVI,14718
-RobotRaconteurCompanion/Util/IdentifierUtil.py,sha256=-XMm76PIHYseS-SMpKr1LisKXqImRKD_QKQMciAlZ8o,4081
-RobotRaconteurCompanion/Util/ImageUtil.py,sha256=LlPRp4fiaurAnHcUbacoa_va6s1RcWtq0B-M4D3b1oc,7999
-RobotRaconteurCompanion/Util/InfoFileLoader.py,sha256=bobLdRwh1QdCWnsw9uOPvuhV5CyCzNbVDNFUOGGKJoI,2416
-RobotRaconteurCompanion/Util/LocalIdentifiersManager.py,sha256=_d3EeAz0w0n8lp3BRCW0t9CFJbhXQ3ILW_f48UhPydw,5604
-RobotRaconteurCompanion/Util/RobDef.py,sha256=e6pVOwfrKUTnx0G3FtFIqZapfRjZilH1En_2KXxp3YE,1077
-RobotRaconteurCompanion/Util/RobotUtil.py,sha256=8UIJ2gnFvxbqi4zBEuY2oOXqg_SfkRn3lW-WQgkWXOA,4269
-RobotRaconteurCompanion/Util/RobustFunctionCaller.py,sha256=Ix-cLfVWCBeNQCTs7BFKLMzoB6IckiqAsSn4JGDBlXw,3741
-RobotRaconteurCompanion/Util/SensorDataUtil.py,sha256=hv0ZscpN_X4L5t9KORRmjwv7mRjeHua7iv-zW4GvlHs,1162
-RobotRaconteurCompanion/Util/UuidUtil.py,sha256=yLV6poiOO6qVWkSSvAbh3l1xPU2egrFJoyQyXuyVEo0,1090
-RobotRaconteurCompanion-0.1.9.dist-info/LICENSE.txt,sha256=Tl1tRxWGtrUEp-8aQr9k8kNBVeVc0FnOcSY8m7eKPfc,11554
-RobotRaconteurCompanion-0.1.9.dist-info/METADATA,sha256=8KmqFq9dlOUOBeX-Fu36oiJHfjtDhv-XZhhXGI2Y1Ec,528
-RobotRaconteurCompanion-0.1.9.dist-info/WHEEL,sha256=D1Wh14kWDxPnrM-5t_6UCB-UuQNrEODtRa3vF4OsvQY,97
-RobotRaconteurCompanion-0.1.9.dist-info/top_level.txt,sha256=sTqNX_M_WXwgaIkdMUK-MsOwxqglJ42PnGGm02zuBZY,24
-RobotRaconteurCompanion-0.1.9.dist-info/RECORD,,
+RobotRaconteurCompanion/__init__.py,sha256=5pDj61pZm4eO6ehFpv51CcStsdcoFWeaiKmpwoAtjG4,355
+RobotRaconteurCompanion/InfoParser/__init__.py,sha256=1iUjworxm1fRBqGqspvdLS5Hw_dc2tsuKo2L9kvFi6U,13037
+RobotRaconteurCompanion/StdRobDef/__init__.py,sha256=dV-W4H2lFkTnwzgkhN6zE48CVSbhJOzNLlILF77ji5g,2454
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.action.robdef,sha256=tSpFycEMsweyCn_kDCu9estB8r4WHVMk2gqoZVxd-fc,182
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.actuator.robdef,sha256=Upm7zm2LEvEXlIdzE7eKoOEionIuwK8aEpyYlwVGh1o,2197
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.bignum.robdef,sha256=Hut-XwPMyUpQbbN9hvtofeLbMv7iXX8X4OD2zYowtks,373
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.color.robdef,sha256=eqoWr20K_zXev3N0gauF0ez9LvQ3E5310DuasduYrTA,781
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.datatype.robdef,sha256=ywZqPsoP3nUYss-g-TMhDcheeQTP59L3xkO9JpcFsmA,1005
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.datetime.clock.robdef,sha256=g36ZhChPtRr9t-_fjDANpm4T4MZj6hu0uDLBGAGR2ck,1042
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.datetime.robdef,sha256=isHRA0onDOpM0WyGWgfXETSB27llwXbZiD86Th1c5lc,1415
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.device.clock.robdef,sha256=QN0xJHwf2z_pfbDTsERc1j8ozcuUMsTX0gh4Pj8eXWQ,372
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.device.isoch.robdef,sha256=IyfxcTHFiLhGiDOEAhF1M8r5E17D-wBVSpXMHb8gZHM,374
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.device.robdef,sha256=p744JCbJjd1tiUtwi9gIrpjCfth9UfOYZzLV1oOi4Ro,1626
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.eventlog.robdef,sha256=Nh3M0-W0Xjq0XmPraj-xJ18aCxKW_G-Vm-QMBl-5aaM,1835
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.fiducial.robdef,sha256=fbyUWqXCFS9fX1-m9KeRafhtw1J6H28ZmhOkUGFjLh0,3100
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.geometry.robdef,sha256=kRJhQMm5dPcSqGq9tMiVnigJipxU0ft0xSffdb-IvrE,2840
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.geometry.shapes.robdef,sha256=xHoSOvTRKSy_6MZlp1tBNpFNAhTHNIZrtQQFx9X2JEk,2094
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.geometryf.robdef,sha256=QAjmZ5vw_u-PLudGbXW3ldXgZ6VWNW7uBGdX8yMvlUE,2841
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.geometryi.robdef,sha256=tNYf1kIuckeR03ZFX7nsLwW7JcM6T0wBkJ0Mz8uXaek,2805
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.gps.robdef,sha256=q_xVTcel96rQgC7rN35BeP1PdaV7NVOJwORfXrJWEec,2454
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.hid.joystick.robdef,sha256=ZNEOdBh0Tlk7SCY710ufgZ8hPbu9w0hylrOAJ_co5Rg,2967
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.identifier.robdef,sha256=vYH1VvpHfnn_kVwUg0aLwfpkU1ByqD1hVJ37jlqKMKg,184
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.image.robdef,sha256=P1ATO8fwthHqOnwNgp8G1hi0OnuydDTCD1C_zH71PL8,2459
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.imaging.camerainfo.robdef,sha256=QsSvcIzc56047pa87eXdorF1QW0sF4EDRSv32m1Ao14,1006
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.imaging.robdef,sha256=RVKYSB_bukOxJl6-Udf0OEiwmvF8-2trxWWX7il8sJU,4111
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.imu.robdef,sha256=-sVhslHwSqE25DMShII0tORXMhXhE4u61dPXRsBcO2g,1151
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.laserscan.robdef,sha256=Us6walbjeD-_dOvfK1Olsf8UuRMCBqDolxFllJyZyUA,2121
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.laserscanner.robdef,sha256=3j_WCdlraVAO9ikv00AhOWooauyRWqPj0jMdNMrd_dQ,1277
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.lighting.robdef,sha256=UnYQXXeNvDL8Wh9h4hRREWt_bCvfdGbo9ZYY13_ivyQ,1039
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.objectrecognition.robdef,sha256=JL3M8SjLGyeOzN1RKNMOdmC93HwNeA0vNNXT--cFA3M,2978
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.octree.robdef,sha256=XTMYKRDbpGxT4kWPofHO5yFUekVuX5Qza1CBeyM83WU,896
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.param.robdef,sha256=vCbLc7dHptNLaxqCEMf01q4WEYgZeX76RY3rbDA8BPE,721
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.pid.robdef,sha256=o8VBKAPz44h1bn6eG8WCgo_GkhaPk8t5UZEJfnL1FFk,216
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.pointcloud.robdef,sha256=y64N2nazbO7W7oESknbTrJplMGlX7ihfjEvmLHSXGhw,2813
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.pointcloud.sensor.robdef,sha256=d3tI28llWV_aRvwN5plILzTWfROLcduQdWC5ONzbLv4,4502
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.resource.device.robdef,sha256=T2_JMV7klXdM7kuRMNxPQ_QMgoViVo8Pbmzp9vEldp8,1506
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.resource.robdef,sha256=o58N7drMOzACZAvP7PqmiQImvPqNMN6_Yl8N0lX5CBU,2073
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.robotics.joints.robdef,sha256=ChQlQNHG_oJU7ZJf9IcOHcv_azq47zXJr93cS9-VPjA,2182
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.robotics.payload.robdef,sha256=WOBzNrMBaVWcO6BYB7nflIVr8noO341O79h0RjrpAa0,502
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.robotics.robot.robdef,sha256=uP5uey_sjJZkZTwVGH2kw5xQJAtUpDKULzVM-oKNRo0,8441
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.robotics.tool.robdef,sha256=WBB1k6MWjbSNOwq1gyIccL9Nd1LM1C4tR1Xk5VMVQB8,3601
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.robotics.trajectory.robdef,sha256=T-k20QUec1Yy88w1XCr5j9OCRRnVbBbvJgSV5M6HSkY,2952
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.sensor.robdef,sha256=LqVKrzxdTNAGEnGoifn6kzFLYe17J4jpdHvj8Ag3rPk,5361
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.sensordata.robdef,sha256=p3XUaXU75dRX71hesSSlmwvjcd5Gfc57SijKP8xgaFQ,616
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.servo.robdef,sha256=NTetK8yAtz0C15wY6Ly7SIR-K28WaxQtRXLQnseYByE,4166
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.signal.robdef,sha256=AaDGpKtCt97MFIlrsnpnH6U0P0cATkGSyVanTNntcT0,2522
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.units.robdef,sha256=JRiuyq4h292pzIxU7KRXz2bNOxb58pcm1xwXHSsxXnw,127
+RobotRaconteurCompanion/StdRobDef/com.robotraconteur.uuid.robdef,sha256=qU8KeGvSV3psmzeCaCoYYy43ueLPWTlMUicqHwkqcVA,97
+RobotRaconteurCompanion/Util/AttributesUtil.py,sha256=B_IIejK6wobQo_eoQF37z1n-MWbyw2OXR5WVo49PYoI,2456
+RobotRaconteurCompanion/Util/DateTimeUtil.py,sha256=kn37kE7G9VbH-81SuONl3GxvxtC7oGWeJzJF4Kcrm-I,5188
+RobotRaconteurCompanion/Util/GeometryUtil.py,sha256=mIq_m_MSVHvl2kz48qC65hrF4w0AY9P1IjZafo-46tA,31608
+RobotRaconteurCompanion/Util/IdentifierUtil.py,sha256=jluZ7-5-hpoXmOnBit3I2Iq_x-BZ0mUrsKUCVr63xAo,7229
+RobotRaconteurCompanion/Util/ImageUtil.py,sha256=-X7T16CHFw_BCUlaneC6J-jdwlsLFOkye8w6BVHRM0g,10396
+RobotRaconteurCompanion/Util/InfoFileLoader.py,sha256=lKheRuD3nDpKxixilbdOTRNRZczijR9yT28_jSKtQ4Y,4070
+RobotRaconteurCompanion/Util/LocalIdentifiersManager.py,sha256=LRniZERZpGaS3WaH3IYBs7vD_gM08hwi6fHaaMoSOKU,2553
+RobotRaconteurCompanion/Util/RobDef.py,sha256=gymQkCKp6vRTL7T1DnvS7GvEPs-plJH0zR52ILAzii8,2327
+RobotRaconteurCompanion/Util/RobotUtil.py,sha256=hqRx6eknVlHPTLtHHUm86KyiHIALW75BuKyIvq47UMk,5951
+RobotRaconteurCompanion/Util/RobustFunctionCaller.py,sha256=MOtFXjiiCavTCY-s0EYTiJop-8LoEK9DENyhWg6WvgI,4768
+RobotRaconteurCompanion/Util/SensorDataUtil.py,sha256=hetl60vn3ceybppP40moIedSHkKO-0xhiZAv2nkoB4Y,1834
+RobotRaconteurCompanion/Util/UuidUtil.py,sha256=4xK7MwI8XuYYyBVqmlhgs3HFv-GmEGf1lgKs9PxhTRE,2473
+RobotRaconteurCompanion-0.2.0.dist-info/LICENSE.txt,sha256=qGxBeReM7Xcl1sVO7Ht_vdVDXh4zuXiYtEFIqk1pqHM,11354
+RobotRaconteurCompanion-0.2.0.dist-info/METADATA,sha256=vREbBeIvVg7IhveaYuTNXUFF_5zngDqcuIv0rnhTQ0w,547
+RobotRaconteurCompanion-0.2.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+RobotRaconteurCompanion-0.2.0.dist-info/top_level.txt,sha256=sTqNX_M_WXwgaIkdMUK-MsOwxqglJ42PnGGm02zuBZY,24
+RobotRaconteurCompanion-0.2.0.dist-info/RECORD,,
```

