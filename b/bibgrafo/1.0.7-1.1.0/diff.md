# Comparing `tmp/bibgrafo-1.0.7-py3-none-any.whl.zip` & `tmp/bibgrafo-1.1.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,25 +1,25 @@
-Zip file size: 40891 bytes, number of entries: 23
+Zip file size: 40963 bytes, number of entries: 23
 -rw-rw-r--  2.0 unx        0 b- defN 22-Jun-30 23:02 bibgrafo/__init__.py
--rw-rw-r--  2.0 unx     3773 b- defN 23-Jun-22 13:10 bibgrafo/aresta.py
+-rw-rw-r--  2.0 unx     3984 b- defN 23-Jul-09 20:00 bibgrafo/aresta.py
 -rw-rw-r--  2.0 unx     6855 b- defN 23-Jun-22 13:10 bibgrafo/grafo.py
 -rw-rw-r--  2.0 unx      713 b- defN 23-Jun-22 13:10 bibgrafo/grafo_errors.py
 -rw-rw-r--  2.0 unx      155 b- defN 22-Jun-30 23:02 bibgrafo/grafo_exceptions.py
--rw-rw-r--  2.0 unx    12940 b- defN 23-Jun-22 13:10 bibgrafo/grafo_lista_adj.py
+-rw-rw-r--  2.0 unx    12909 b- defN 23-Jul-09 19:23 bibgrafo/grafo_lista_adj.py
 -rw-rw-r--  2.0 unx    12940 b- defN 22-Sep-08 02:44 bibgrafo/grafo_lista_adjacencia.py
--rw-rw-r--  2.0 unx    17623 b- defN 23-Jun-22 13:10 bibgrafo/grafo_matriz_adj_dir.py
--rw-rw-r--  2.0 unx    16842 b- defN 23-Jun-22 13:10 bibgrafo/grafo_matriz_adj_nao_dir.py
+-rw-rw-r--  2.0 unx    17615 b- defN 23-Jul-09 19:54 bibgrafo/grafo_matriz_adj_dir.py
+-rw-rw-r--  2.0 unx    16840 b- defN 23-Jul-09 19:53 bibgrafo/grafo_matriz_adj_nao_dir.py
 -rw-rw-r--  2.0 unx     2754 b- defN 23-Jun-22 13:10 bibgrafo/vertice.py
 -rw-rw-r--  2.0 unx      163 b- defN 22-Sep-08 02:33 bibgrafo/__pycache__/__init__.cpython-310.pyc
 -rw-rw-r--  2.0 unx     4336 b- defN 22-Sep-08 02:33 bibgrafo/__pycache__/aresta.cpython-310.pyc
 -rw-rw-r--  2.0 unx     8151 b- defN 22-Sep-08 02:33 bibgrafo/__pycache__/grafo.cpython-310.pyc
 -rw-rw-r--  2.0 unx     1167 b- defN 22-Sep-08 02:33 bibgrafo/__pycache__/grafo_errors.cpython-310.pyc
 -rw-rw-r--  2.0 unx      602 b- defN 22-Sep-08 02:33 bibgrafo/__pycache__/grafo_exceptions.cpython-310.pyc
 -rw-rw-r--  2.0 unx    12527 b- defN 22-Sep-08 02:33 bibgrafo/__pycache__/grafo_lista_adjacencia.cpython-310.pyc
 -rw-rw-r--  2.0 unx    14589 b- defN 22-Sep-08 02:33 bibgrafo/__pycache__/grafo_matriz_adj_dir.cpython-310.pyc
 -rw-rw-r--  2.0 unx    12844 b- defN 22-Sep-08 02:33 bibgrafo/__pycache__/grafo_matriz_adj_nao_dir.cpython-310.pyc
 -rw-rw-r--  2.0 unx     3478 b- defN 22-Sep-08 02:33 bibgrafo/__pycache__/vertice.cpython-310.pyc
--rw-rw-r--  2.0 unx      234 b- defN 23-Jun-22 19:34 bibgrafo-1.0.7.dist-info/METADATA
--rw-rw-r--  2.0 unx       92 b- defN 23-Jun-22 19:34 bibgrafo-1.0.7.dist-info/WHEEL
--rw-rw-r--  2.0 unx        9 b- defN 23-Jun-22 19:34 bibgrafo-1.0.7.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     2091 b- defN 23-Jun-22 19:34 bibgrafo-1.0.7.dist-info/RECORD
-23 files, 134878 bytes uncompressed, 37441 bytes compressed:  72.2%
+-rw-rw-r--  2.0 unx      234 b- defN 23-Jul-09 20:06 bibgrafo-1.1.0.dist-info/METADATA
+-rw-rw-r--  2.0 unx       92 b- defN 23-Jul-09 20:06 bibgrafo-1.1.0.dist-info/WHEEL
+-rw-rw-r--  2.0 unx        9 b- defN 23-Jul-09 20:06 bibgrafo-1.1.0.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     2091 b- defN 23-Jul-09 20:06 bibgrafo-1.1.0.dist-info/RECORD
+23 files, 135048 bytes uncompressed, 37513 bytes compressed:  72.2%
```

## zipnote {}

```diff
@@ -51,20 +51,20 @@
 
 Filename: bibgrafo/__pycache__/grafo_matriz_adj_nao_dir.cpython-310.pyc
 Comment: 
 
 Filename: bibgrafo/__pycache__/vertice.cpython-310.pyc
 Comment: 
 
-Filename: bibgrafo-1.0.7.dist-info/METADATA
+Filename: bibgrafo-1.1.0.dist-info/METADATA
 Comment: 
 
-Filename: bibgrafo-1.0.7.dist-info/WHEEL
+Filename: bibgrafo-1.1.0.dist-info/WHEEL
 Comment: 
 
-Filename: bibgrafo-1.0.7.dist-info/top_level.txt
+Filename: bibgrafo-1.1.0.dist-info/top_level.txt
 Comment: 
 
-Filename: bibgrafo-1.0.7.dist-info/RECORD
+Filename: bibgrafo-1.1.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## bibgrafo/aresta.py

```diff
@@ -79,14 +79,22 @@
         Args:
             v: O vértice que se deseja verificar se é ponta da aresta.
         Returns:
             True se for ponta da aresta ou False, caso contrário.
         """
         return v == self._v1 or v == self._v2
 
+    def vertice_oposto(self, v: Vertice):
+        """
+        Provê o vértice oposto ao vértice passado como parâmetro
+        """
+        if v == self.v1:
+            return self.v2
+        return self.v1
+
     def __eq__(self, other):
         """
         É chamado quando se tenta usar o operador de igualdade entre uma Aresta e outro objeto.
         Args:
             other: O outro objeto que se deseja verificar a igualdade.
         Returns:
             True se os objetos forem iguais ou False, caso contrário.
```

## bibgrafo/grafo_lista_adj.py

```diff
@@ -8,16 +8,16 @@
 
 class GrafoListaAdjacencia(GrafoIF):
 
     """
     Esta classe representa um grafo com implementação interna em lista de adjacência
 
     Attributes:
-        _vertices (list): Uma lista dos vértices (ou nodos) do grafo.
-        _arestas: Uma dicionário que guarda as arestas do grafo. A chave representa o nome da aresta e o valor é um
+        vertices (list): Uma lista dos vértices (ou nodos) do grafo.
+        arestas: Uma dicionário que guarda as arestas do grafo. A chave representa o nome da aresta e o valor é um
         objeto do tipo Aresta que deve conter referências para os vértices
     """
 
     _vertices: list
     _arestas: dict
 
     def __init__(self, vertices=None, arestas=None):
@@ -58,15 +58,15 @@
     def vertices(self, novos_vertices):
         if novos_vertices is None:
             novos_vertices = list()
         else:
             for v in novos_vertices:
                 if not(GrafoListaAdjacencia.vertice_valido(v)):
                     raise VerticeInvalidoError('O vértice ' + v + ' é inválido')
-        self._vertices = deepcopy(novos_vertices)
+        self.vertices = deepcopy(novos_vertices)
 
     @property
     def arestas(self):
         """ dict: Um dicionário de arestas. """
         return self._arestas
 
     @arestas.setter
@@ -74,15 +74,15 @@
         if novas_arestas is None:
             novas_arestas = dict()
         else:
             for a in novas_arestas:
                 if not(self.aresta_valida(novas_arestas[a])):
                     raise ArestaInvalidaError('A aresta ' + novas_arestas[a] + ' é inválida')
 
-        self._arestas = deepcopy(novas_arestas)
+        self.arestas = deepcopy(novas_arestas)
 
     @classmethod
     def vertice_valido(cls, vertice: Vertice) -> bool:
         """
         Verifica se um vértice passado como parâmetro está dentro do padrão estabelecido.
         O rótulo do vértice não pode ser vazio.
         Args:
@@ -95,15 +95,15 @@
     def existe_vertice(self, vertice: Vertice) -> bool:
         """
         Verifica se um vértice passado como parâmetro pertence ao grafo.
         Args:
             vertice: O vértice que deve ser verificado.
         Return: Um valor booleano que indica se o vértice existe no grafo.
         """
-        return GrafoListaAdjacencia.vertice_valido(vertice) and vertice in self._vertices
+        return GrafoListaAdjacencia.vertice_valido(vertice) and vertice in self.vertices
 
     def existe_rotulo_vertice(self, rotulo: str) -> bool:
         """
         Verifica se há algum vértice no grafo com o rótulo que é passado como parâmetro.
         Args:
             rotulo: O vértice que deve ser verificado.
         Returns:
@@ -122,85 +122,85 @@
         Returns:
             Um objeto do tipo vértice que tem como rótulo o parâmetro passado
         Raises:
             VerticeInvalidoError se o vértice não for encontrado.
         """
         if not self.existe_rotulo_vertice(rotulo):
             raise VerticeInvalidoError("O vértice não existe no grafo.")
-        for i in range(len(self._vertices)):
-            if self._vertices[i].rotulo == rotulo:
-                return self._vertices[i]
+        for i in range(len(self.vertices)):
+            if self.vertices[i].rotulo == rotulo:
+                return self.vertices[i]
 
     @dispatch(str)
     def adiciona_vertice(self, rotulo: str):
         """
         Adiciona um vértice no Grafo caso o vértice seja válido e não exista outro vértice com o mesmo nome
         Args:
             rotulo: O rótulo do vértice a ser adicionado
         Raises:
             VerticeInvalidoError se já houver um vértice com o mesmo nome no grafo
         """
         if not self.existe_rotulo_vertice(rotulo):
-            self._vertices.append(Vertice(rotulo))
+            self.vertices.append(Vertice(rotulo))
         else:
             raise VerticeInvalidoError('O rótulo de vértice ' + rotulo + ' já existe no grafo')
 
     @dispatch(Vertice)
     def adiciona_vertice(self, v: Vertice):
         """
         Adiciona um vértice no Grafo caso o vértice seja válido e não exista outro vértice com o mesmo nome
         Args:
             v: O vértice a ser adicionado
         Raises:
             VerticeInvalidoError se o vértice passado como parâmetro não puder ser adicionado
         """
         if self.vertice_valido(v) and not self.existe_vertice(v) and not self.existe_rotulo_vertice(v.rotulo()):
-            self._vertices.append(v)
+            self.vertices.append(v)
         else:
             raise VerticeInvalidoError('O vértice ' + str(v) + ' é inválido ou já existe no grafo')
 
     def remove_vertice(self, v: str):
         """
         Remove um vértice que tenha o rótulo passado como parâmetro e remove em cascata as arestas que estão
         conectadas a esse vértice.
         Args:
             v: O rótulo do vértice a ser removido.
         Raises:
             VerticeInvalidoError se o vértice passado como parâmetro não existir no grafo.
         """
         newA = dict()
         if self.existe_rotulo_vertice(v):
-            self._vertices.remove(v)
-            for a in self._arestas.keys():
-                if not(self._arestas[a].eh_ponta(v)):
-                    newA[a] = self._arestas[a]
-            self._arestas = newA
+            self.vertices.remove(v)
+            for a in self.arestas.keys():
+                if not(self.arestas[a].eh_ponta(v)):
+                    newA[a] = self.arestas[a]
+            self.arestas = newA
         else:
             raise VerticeInvalidoError('O vértice {} não existe no grafo.'.format(v))
 
     def existe_rotulo_aresta(self, r=''):
         """
         Verifica se um rótulo de aresta passada como parâmetro pertence ao grafo.
         Args:
             r: O rótulo da aresta a ser verificada
         Returns:
             Um valor booleano que indica se o rótulo da aresta existe no grafo.
         """
-        return r in self._arestas
+        return r in self.arestas
 
     def get_aresta(self, r):
         """
         Retorna uma referência para a aresta que tem o rótulo passado como parâmetro
         Args:
             r: O rótulo da aresta solicitada
         Returns:
             Um objeto do tipo Aresta que é uma referência para a aresta requisitada ou False se a aresta não existe
         """
         if self.existe_rotulo_aresta(r):
-            return self._arestas[r]
+            return self.arestas[r]
         return False
     
     def aresta_valida(self, aresta: Aresta):
         """
         Verifica se uma aresta passada como parâmetro está dentro do padrão estabelecido.
         Uma aresta só é válida se conectar dois vértices existentes no grafo e for uma instância da classe Aresta.
         Args:
@@ -224,15 +224,15 @@
         Returns:
             True se a aresta foi adicionada com sucesso
         Raises:
             ArestaInvalidaError se a aresta passada como parâmetro não puder ser adicionada
         """
         if self.aresta_valida(a):
             if not self.existe_rotulo_aresta(a.rotulo):  # Verifica se a aresta já existe no grafo
-                self._arestas[a.rotulo] = a
+                self.arestas[a.rotulo] = a
             else:
                 raise ArestaInvalidaError('A aresta {} não pode ter o mesmo rótulo de uma aresta já existente'
                                           'no grafo'.format(str(a)))
         else:
             raise ArestaInvalidaError('A aresta ' + str(a) + ' é inválida')
         return True
 
@@ -275,52 +275,52 @@
         Remove uma aresta a partir de seu rótulo.
         Args:
             r: O rótulo da aresta a ser removida.
         Raises:
             ArestaInvalidaError se a aresta passada como parâmetro não puder ser removida.
         """
         if self.existe_rotulo_aresta(r):
-            self._arestas.pop(r)
+            self.arestas.pop(r)
         else:
             raise ArestaInvalidaError('A aresta {} não existe no grafo'.format(r))
 
     def __eq__(self, other):
         """
         Define a igualdade entre a instância do GrafoListaAdjacencia para o qual essa função foi chamada e a
         instância de um GrafoListaAdjacencia passado como parâmetro.
         Args:
             other: O grafo que deve ser comparado com este grafo.
         Returns:
             Um valor booleano caso os grafos sejam iguais.
         """
-        if len(self._arestas) != len(other._arestas) or len(self._vertices) != len(other._vertices):
+        if len(self.arestas) != len(other.arestas) or len(self.vertices) != len(other.vertices):
             return False
-        for n in self._vertices:
+        for n in self.vertices:
             if not other.existe_vertice(n):
                 return False
-        for a in self._arestas:
+        for a in self.arestas:
             if not self.existe_rotulo_aresta(a) or not other.existe_rotulo_aresta(a):
                 return False
-            if not self._arestas[a] == other.get_aresta(a):
+            if not self.arestas[a] == other.get_aresta(a):
                 return False
         return True
 
     def __str__(self):
         """
         Fornece uma representação do tipo String do grafo. O String contém um sequência dos vértices separados por
         vírgula, seguido de uma sequência das arestas no formato padrão.
         Returns:
             Uma string que representa o grafo.
         """
         grafo_str = ''
 
-        for v in range(len(self._vertices)):
-            grafo_str += str(self._vertices[v])
-            if v < (len(self._vertices) - 1):  # Só coloca a vírgula se não for o último vértice
+        for v in range(len(self.vertices)):
+            grafo_str += str(self.vertices[v])
+            if v < (len(self.vertices) - 1):  # Só coloca a vírgula se não for o último vértice
                 grafo_str += ", "
 
         grafo_str += '\n'
 
-        for i, a in enumerate(self._arestas):
-            grafo_str += str(self._arestas[a]) + '\n'
+        for i, a in enumerate(self.arestas):
+            grafo_str += str(self.arestas[a]) + '\n'
 
         return grafo_str
```

## bibgrafo/grafo_matriz_adj_dir.py

```diff
@@ -7,22 +7,22 @@
 
 class GrafoMatrizAdjacenciaDirecionado(GrafoIF):
 
     """
     Esta classe representa um grafo direcionado com implementação interna em matriz de adjacência
 
     Attributes:
-        _vertices (list): Uma lista dos vértices (ou nodos) do grafo.
-        _matriz: Uma matriz de adjacência que guarda as arestas do grafo. Cada entrada da matriz tem um
+        vertices (list): Uma lista dos vértices (ou nodos) do grafo.
+        matriz: Uma matriz de adjacência que guarda as arestas do grafo. Cada entrada da matriz tem um
         dicionário de arestas (objetos do tipo Aresta) para que seja possível representar arestas paralelas
         e que cada aresta tenha seus próprios atributos distintos.
     """
 
     _vertices: list
-    _matriz: list
+    _arestas: list
 
     def __init__(self, vertices: list = None, matriz: list = None):
         """
         Constrói um objeto do tipo grafo direcionado com matriz de adjacência.
         Se nenhum parâmetro for passado, cria um grafo vazio.
         Se houver alguma aresta ou algum vértice inválido, uma exceção é lançada.
         Args:
@@ -40,31 +40,31 @@
         for v in vertices:
             if not (GrafoMatrizAdjacenciaDirecionado.vertice_valido(v)):
                 raise VerticeInvalidoError('O vértice ' + v + ' é inválido.')
 
         self._vertices = deepcopy(vertices)
 
         if not matriz:
-            self._matriz = list()
+            self._arestas = list()
             for k in range(len(vertices)):
-                self._matriz.append(list())
+                self.arestas.append(list())
                 for m in range(len(vertices)):
-                    self._matriz[k].append(dict())
+                    self.arestas[k].append(dict())
 
-        if len(self._matriz) != len(vertices):
+        if len(self.arestas) != len(vertices):
             raise MatrizInvalidaError('A matriz passada como parâmetro não tem o tamanho correto.')
 
-        for c in self._matriz:
+        for c in self.arestas:
             if len(c) != len(vertices):
                 raise MatrizInvalidaError('A matriz passada como parâmetro não tem o tamanho correto.')
 
         # Verifica se as arestas passadas na matriz são válidas
         for i in range(len(vertices)):
             for j in range(len(vertices)):
-                dicio_aresta = self._matriz[i][j]
+                dicio_aresta = self.arestas[i][j]
                 for k in dicio_aresta.values():
                     aresta = dicio_aresta[k]
                     if not (self.aresta_valida(aresta)):
                         raise ArestaInvalidaError('A aresta ' + aresta + ' é inválida.')
 
     @property
     def vertices(self):
@@ -76,41 +76,41 @@
         if novos_vertices is None:
             vertices = list()
 
         for v in vertices:
             if not (GrafoMatrizAdjacenciaDirecionado.vertice_valido(v)):
                 raise VerticeInvalidoError('O vértice ' + v + ' é inválido')
 
-        self._vertices = deepcopy(vertices)
+        self.vertices = deepcopy(vertices)
 
     @property
-    def matriz(self):
+    def arestas(self):
         """ list: Uma matriz de arestas. """
-        return self._matriz
+        return self._arestas
 
-    @matriz.setter
-    def matriz(self, nova_matriz):
+    @arestas.setter
+    def arestas(self, nova_matriz):
         if not nova_matriz:
-            self._matriz = list()
+            self.arestas = list()
             for k in range(len(self.vertices)):
-                self._matriz.append(list())
+                self.arestas.append(list())
                 for m in range(len(self.vertices)):
-                    self._matriz[k].append(dict())
+                    self.arestas[k].append(dict())
 
-        if len(self._matriz) != len(self.vertices):
+        if len(self.arestas) != len(self.vertices):
             raise MatrizInvalidaError('A matriz passada como parâmetro não tem o tamanho correto')
 
-        for c in self._matriz:
+        for c in self.arestas:
             if len(c) != len(self.vertices):
                 raise MatrizInvalidaError('A matriz passada como parâmetro não tem o tamanho correto')
 
         # Verifica se as arestas passadas na matriz são válidas
         for i in range(len(self.vertices)):
             for j in range(len(self.vertices)):
-                dicio_aresta = self._matriz[i][j]
+                dicio_aresta = self.arestas[i][j]
                 for k in dicio_aresta.values():
                     aresta = dicio_aresta[k]
                     if not (self.aresta_valida(aresta)):
                         raise ArestaInvalidaError('A aresta ' + aresta + ' é inválida')
 
     @classmethod
     def vertice_valido(cls, vertice: Vertice) -> bool:
@@ -128,26 +128,26 @@
         """
         Verifica se um vértice passado como parâmetro pertence ao grafo.
         Args:
             vertice: O vértice que deve ser verificado.
         Returns:
             Um valor booleano que indica se o vértice existe no grafo.
         """
-        return GrafoMatrizAdjacenciaDirecionado.vertice_valido(vertice) and vertice in self._vertices
+        return GrafoMatrizAdjacenciaDirecionado.vertice_valido(vertice) and vertice in self.vertices
 
     def get_vertice(self, rotulo: str):
         """
         Retorna o objeto do tipo vértice que tem como rótulo o parâmetro passado.
         Args:
             rotulo: O rótulo do vértice a ser retornado
         Returns:
             Um objeto do tipo vértice que tem como rótulo o parâmetro passado ou False se o vértice não
             for encontrado.
         """
-        for i in self._vertices:
+        for i in self.vertices:
             if rotulo == i.rotulo:
                 return i
 
     def existe_rotulo_vertice(self, rotulo: str):
         """
         Verifica se há algum vértice no grafo com o rótulo que é passado como parâmetro.
         Args:
@@ -162,15 +162,15 @@
         Dado um vértice retorna o índice do vértice na lista de vértices.
         Pode ser usado para indexar a matriz.
         Args:
             v: O vértice a ser analisado
         Returns:
             O índice do primeiro vértice da aresta na lista de vértices
         """
-        return self._vertices.index(v)
+        return self.vertices.index(v)
 
     @dispatch(str)
     def adiciona_vertice(self, rotulo: str):
         """
         Inclui um vértice no grafo a partir de um rotulo. É criado um objeto do tipo Vertice com o rotulo inserido.
         Args:
             rotulo: O rótulo do vértice a ser incluído no grafo.
@@ -178,21 +178,21 @@
             VerticeInvalidoException: se o vértice já existe ou se ele não estiver no formato válido.
         """
         if self.existe_rotulo_vertice(rotulo):
             raise VerticeInvalidoError('O vértice {} já existe'.format(rotulo))
 
         if rotulo != "":
 
-            self._vertices.append(Vertice(rotulo))  # Adiciona vértice na lista de vértices
-            self._matriz.append([])  # Adiciona a linha
+            self.vertices.append(Vertice(rotulo))  # Adiciona vértice na lista de vértices
+            self.arestas.append([])  # Adiciona a linha
 
-            for k in range(len(self._vertices)):
-                self._matriz[k].append(dict())  # adiciona os elementos da coluna do vértice
-                if k != len(self._vertices) - 1:
-                    self._matriz[self.indice_do_vertice(self.get_vertice(rotulo))].append(
+            for k in range(len(self.vertices)):
+                self.arestas[k].append(dict())  # adiciona os elementos da coluna do vértice
+                if k != len(self.vertices) - 1:
+                    self.arestas[self.indice_do_vertice(self.get_vertice(rotulo))].append(
                         dict())  # adiciona um zero no último elemento da linha
         else:
             raise VerticeInvalidoError('O vértice ' + rotulo + ' é inválido')
 
     @dispatch(Vertice)
     def adiciona_vertice(self, v: Vertice):
         """
@@ -203,21 +203,21 @@
             VerticeInvalidoException: se o vértice já existe ou se ele não estiver no formato válido.
         """
         if self.existe_vertice(v):
             raise VerticeInvalidoError('O vértice {} já existe'.format(v))
 
         if self.vertice_valido(v):
 
-            self._vertices.append(v)  # Adiciona vértice na lista de vértices
-            self._matriz.append([])  # Adiciona a linha
+            self.vertices.append(v)  # Adiciona vértice na lista de vértices
+            self.arestas.append([])  # Adiciona a linha
 
-            for k in range(len(self._vertices)):
-                self._matriz[k].append(dict())  # adiciona os elementos da coluna do vértice
-                if k != len(self._vertices) - 1:
-                    self._matriz[self._vertices.index(v)].append(dict())  # adiciona um zero no último elemento da linha
+            for k in range(len(self.vertices)):
+                self.arestas[k].append(dict())  # adiciona os elementos da coluna do vértice
+                if k != len(self.vertices) - 1:
+                    self.arestas[self.vertices.index(v)].append(dict())  # adiciona um zero no último elemento da linha
 
         else:
             raise VerticeInvalidoError('O vértice ' + str(v) + ' é inválido')
 
     def remove_vertice(self, rotulo: str):
         """
         Remove um vértice do grafo a partir do rótulo do vértice.
@@ -231,20 +231,20 @@
         if not self.existe_rotulo_vertice(rotulo):
             raise VerticeInvalidoError("O vértice passado como parâmetro não existe no grafo.")
 
         v = self.get_vertice(rotulo)
 
         v_i = self.indice_do_vertice(v)
 
-        self._matriz.pop(v_i)
+        self.arestas.pop(v_i)
 
-        for i in range(len(self._matriz)):
-            self._matriz[i].pop(v_i)
+        for i in range(len(self.arestas)):
+            self.arestas[i].pop(v_i)
 
-        self._vertices.remove(v)
+        self.vertices.remove(v)
         return True
 
     def aresta_valida(self, aresta: ArestaDirecionada):
         """
         Verifica se uma aresta passada como parâmetro está dentro do padrão estabelecido.
         Uma aresta só é válida se conectar dois vértices existentes no grafo.
         Args:
@@ -265,15 +265,15 @@
         Args:
             aresta: A aresta a ser verificada.
         Returns:
             Um valor booleano que indica se a aresta existe no grafo.
         """
         if GrafoMatrizAdjacenciaDirecionado.aresta_valida(self, aresta):
             if aresta.rotulo in \
-                    self._matriz[self.indice_do_vertice(aresta.v1)][self.indice_do_vertice(aresta.v2)]:
+                    self.arestas[self.indice_do_vertice(aresta.v1)][self.indice_do_vertice(aresta.v2)]:
                 return True
         return False
 
     @dispatch(ArestaDirecionada)
     def adiciona_aresta(self, aresta: ArestaDirecionada):
         """
         Adiciona uma aresta ao grafo.
@@ -284,15 +284,15 @@
         """
         if self.existe_aresta(aresta):
             raise ArestaInvalidaError('A aresta {} já existe no Grafo'.format(aresta))
 
         if self.aresta_valida(aresta):
             i_a1 = self.indice_do_vertice(aresta.v1)
             i_a2 = self.indice_do_vertice(aresta.v2)
-            self._matriz[i_a1][i_a2][aresta.rotulo] = aresta
+            self.arestas[i_a1][i_a2][aresta.rotulo] = aresta
         else:
             raise ArestaInvalidaError('A aresta {} é inválida'.format(aresta))
 
         return True
 
     @dispatch(str, str, str, int)
     def adiciona_aresta(self, rotulo: str, v1: str, v2: str, peso=1):
@@ -354,95 +354,95 @@
                 for m in arestas_percorrer:
                     if r == m:
                         arestas_percorrer.pop(r)
                         return True
 
         if v1 is None:
             if v2 is None:
-                for i in range(len(self._matriz)):
-                    for j in range(len(self._matriz)):
-                        arestas = self._matriz[i][j]
+                for i in range(len(self.arestas)):
+                    for j in range(len(self.arestas)):
+                        arestas = self.arestas[i][j]
                         for k in arestas:
                             if r == k:
                                 arestas.pop(r)
                                 return True
                 return False
             elif self.existe_rotulo_vertice(v2):
                 v2_i = self.indice_do_vertice(self.get_vertice(v1))
-                percorre_e_remove(self._matriz, v2_i)
+                percorre_e_remove(self.arestas, v2_i)
             elif not self.existe_rotulo_vertice(v2):
                 raise VerticeInvalidoError("O vértice {} é inválido!".format(v2))
 
         else:
             if self.existe_rotulo_vertice(v1):
                 v1_i = self.indice_do_vertice(self.get_vertice(v1))
                 if self.existe_rotulo_vertice(v2):
                     v2_i = self.indice_do_vertice(self.get_vertice(v1))
 
-                    arestas = self._matriz[v1_i][v2_i]
+                    arestas = self.arestas[v1_i][v2_i]
                     for k in arestas:
                         if r == k:
                             arestas.pop(r)
                             return True
                     return False
                 else:
-                    return percorre_e_remove(self._matriz, v1_i)
+                    return percorre_e_remove(self.arestas, v1_i)
             else:
                 raise VerticeInvalidoError("O vértice {} é inválido!".format(v1))
 
     def __eq__(self, other):
         """
         Define a igualdade entre a instância do grafo para o qual essa função foi chamada e a instância de um
         GrafoMatrizAdjacenciaDirecionado passado como parâmetro.
         Args:
             other: O grafo que deve ser comparado com este grafo.
         Returns:
             Um valor booleano caso os grafos sejam iguais.
         """
-        if len(self.matriz) != len(other.matriz) or len(self.vertices) != len(other.vertices):
+        if len(self.arestas) != len(other.arestas) or len(self.vertices) != len(other.vertices):
             return False
         for n in self.vertices:
             if not other.existe_vertice(n):
                 return False
-        for i in range(len(self.matriz)):
-            for j in range(len(self.matriz)):
-                if len(self.matriz[i][j]) != len(other.matriz[i][j]):
+        for i in range(len(self.arestas)):
+            for j in range(len(self.arestas)):
+                if len(self.arestas[i][j]) != len(other.arestas[i][j]):
                     return False
-                for k in self.matriz[i][j]:
-                    if k not in other.matriz[i][j]:
+                for k in self.arestas[i][j]:
+                    if k not in other.arestas[i][j]:
                         return False
         return True
 
     def __str__(self):
         """
         Fornece uma representação do tipo String do grafo.
         Returns:
             Uma string que representa o grafo
         """
 
         grafo_str = '  '
 
-        for v in range(len(self._vertices)):
-            grafo_str += str(self._vertices[v])
-            if v < (len(self._vertices) - 1):  # Só coloca o espaço se não for o último vértice
+        for v in range(len(self.vertices)):
+            grafo_str += str(self.vertices[v])
+            if v < (len(self.vertices) - 1):  # Só coloca o espaço se não for o último vértice
                 grafo_str += ' '
 
         grafo_str += '\n'
 
-        for m in range(len(self._matriz)):
-            grafo_str += str(self._vertices[m]) + ' '
-            for c in range(len(self._matriz)):
-                if bool(self._matriz[m][c]):
+        for m in range(len(self.arestas)):
+            grafo_str += str(self.vertices[m]) + ' '
+            for c in range(len(self.arestas)):
+                if bool(self.arestas[m][c]):
                     grafo_str += '*' + ' '
                 else:
                     grafo_str += 'o' + ' '
             grafo_str += '\n'
 
-        for m in range(len(self._vertices)):
-            for c in range(len(self._vertices)):
-                if bool(self._matriz[m][c]):
-                    grafo_str += str(self._vertices[m]) + '-' + str(self._vertices[c]) + ': '
-                    for k in self._matriz[m][c]:
+        for m in range(len(self.vertices)):
+            for c in range(len(self.vertices)):
+                if bool(self.arestas[m][c]):
+                    grafo_str += str(self.vertices[m]) + '-' + str(self.vertices[c]) + ': '
+                    for k in self.arestas[m][c]:
                         grafo_str += k
                     grafo_str += '\n'
 
         return grafo_str
```

## bibgrafo/grafo_matriz_adj_nao_dir.py

```diff
@@ -8,132 +8,132 @@
 
 class GrafoMatrizAdjacenciaNaoDirecionado(GrafoMatrizAdjacenciaDirecionado):
 
     """
     Esta classe representa um grafo com implementação interna em lista de adjacência
 
     Attributes:
-        _vertices (list): Uma lista dos vértices (ou nodos) do grafo.
-        _arestas: Uma dicionário que guarda as arestas do grafo. A chave representa o nome da aresta e o valor é um
+        vertices (list): Uma lista dos vértices (ou nodos) do grafo.
+        arestas: Uma dicionário que guarda as arestas do grafo. A chave representa o nome da aresta e o valor é um
         objeto do tipo Aresta que deve conter referências para os vértices
     """
 
     _vertices: list
-    _matriz: list
+    _arestas: list
 
-    def __init__(self, vertices=None, matriz=None):
+    def __init__(self, vertices=None, arestas=None):
         """
         Constrói um objeto do tipo grafo não direcionado com matriz de adjacência.
         Se nenhum parâmetro for passado, cria um grafo vazio.
         Se houver alguma aresta ou algum vértice inválido, uma exceção é lançada.
         :param vertices: Uma lista dos vértices (ou nodos) do grafo.
-        :param matriz: Uma matriz de adjacência que guarda as arestas do grafo. Cada entrada da matriz tem um
+        :param arestas: Uma matriz de adjacência que guarda as arestas do grafo. Cada entrada da matriz tem um
         dicionário de arestas (objetos do tipo Aresta) para que seja possível representar arestas paralelas
         e que cada aresta tenha seus próprios atributos distintos. Como a matriz é não direcionada, os elementos
         abaixo da diagonal principal são espelhados em relação aos elementos acima da diagonal principal.
         """
 
         if vertices is None:
             vertices = list()
-        if matriz is None:
-            matriz = list()
+        if arestas is None:
+            arestas = list()
 
         for v in vertices:
             if not(GrafoMatrizAdjacenciaNaoDirecionado.vertice_valido(v)):
                 raise VerticeInvalidoError('O vértice ' + v + ' é inválido')
 
-        self._vertices = deepcopy(vertices)
+        self.vertices = deepcopy(vertices)
 
-        if not matriz:
-            self._matriz = list()
+        if not arestas:
+            self._arestas = list()
             for k in range(len(vertices)):
-                self._matriz.append(list())
+                self._arestas.append(list())
                 for m in range(len(vertices)):
-                    self._matriz[k].append(dict())
+                    self._arestas[k].append(dict())
 
-        if len(self._matriz) != len(vertices):
+        if len(self._arestas) != len(vertices):
             raise MatrizInvalidaError('A matriz passada como parâmetro não tem o mesmo tamanho da quantidade de'
                                       'vértices')
 
-        for c in self._matriz:
+        for c in self._arestas:
             if len(c) != len(vertices):
                 raise MatrizInvalidaError('A matriz passada como parâmetro não tem o tamanho correto')
 
         for i in range(len(vertices)):
             for j in range(len(vertices)):
                 '''
                 Verifica se cada elemento da matriz é um dicionário de arestas válidas
                 '''
-                if type(self._matriz[i][j]) is not dict:
+                if type(self.arestas[i][j]) is not dict:
                     raise MatrizInvalidaError("Algum elemento da matriz não é um dicionário de arestas")
                 else:
-                    dicio_aresta = self._matriz[i][j]
+                    dicio_aresta = self.arestas[i][j]
                 for k in dicio_aresta.values():
                     aresta = Aresta(k, dicio_aresta[k].v1(), dicio_aresta[k].v2())
                     if not(self.aresta_valida(aresta)):
                         raise ArestaInvalidaError('A aresta ' + str(aresta) + ' é inválida')
 
-                if i != j and self._matriz[i][j] != self._matriz[j][i]:
+                if i != j and self.arestas[i][j] != self.arestas[j][i]:
                     raise MatrizInvalidaError('A matriz não representa uma matriz de grafo não direcionado')
 
     @property
     def vertices(self):
         """ list: Uma lista de vértices. """
         return self._vertices
 
     @vertices.setter
     def vertices(self, novos_vertices):
         if novos_vertices is None:
-            novos_vertices = list()
+            novosvertices = list()
 
         for v in novos_vertices:
             if not (GrafoMatrizAdjacenciaNaoDirecionado.vertice_valido(v)):
                 raise VerticeInvalidoError('O vértice ' + v + ' é inválido')
 
         self._vertices = deepcopy(novos_vertices)
 
     @property
-    def matriz(self):
+    def arestas(self):
         """ list: Uma matriz de arestas. """
-        return self._matriz
+        return self._arestas
 
-    @matriz.setter
-    def matriz(self, nova_matriz):
+    @arestas.setter
+    def arestas(self, nova_matriz):
         if nova_matriz is None:
-            matriz = list()
-        if not matriz:
-            self._matriz = list()
+            arestas = list()
+        if not arestas:
+            self.arestas = list()
             for k in range(len(self.vertices)):
-                self._matriz.append(list())
+                self.arestas.append(list())
                 for m in range(len(self.vertices)):
-                    self._matriz[k].append(dict())
+                    self.arestas[k].append(dict())
 
-        if len(self._matriz) != len(self.vertices):
+        if len(self.arestas) != len(self.vertices):
             raise MatrizInvalidaError('A matriz passada como parâmetro não tem o mesmo tamanho da quantidade de'
                                       'vértices')
 
-        for c in self._matriz:
+        for c in self.arestas:
             if len(c) != len(self.vertices):
                 raise MatrizInvalidaError('A matriz passada como parâmetro não tem o tamanho correto')
 
         for i in range(len(self.vertices)):
             for j in range(len(self.vertices)):
                 '''
                 Verifica se cada elemento da matriz é um dicionário de arestas válidas
                 '''
-                if type(self._matriz[i][j]) is not dict:
+                if type(self.arestas[i][j]) is not dict:
                     raise MatrizInvalidaError("Algum elemento da matriz não é um dicionário de arestas")
                 else:
-                    dicio_aresta = self._matriz[i][j]
+                    dicio_aresta = self.arestas[i][j]
                 for k in dicio_aresta.values():
                     aresta = Aresta(k, dicio_aresta[k].v1(), dicio_aresta[k].v2())
                     if not(self.aresta_valida(aresta)):
                         raise ArestaInvalidaError('A aresta ' + str(aresta) + ' é inválida')
 
-                if i != j and self._matriz[i][j] != self._matriz[j][i]:
+                if i != j and self.arestas[i][j] != self.arestas[j][i]:
                     raise MatrizInvalidaError('A matriz não representa uma matriz de grafo não direcionado')
 
     @dispatch(str)
     def adiciona_vertice(self, rotulo: str):
         """
         Inclui um vértice no grafo se ele estiver no formato correto.
         Args:
@@ -143,22 +143,22 @@
         """
         if self.existe_rotulo_vertice(rotulo):
             raise VerticeInvalidoError('O vértice {} já existe'.format(rotulo))
 
         if rotulo != "":
 
             v = Vertice(rotulo)
-            self._vertices.append(v)  # Adiciona vértice na lista de vértices
-            self._matriz.append([])  # Adiciona a linha
+            self.vertices.append(v)  # Adiciona vértice na lista de vértices
+            self.arestas.append([])  # Adiciona a linha
 
             i_v = self.indice_do_vertice(v)
 
-            for k in range(len(self._vertices)):
-                self._matriz[k].append(dict())  # adiciona os elementos da coluna do vértice
-                self._matriz[i_v].append(dict())  # adiciona um zero no último elemento da linha
+            for k in range(len(self.vertices)):
+                self.arestas[k].append(dict())  # adiciona os elementos da coluna do vértice
+                self.arestas[i_v].append(dict())  # adiciona um zero no último elemento da linha
         else:
             raise VerticeInvalidoError('O vértice ' + rotulo + ' é inválido.')
 
     @dispatch(Vertice)
     def adiciona_vertice(self, v: Vertice):
         """
         Inclui um vértice no grafo se ele estiver no formato correto.
@@ -168,51 +168,51 @@
             VerticeInvalidoException: se o vértice já existe ou se ele não estiver no formato válido.
         """
         if GrafoMatrizAdjacenciaNaoDirecionado.existe_vertice(v):
             raise VerticeInvalidoError('O vértice {} já existe'.format(v))
 
         if self.vertice_valido(v):
 
-            self._vertices.append(v)  # Adiciona vértice na lista de vértices
-            self._matriz.append([])  # Adiciona a linha
+            self.vertices.append(v)  # Adiciona vértice na lista de vértices
+            self.arestas.append([])  # Adiciona a linha
 
             i_v = self.indice_do_vertice(v)
 
-            for k in range(len(self._vertices)):
-                self._matriz[k].append(dict())  # adiciona os elementos da coluna do vértice
-                self._matriz[i_v].append(dict())  # adiciona um zero no último elemento da linha
+            for k in range(len(self.vertices)):
+                self.arestas[k].append(dict())  # adiciona os elementos da coluna do vértice
+                self.arestas[i_v].append(dict())  # adiciona um zero no último elemento da linha
         else:
             raise VerticeInvalidoError('O vértice ' + str(v) + ' é inválido')
 
     def existe_aresta(self, aresta: Aresta) -> bool:
         """
         Verifica se uma aresta passada como parâmetro pertence ao grafo.
         Args:
             aresta: A aresta a ser verificada
         Returns:
             Um valor booleano que indica se a aresta existe no grafo.
         """
         if GrafoMatrizAdjacenciaNaoDirecionado.aresta_valida(self, aresta):
-            if aresta.rotulo in self._matriz[self.indice_do_vertice(aresta.v1)][self.indice_do_vertice(aresta.v2)]:
+            if aresta.rotulo in self.arestas[self.indice_do_vertice(aresta.v1)][self.indice_do_vertice(aresta.v2)]:
                 return True
         else:
             raise ArestaInvalidaError("A aresta passada como parâmetro é inválida.")
         return False
 
     def existe_rotulo_aresta(self, aresta: str) -> bool:
         """
         Verifica se uma aresta passada como parâmetro pertence ao grafo.
         Args:
             aresta: A aresta a ser verificada
         Returns:
             Um valor booleano que indica se a aresta existe no grafo.
         """
-        for i in range(len(self._matriz)):
-            for j in range(len(self._matriz)):
-                if self._matriz[i][j].get(aresta) is not None:
+        for i in range(len(self.arestas)):
+            for j in range(len(self.arestas)):
+                if self.arestas[i][j].get(aresta) is not None:
                     return True
         return False
 
     def aresta_valida(self, aresta: Aresta):
         """
         Verifica se uma aresta passada como parâmetro está dentro do padrão estabelecido.
         Uma aresta só é válida se conectar dois vértices existentes no grafo.
@@ -238,16 +238,16 @@
         """
         if self.existe_aresta(a):
             raise ArestaInvalidaError('A aresta {} já existe no Grafo'.format(a))
 
         if self.aresta_valida(a):
             i_a1 = self.indice_do_vertice(a.v1)
             i_a2 = self.indice_do_vertice(a.v2)
-            self._matriz[i_a1][i_a2][a.rotulo] = a
-            self._matriz[i_a2][i_a1][a.rotulo] = a
+            self.arestas[i_a1][i_a2][a.rotulo] = a
+            self.arestas[i_a2][i_a1][a.rotulo] = a
         else:
             raise ArestaInvalidaError('A aresta {} é inválida'.format(a))
 
         return True
 
     @dispatch(str, str, str, int)
     def adiciona_aresta(self, rotulo: str, v1: str, v2: str, peso=1):
@@ -296,16 +296,16 @@
             Retorna True se a aresta foi removida com sucesso.
         """
 
         def remove_com_indices(rotulo, v1_ind, v2_ind):
             """
             Função interna apenas para remover do dicionário de arestas, quando há índices conhecidos
             """
-            arestas_top = self._matriz[v1_ind][v2_ind]
-            arestas_bottom = self._matriz[v2_ind][v1_ind]
+            arestas_top = self.arestas[v1_ind][v2_ind]
+            arestas_bottom = self.arestas[v2_ind][v1_ind]
 
             if arestas_top.get(rotulo) is not None:
                 arestas_top.pop(rotulo)
 
             if arestas_bottom.get(rotulo) is not None:
                 arestas_bottom.pop(rotulo)
 
@@ -326,88 +326,88 @@
                     arestas_percorrer.pop(r)
 
         if not self.existe_rotulo_aresta(r):
             raise ArestaInvalidaError("A aresta não existe no grafo.")
 
         if v1 is None:
             if v2 is None:
-                for i in range(len(self._matriz)):
-                    for j in range(len(self._matriz)):
+                for i in range(len(self.arestas)):
+                    for j in range(len(self.arestas)):
                         remove_com_indices(r, i, j)
 
             elif self.existe_vertice(v2):
                 v2_i = self.indice_do_vertice(self.get_vertice(v2))
-                return percorre_e_remove(self._matriz, v2_i)
+                return percorre_e_remove(self.arestas, v2_i)
             elif not self.existe_vertice(self.get_vertice(v2)):
                 raise VerticeInvalidoError("O vértice {} é inválido!".format(v2))
 
         else:
             if self.existe_rotulo_vertice(v1):
                 v1_i = self.indice_do_vertice(self.get_vertice(v1))
                 if self.existe_vertice(v2):
                     v2_i = self.indice_do_vertice(self.get_vertice(v2))
                     remove_com_indices(r, v1_i, v2_i)
                 else:
-                    return percorre_e_remove(self._matriz, v1_i)
+                    return percorre_e_remove(self.arestas, v1_i)
             else:
                 raise VerticeInvalidoError("O vértice {} é inválido!".format(v1))
 
     def __eq__(self, other):
         """
         Define a igualdade entre a instância do grafo para o qual essa função foi chamada e a instância de um
         GrafoMatrizAdjacenciaNaoDirecionado passado como parâmetro.
         Args:
             other: O grafo que deve ser comparado com este grafo.
         Returns:
             Um valor booleano caso os grafos sejam iguais.
         """
-        if len(self._matriz) != len(other._matriz) or len(self._vertices) != len(other._vertices):
+        if len(self.arestas) != len(other.arestas) or len(self.vertices) != len(other.vertices):
             return False
-        for n in self._vertices:
+        for n in self.vertices:
             if not other.existe_vertice(n):
                 return False
-        for i in range(len(self._matriz)):
-            for j in range(len(self._matriz)):
-                if len(self._matriz[i][j]) != len(other._matriz[i][j]):
+        for i in range(len(self.arestas)):
+            for j in range(len(self.arestas)):
+                if len(self.arestas[i][j]) != len(other.arestas[i][j]):
                     return False
-                for k in self._matriz[i][j]:
-                    if k not in other._matriz[i][j]:
+                for k in self.arestas[i][j]:
+                    if k not in other.arestas[i][j]:
                         return False
         return True
 
     def __str__(self):
         """
         Fornece uma representação do tipo String do grafo.
         Returns:
             Uma string que representa o grafo
         """
 
         grafo_str = '  '
 
-        for v in range(len(self._vertices)):
-            grafo_str += str(self._vertices[v])
-            if v < (len(self._vertices) - 1):  # Só coloca o espaço se não for o último vértice
+        for v in range(len(self.vertices)):
+            grafo_str += str(self.vertices[v])
+            if v < (len(self.vertices) - 1):  # Só coloca o espaço se não for o último vértice
                 grafo_str += ' '
 
         grafo_str += '\n'
 
-        for m in range(len(self._matriz)):
-            grafo_str += str(self._vertices[m]) + ' '
-            for c in range(len(self._matriz)):
-                if self._matriz[m][c] == '-':
-                    grafo_str += str(self._matriz[m][c]) + ' '
+        for m in range(len(self.arestas)):
+            grafo_str += str(self.vertices[m]) + ' '
+            for c in range(len(self.arestas)):
+                if self.arestas[m][c] == '-':
+                    grafo_str += str(self.arestas[m][c]) + ' '
                 else:
-                    if bool(self._matriz[m][c]):
+                    if bool(self.arestas[m][c]):
                         grafo_str += '*' + ' '
                     else:
                         grafo_str += 'o' + ' '
             grafo_str += '\n'
 
-        for m in range(len(self._vertices)):
-            for c in range(len(self._vertices)):
-                if bool(self._matriz[m][c]) and m > c:
-                    grafo_str += str(self._vertices[m]) + '-' + str(self._vertices[c]) + ': '
-                    for k in self._matriz[m][c]:
+        for m in range(len(self.vertices)):
+            for c in range(len(self.vertices)):
+                if bool(self.arestas[m][c]) and m > c:
+                    grafo_str += str(self.vertices[m]) + '-' + str(self.vertices[c]) + ': '
+                    for k in self.arestas[m][c]:
                         grafo_str += k + ' | '
                     grafo_str += '\n'
 
         return grafo_str
```

## Comparing `bibgrafo-1.0.7.dist-info/RECORD` & `bibgrafo-1.1.0.dist-info/RECORD`

 * *Files 7% similar despite different names*

```diff
@@ -1,23 +1,23 @@
 bibgrafo/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-bibgrafo/aresta.py,sha256=lp_NlxzxAgqNfri5s1KoqcflOGJZPdAmXxD4CDFc-Wk,3773
+bibgrafo/aresta.py,sha256=8e3_Eh3JoXj_mesY1OCZ2-6ZNfV3UVU1KjQgZnEo8lU,3984
 bibgrafo/grafo.py,sha256=yWPZUk9PMQOZFqybiTCgDSns85MH5MUDMq9NkIiHMjk,6855
 bibgrafo/grafo_errors.py,sha256=sIoaMxfIx1psXbdLEJ_l0D2Ram_pbrfK6qJpeTosdPk,713
 bibgrafo/grafo_exceptions.py,sha256=Sdsmb3wBaXy4zJTiwUjP_Cku_EHk5Vxazix7m6HlXMU,155
-bibgrafo/grafo_lista_adj.py,sha256=pUvrfs6eM5bPf4ey5PJupcNi7r0andW3YcjcCj_BR6g,12940
+bibgrafo/grafo_lista_adj.py,sha256=OypKSZ7yLhse1X3HHEXMuT-HPMFwJBBqdbLXyuVIqeI,12909
 bibgrafo/grafo_lista_adjacencia.py,sha256=pUvrfs6eM5bPf4ey5PJupcNi7r0andW3YcjcCj_BR6g,12940
-bibgrafo/grafo_matriz_adj_dir.py,sha256=330fbfHQ7FGoSpvYdBu9BUH3kYUTXz1AdD8y71Vwrng,17623
-bibgrafo/grafo_matriz_adj_nao_dir.py,sha256=UT_q2mj6FjXWH8cIS7QW15r7VaCHvEOq9ZgLW0WJptA,16842
+bibgrafo/grafo_matriz_adj_dir.py,sha256=QAaDe7-uH1mielwPQV_woAO_W6bDx-4qRzkUv3fAA1A,17615
+bibgrafo/grafo_matriz_adj_nao_dir.py,sha256=sXNS28lYnYFP2cwmg42KV1WP6wMTcSdJSOPiMcM3KTM,16840
 bibgrafo/vertice.py,sha256=9ctmgaV9GVCdByPhaGCUDSRaC8IZjlNGm2T8RlrTEH0,2754
 bibgrafo/__pycache__/__init__.cpython-310.pyc,sha256=dA7VWjl50J1KL_6awjqb4IEzGkVXn-DxaG3AqvlrXQU,163
 bibgrafo/__pycache__/aresta.cpython-310.pyc,sha256=XyxtHQPK_wvQvEN-Z7ELNMnfRen1gaOzdyk3NbwIt94,4336
 bibgrafo/__pycache__/grafo.cpython-310.pyc,sha256=gyTCatwSP6noGX5YWsd2sSMh781ZTCvhZtaMCh1H1Ss,8151
 bibgrafo/__pycache__/grafo_errors.cpython-310.pyc,sha256=HhV3AYVbT_kgjrYmoDax9i_4xAilzcPIKI1Ua86Pa1M,1167
 bibgrafo/__pycache__/grafo_exceptions.cpython-310.pyc,sha256=l-kPwS-OdofdzBarVRHblvNUAbLkcaKbmQpshvXdXp0,602
 bibgrafo/__pycache__/grafo_lista_adjacencia.cpython-310.pyc,sha256=4xNVtb5a-k3d_e6BmGOIQimDTMTynNz4Hvi6vfaBP3Y,12527
 bibgrafo/__pycache__/grafo_matriz_adj_dir.cpython-310.pyc,sha256=G9gff0gFHwnYGzi0oOE5aH_q4y8U3vDrkPjvTEgCuFI,14589
 bibgrafo/__pycache__/grafo_matriz_adj_nao_dir.cpython-310.pyc,sha256=lJ_fS_Dq_Gk6l9NixhUruVScO1pynSX1dgsk2KdBMOc,12844
 bibgrafo/__pycache__/vertice.cpython-310.pyc,sha256=nAezojrL9IgTEC_a3BhAaF6Axo5AdF8J_S--gMeNdKQ,3478
-bibgrafo-1.0.7.dist-info/METADATA,sha256=246XQFhTaoFBX07q-SXmmFv4JjzcKkzvId2hbRm4V_E,234
-bibgrafo-1.0.7.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
-bibgrafo-1.0.7.dist-info/top_level.txt,sha256=g_rJvENg50O0A1685iHhZrkWq0gC1W-TtjiHcSgL_dA,9
-bibgrafo-1.0.7.dist-info/RECORD,,
+bibgrafo-1.1.0.dist-info/METADATA,sha256=XQNRE55l7SHv5tAWg1nZTicJi3Ooo3cAUhFv6_S_43c,234
+bibgrafo-1.1.0.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
+bibgrafo-1.1.0.dist-info/top_level.txt,sha256=g_rJvENg50O0A1685iHhZrkWq0gC1W-TtjiHcSgL_dA,9
+bibgrafo-1.1.0.dist-info/RECORD,,
```

